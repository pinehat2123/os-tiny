From 9ddcf116396e748a807cbbd2e85705b0d61d8d7c Mon Sep 17 00:00:00 2001
From: andre <12485443-Andre_HJR@users.noreply.gitlab.com>
Date: Sat, 11 Feb 2023 11:49:41 -0500
Subject: [PATCH 08/80] rm rubbish

---
 Cargo.toml                                    |  19 +-
 Makefile                                      |  12 +-
 allocator/Cargo.toml                          |  11 -
 allocator/src/lib.rs                          |  65 ---
 config/config.mk                              |  20 -
 config/lib_kernel_config.mk                   |  10 -
 config/lib_kernel_lib_config.mk               |  12 -
 config/lib_run.mk                             |  35 --
 config/mkEnv.mk                               |  19 -
 config/run.mk                                 |  58 ---
 console/Cargo.toml                            |  10 -
 console/src/lib.rs                            | 129 ------
 context/Cargo.toml                            |  12 -
 context/src/foreign.rs                        | 317 --------------
 context/src/lib.rs                            | 252 -----------
 easy-fs-fuse/Cargo.toml                       |  16 -
 easy-fs-fuse/rust-toolchain.toml              |   5 -
 easy-fs-fuse/src/main.rs                      | 155 -------
 easy-fs/Cargo.toml                            |  18 -
 easy-fs/src/bitmap.rs                         |  69 ---
 easy-fs/src/block_cache.rs                    | 142 ------
 easy-fs/src/block_dev.rs                      |   7 -
 easy-fs/src/efs.rs                            | 147 -------
 easy-fs/src/layout.rs                         | 409 ------------------
 easy-fs/src/lib.rs                            |  18 -
 easy-fs/src/vfs.rs                            | 186 --------
 kernel/Cargo.toml                             |   9 +-
 kernel/src/lib.rs                             |   8 +-
 kernel/src/trap/mod.rs                        |   3 +
 kernel_lib/.cargo/config.toml                 |   2 -
 kernel_lib/.gitignore                         |   2 -
 kernel_lib/Cargo.toml                         |  31 --
 kernel_lib/build.rs                           |  11 -
 kernel_lib/src/lib.rs                         |  32 --
 kernel_lib/src/plantform/arch/mod.rs          |   5 -
 .../src/plantform/arch/riscv64gc/asm/entry.S  |  11 -
 .../plantform/arch/riscv64gc/link/linker.ld   |  29 --
 .../src/plantform/arch/riscv64gc/mod.rs       |  28 --
 kernel_lib/src/plantform/mod.rs               |  29 --
 linker/Cargo.toml                             |   8 -
 linker/src/lib.rs                             | 320 --------------
 signal-defs/Cargo.toml                        |   9 -
 signal-defs/src/lib.rs                        |  96 ----
 signal-impl/Cargo.toml                        |  10 -
 signal-impl/src/default_action.rs             |  26 --
 signal-impl/src/lib.rs                        | 182 --------
 signal-impl/src/signal_set.rs                 |  70 ---
 signal/Cargo.toml                             |  10 -
 signal/src/lib.rs                             |  49 ---
 signal/src/signal_result.rs                   |  15 -
 sync/.cargo/config.toml                       |   2 -
 sync/Cargo.toml                               |  11 -
 sync/src/condvar.rs                           |  61 ---
 sync/src/lib.rs                               |  16 -
 sync/src/mutex.rs                             |  62 ---
 sync/src/semaphore.rs                         |  47 --
 sync/src/up.rs                                | 141 ------
 syscall/Cargo.toml                            |  15 -
 syscall/build.rs                              |  33 --
 syscall/src/io.rs                             |   3 -
 syscall/src/kernel.rs                         | 277 ------------
 syscall/src/lib.rs                            |  39 --
 syscall/src/syscall.h.in                      | 322 --------------
 syscall/src/syscalls.rs                       | 296 -------------
 syscall/src/time.rs                           |  79 ----
 syscall/src/user.rs                           | 296 -------------
 task-manage/Cargo.toml                        |  12 -
 task-manage/src/id.rs                         |  67 ---
 task-manage/src/lib.rs                        |  33 --
 task-manage/src/manager.rs                    |   9 -
 task-manage/src/proc_manage.rs                | 106 -----
 task-manage/src/proc_rel.rs                   |  78 ----
 task-manage/src/proc_thread_rel.rs            | 122 ------
 task-manage/src/scheduler.rs                  |   7 -
 task-manage/src/thread_manager.rs             | 193 ---------
 user/.cargo/config.toml                       |   7 -
 user/.gitignore                               |   1 -
 user/Cargo.toml                               |  19 -
 user/Makefile                                 |  29 --
 user/src/bin/adder.rs                         |  57 ---
 user/src/bin/adder_atomic.rs                  |  74 ----
 user/src/bin/adder_mutex_blocking.rs          |  61 ---
 user/src/bin/adder_mutex_spin.rs              |  62 ---
 user/src/bin/adder_peterson_spin.rs           |  95 ----
 user/src/bin/adder_peterson_yield.rs          |  94 ----
 user/src/bin/adder_simple_spin.rs             |  70 ---
 user/src/bin/adder_simple_yield.rs            |  72 ---
 user/src/bin/barrier_condvar.rs               |  83 ----
 user/src/bin/barrier_fail.rs                  |  33 --
 user/src/bin/cat.rs                           |  32 --
 user/src/bin/cmdline_args.rs                  |  16 -
 user/src/bin/condsync_condvar.rs              |  59 ---
 user/src/bin/condsync_sem.rs                  |  64 ---
 user/src/bin/count_lines.rs                   |  30 --
 user/src/bin/eisenberg.rs                     | 138 ------
 user/src/bin/exit.rs                          |  30 --
 user/src/bin/fantastic_text.rs                |  44 --
 user/src/bin/filetest_simple.rs               |  29 --
 user/src/bin/forktest.rs                      |  34 --
 user/src/bin/forktest2.rs                     |  34 --
 user/src/bin/forktest_simple.rs               |  28 --
 user/src/bin/forktree.rs                      |  45 --
 user/src/bin/gui_rect.rs                      |  71 ---
 user/src/bin/gui_simple.rs                    |  23 -
 user/src/bin/gui_snake.rs                     | 351 ---------------
 user/src/bin/gui_uart.rs                      | 125 ------
 user/src/bin/hello_world.rs                   |  11 -
 user/src/bin/huge_write.rs                    |  33 --
 user/src/bin/huge_write_mt.rs                 |  56 ---
 user/src/bin/infloop.rs                       |  10 -
 user/src/bin/initproc.rs                      |  30 --
 user/src/bin/inputdev_event.rs                |  25 --
 user/src/bin/matrix.rs                        |  69 ---
 user/src/bin/mpsc_sem.rs                      |  73 ----
 user/src/bin/peterson.rs                      |  80 ----
 user/src/bin/phil_din_mutex.rs                | 107 -----
 user/src/bin/pipe_large_test.rs               |  71 ---
 user/src/bin/pipetest.rs                      |  44 --
 user/src/bin/priv_csr.rs                      |  17 -
 user/src/bin/priv_inst.rs                     |  17 -
 user/src/bin/race_adder_arg.rs                |  56 ---
 user/src/bin/random_num.rs                    |  16 -
 user/src/bin/run_pipe_test.rs                 |  21 -
 user/src/bin/sleep.rs                         |  30 --
 user/src/bin/sleep_simple.rs                  |  23 -
 user/src/bin/stack_overflow.rs                |  20 -
 user/src/bin/stackful_coroutine.rs            | 350 ---------------
 user/src/bin/stackless_coroutine.rs           | 129 ------
 user/src/bin/store_fault.rs                   |  15 -
 user/src/bin/sync_sem.rs                      |  45 --
 user/src/bin/threads.rs                       |  45 --
 user/src/bin/threads_arg.rs                   |  44 --
 user/src/bin/until_timeout.rs                 |  46 --
 user/src/bin/user_shell.rs                    | 214 ---------
 user/src/bin/usertests.rs                     | 145 -------
 user/src/bin/yield.rs                         |  17 -
 user/src/console.rs                           |  39 --
 user/src/file.rs                              |  30 --
 user/src/io.rs                                | 116 -----
 user/src/lang_items.rs                        |  18 -
 user/src/lib.rs                               |  89 ----
 user/src/linker.ld                            |  32 --
 user/src/sync.rs                              |  32 --
 user/src/syscall.rs                           | 176 --------
 user/src/task.rs                              |  82 ----
 user_libs/Cargo.toml                          |  10 -
 user_libs/README.md                           |   8 -
 user_libs/build.rs                            |  40 --
 user_libs/cases.toml                          | 124 ------
 user_libs/src/bin/00hello_world.rs            |  11 -
 user_libs/src/bin/01store_fault.rs            |  13 -
 user_libs/src/bin/02power.rs                  |  27 --
 user_libs/src/bin/03priv_inst.rs              |  13 -
 user_libs/src/bin/04priv_csr.rs               |  13 -
 user_libs/src/bin/05write_a.rs                |  23 -
 user_libs/src/bin/06write_b.rs                |  23 -
 user_libs/src/bin/07write_c.rs                |  23 -
 user_libs/src/bin/08power_3.rs                |  28 --
 user_libs/src/bin/09power_5.rs                |  28 --
 user_libs/src/bin/10power_7.rs                |  28 --
 user_libs/src/bin/11sleep.rs                  |  24 -
 user_libs/src/bin/12forktest.rs               |  34 --
 user_libs/src/bin/13forktree.rs               |  45 --
 user_libs/src/bin/14forktest2.rs              |  37 --
 user_libs/src/bin/15matrix.rs                 |  71 ---
 user_libs/src/bin/cat_filea.rs                |  27 --
 user_libs/src/bin/filetest_simple.rs          |  29 --
 user_libs/src/bin/initproc.rs                 |  30 --
 user_libs/src/bin/mpsc_sem.rs                 |  73 ----
 .../src/bin/race_adder_mutex_blocking.rs      |  52 ---
 user_libs/src/bin/sig_ctrlc.rs                |  40 --
 user_libs/src/bin/sig_simple.rs               |  30 --
 user_libs/src/bin/sig_simple2.rs              |  43 --
 user_libs/src/bin/sig_tests.rs                | 208 ---------
 user_libs/src/bin/sync_sem.rs                 |  45 --
 user_libs/src/bin/test_condvar.rs             |  59 ---
 user_libs/src/bin/threads.rs                  |  56 ---
 user_libs/src/bin/threads_arg.rs              |  44 --
 user_libs/src/bin/user_shell.rs               |  63 ---
 user_libs/src/heap.rs                         |  44 --
 user_libs/src/lib.rs                          |  81 ----
 vm/Cargo.toml                                 |  10 -
 vm/src/lib.rs                                 |  45 --
 vm/src/space/mapper.rs                        |  69 ---
 vm/src/space/mod.rs                           | 147 -------
 vm/src/space/visitor.rs                       |  45 --
 186 files changed, 26 insertions(+), 11695 deletions(-)
 delete mode 100644 allocator/Cargo.toml
 delete mode 100644 allocator/src/lib.rs
 delete mode 100644 config/config.mk
 delete mode 100644 config/lib_kernel_config.mk
 delete mode 100644 config/lib_kernel_lib_config.mk
 delete mode 100644 config/lib_run.mk
 delete mode 100644 config/mkEnv.mk
 delete mode 100644 config/run.mk
 delete mode 100644 console/Cargo.toml
 delete mode 100644 console/src/lib.rs
 delete mode 100644 context/Cargo.toml
 delete mode 100644 context/src/foreign.rs
 delete mode 100644 context/src/lib.rs
 delete mode 100644 easy-fs-fuse/Cargo.toml
 delete mode 100644 easy-fs-fuse/rust-toolchain.toml
 delete mode 100644 easy-fs-fuse/src/main.rs
 delete mode 100644 easy-fs/Cargo.toml
 delete mode 100644 easy-fs/src/bitmap.rs
 delete mode 100644 easy-fs/src/block_cache.rs
 delete mode 100644 easy-fs/src/block_dev.rs
 delete mode 100644 easy-fs/src/efs.rs
 delete mode 100644 easy-fs/src/layout.rs
 delete mode 100644 easy-fs/src/lib.rs
 delete mode 100644 easy-fs/src/vfs.rs
 delete mode 100644 kernel_lib/.cargo/config.toml
 delete mode 100644 kernel_lib/.gitignore
 delete mode 100644 kernel_lib/Cargo.toml
 delete mode 100644 kernel_lib/build.rs
 delete mode 100644 kernel_lib/src/lib.rs
 delete mode 100644 kernel_lib/src/plantform/arch/mod.rs
 delete mode 100644 kernel_lib/src/plantform/arch/riscv64gc/asm/entry.S
 delete mode 100644 kernel_lib/src/plantform/arch/riscv64gc/link/linker.ld
 delete mode 100644 kernel_lib/src/plantform/arch/riscv64gc/mod.rs
 delete mode 100644 kernel_lib/src/plantform/mod.rs
 delete mode 100644 linker/Cargo.toml
 delete mode 100644 linker/src/lib.rs
 delete mode 100644 signal-defs/Cargo.toml
 delete mode 100644 signal-defs/src/lib.rs
 delete mode 100644 signal-impl/Cargo.toml
 delete mode 100644 signal-impl/src/default_action.rs
 delete mode 100644 signal-impl/src/lib.rs
 delete mode 100644 signal-impl/src/signal_set.rs
 delete mode 100644 signal/Cargo.toml
 delete mode 100644 signal/src/lib.rs
 delete mode 100644 signal/src/signal_result.rs
 delete mode 100644 sync/.cargo/config.toml
 delete mode 100644 sync/Cargo.toml
 delete mode 100644 sync/src/condvar.rs
 delete mode 100644 sync/src/lib.rs
 delete mode 100644 sync/src/mutex.rs
 delete mode 100644 sync/src/semaphore.rs
 delete mode 100644 sync/src/up.rs
 delete mode 100644 syscall/Cargo.toml
 delete mode 100644 syscall/build.rs
 delete mode 100644 syscall/src/io.rs
 delete mode 100644 syscall/src/kernel.rs
 delete mode 100644 syscall/src/lib.rs
 delete mode 100644 syscall/src/syscall.h.in
 delete mode 100644 syscall/src/syscalls.rs
 delete mode 100644 syscall/src/time.rs
 delete mode 100644 syscall/src/user.rs
 delete mode 100644 task-manage/Cargo.toml
 delete mode 100644 task-manage/src/id.rs
 delete mode 100644 task-manage/src/lib.rs
 delete mode 100644 task-manage/src/manager.rs
 delete mode 100644 task-manage/src/proc_manage.rs
 delete mode 100644 task-manage/src/proc_rel.rs
 delete mode 100644 task-manage/src/proc_thread_rel.rs
 delete mode 100644 task-manage/src/scheduler.rs
 delete mode 100644 task-manage/src/thread_manager.rs
 delete mode 100644 user/.cargo/config.toml
 delete mode 100644 user/.gitignore
 delete mode 100644 user/Cargo.toml
 delete mode 100644 user/Makefile
 delete mode 100644 user/src/bin/adder.rs
 delete mode 100644 user/src/bin/adder_atomic.rs
 delete mode 100644 user/src/bin/adder_mutex_blocking.rs
 delete mode 100644 user/src/bin/adder_mutex_spin.rs
 delete mode 100644 user/src/bin/adder_peterson_spin.rs
 delete mode 100644 user/src/bin/adder_peterson_yield.rs
 delete mode 100644 user/src/bin/adder_simple_spin.rs
 delete mode 100644 user/src/bin/adder_simple_yield.rs
 delete mode 100644 user/src/bin/barrier_condvar.rs
 delete mode 100644 user/src/bin/barrier_fail.rs
 delete mode 100644 user/src/bin/cat.rs
 delete mode 100644 user/src/bin/cmdline_args.rs
 delete mode 100644 user/src/bin/condsync_condvar.rs
 delete mode 100644 user/src/bin/condsync_sem.rs
 delete mode 100644 user/src/bin/count_lines.rs
 delete mode 100644 user/src/bin/eisenberg.rs
 delete mode 100644 user/src/bin/exit.rs
 delete mode 100644 user/src/bin/fantastic_text.rs
 delete mode 100644 user/src/bin/filetest_simple.rs
 delete mode 100644 user/src/bin/forktest.rs
 delete mode 100644 user/src/bin/forktest2.rs
 delete mode 100644 user/src/bin/forktest_simple.rs
 delete mode 100644 user/src/bin/forktree.rs
 delete mode 100644 user/src/bin/gui_rect.rs
 delete mode 100644 user/src/bin/gui_simple.rs
 delete mode 100644 user/src/bin/gui_snake.rs
 delete mode 100644 user/src/bin/gui_uart.rs
 delete mode 100644 user/src/bin/hello_world.rs
 delete mode 100644 user/src/bin/huge_write.rs
 delete mode 100644 user/src/bin/huge_write_mt.rs
 delete mode 100644 user/src/bin/infloop.rs
 delete mode 100644 user/src/bin/initproc.rs
 delete mode 100644 user/src/bin/inputdev_event.rs
 delete mode 100644 user/src/bin/matrix.rs
 delete mode 100644 user/src/bin/mpsc_sem.rs
 delete mode 100644 user/src/bin/peterson.rs
 delete mode 100644 user/src/bin/phil_din_mutex.rs
 delete mode 100644 user/src/bin/pipe_large_test.rs
 delete mode 100644 user/src/bin/pipetest.rs
 delete mode 100644 user/src/bin/priv_csr.rs
 delete mode 100644 user/src/bin/priv_inst.rs
 delete mode 100644 user/src/bin/race_adder_arg.rs
 delete mode 100644 user/src/bin/random_num.rs
 delete mode 100644 user/src/bin/run_pipe_test.rs
 delete mode 100644 user/src/bin/sleep.rs
 delete mode 100644 user/src/bin/sleep_simple.rs
 delete mode 100644 user/src/bin/stack_overflow.rs
 delete mode 100644 user/src/bin/stackful_coroutine.rs
 delete mode 100644 user/src/bin/stackless_coroutine.rs
 delete mode 100644 user/src/bin/store_fault.rs
 delete mode 100644 user/src/bin/sync_sem.rs
 delete mode 100644 user/src/bin/threads.rs
 delete mode 100644 user/src/bin/threads_arg.rs
 delete mode 100644 user/src/bin/until_timeout.rs
 delete mode 100644 user/src/bin/user_shell.rs
 delete mode 100644 user/src/bin/usertests.rs
 delete mode 100644 user/src/bin/yield.rs
 delete mode 100644 user/src/console.rs
 delete mode 100644 user/src/file.rs
 delete mode 100644 user/src/io.rs
 delete mode 100644 user/src/lang_items.rs
 delete mode 100644 user/src/lib.rs
 delete mode 100644 user/src/linker.ld
 delete mode 100644 user/src/sync.rs
 delete mode 100644 user/src/syscall.rs
 delete mode 100644 user/src/task.rs
 delete mode 100644 user_libs/Cargo.toml
 delete mode 100644 user_libs/README.md
 delete mode 100644 user_libs/build.rs
 delete mode 100644 user_libs/cases.toml
 delete mode 100644 user_libs/src/bin/00hello_world.rs
 delete mode 100644 user_libs/src/bin/01store_fault.rs
 delete mode 100644 user_libs/src/bin/02power.rs
 delete mode 100644 user_libs/src/bin/03priv_inst.rs
 delete mode 100644 user_libs/src/bin/04priv_csr.rs
 delete mode 100644 user_libs/src/bin/05write_a.rs
 delete mode 100644 user_libs/src/bin/06write_b.rs
 delete mode 100644 user_libs/src/bin/07write_c.rs
 delete mode 100644 user_libs/src/bin/08power_3.rs
 delete mode 100644 user_libs/src/bin/09power_5.rs
 delete mode 100644 user_libs/src/bin/10power_7.rs
 delete mode 100644 user_libs/src/bin/11sleep.rs
 delete mode 100644 user_libs/src/bin/12forktest.rs
 delete mode 100644 user_libs/src/bin/13forktree.rs
 delete mode 100644 user_libs/src/bin/14forktest2.rs
 delete mode 100644 user_libs/src/bin/15matrix.rs
 delete mode 100644 user_libs/src/bin/cat_filea.rs
 delete mode 100644 user_libs/src/bin/filetest_simple.rs
 delete mode 100644 user_libs/src/bin/initproc.rs
 delete mode 100644 user_libs/src/bin/mpsc_sem.rs
 delete mode 100644 user_libs/src/bin/race_adder_mutex_blocking.rs
 delete mode 100644 user_libs/src/bin/sig_ctrlc.rs
 delete mode 100644 user_libs/src/bin/sig_simple.rs
 delete mode 100644 user_libs/src/bin/sig_simple2.rs
 delete mode 100644 user_libs/src/bin/sig_tests.rs
 delete mode 100644 user_libs/src/bin/sync_sem.rs
 delete mode 100644 user_libs/src/bin/test_condvar.rs
 delete mode 100644 user_libs/src/bin/threads.rs
 delete mode 100644 user_libs/src/bin/threads_arg.rs
 delete mode 100644 user_libs/src/bin/user_shell.rs
 delete mode 100644 user_libs/src/heap.rs
 delete mode 100644 user_libs/src/lib.rs
 delete mode 100644 vm/Cargo.toml
 delete mode 100644 vm/src/lib.rs
 delete mode 100644 vm/src/space/mapper.rs
 delete mode 100644 vm/src/space/mod.rs
 delete mode 100644 vm/src/space/visitor.rs

diff --git a/Cargo.toml b/Cargo.toml
index 51699c9..b468543 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,23 +1,20 @@
 [workspace]
 members = [
     "kernel", 
+    "tconfig",
+    "drivers",
     "xtask", 
-    "easy-fs", "easy-fs-fuse",
-    "user",
+    "application/easy-fs", "application/easy-fs-fuse",
+    "application/user",
     ]
 default-members = ["xtask"]
 
 exclude = [
     "mod_mgmt",
-    "kernel_lib",
-    "linker", 
-    "console",
-    "allocator", 
-    "context", 
-    "syscall",
-    "signal-defs", "signal-impl", "signal",
-    "task-manage", "sync",
-    "vm", "user_libs",
+    "other_libs/*",
+    "easy-fs",
+    "easy-fs-fuse",
+    "user"
     ]
 
 
diff --git a/Makefile b/Makefile
index 136f5bf..6eaa8ce 100644
--- a/Makefile
+++ b/Makefile
@@ -1,8 +1,6 @@
 # This is `Makefile`
 
-PJ ?= LIBs
-
-include config/mkEnv.mk
+include mkConfig/mkEnv.mk
 
 .PHONY: check \
 		simple \
@@ -17,15 +15,11 @@ check:
 	${CROSS_LD} --version;
 	${CROSS_GDB} --version;
 
-ifeq ($(PJ), LIB)
-include  config/lib_run.mk
-else
-include  config/run.mk
-endif
+include  mkConfig/run.mk
 
 clean:
 # for easy-fs-fuse
-	@cd easy-fs-fuse && cargo clean
+	@cd application/easy-fs-fuse && cargo clean
 	@${PERL} ./script/simple-clean clean
 
 gitlab:
diff --git a/allocator/Cargo.toml b/allocator/Cargo.toml
deleted file mode 100644
index 3caf5b8..0000000
--- a/allocator/Cargo.toml
+++ /dev/null
@@ -1,11 +0,0 @@
-[package]
-name = "allocator"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-log = "0.4"
-customizable-buddy = "0.0.3"
-page-table = "0.0.6"
\ No newline at end of file
diff --git a/allocator/src/lib.rs b/allocator/src/lib.rs
deleted file mode 100644
index 75c5155..0000000
--- a/allocator/src/lib.rs
+++ /dev/null
@@ -1,65 +0,0 @@
-//! 内存分配。
-
-#![no_std]
-#![deny(warnings, missing_docs)]
-
-extern crate alloc;
-
-use alloc::alloc::handle_alloc_error;
-use core::{
-    alloc::{GlobalAlloc, Layout},
-    ptr::NonNull,
-};
-use customizable_buddy::{BuddyAllocator, LinkedListBuddy, UsizeBuddy};
-
-/// 初始化内存分配。
-///
-/// 参数 `base_address` 表示动态内存区域的起始位置。
-#[inline]
-pub fn init(base_address: usize) {
-    unsafe {
-        HEAP.init(
-            core::mem::size_of::<usize>().trailing_zeros() as _,
-            NonNull::new(base_address as *mut u8).unwrap(),
-        )
-    };
-}
-
-/// 将一个内存块托管到内存分配器。
-///
-/// # Safety
-///
-/// `region` 内存块的所有权将转移到分配器，因此需要调用者确保这个内存块与已经转移到分配器的内存块都不重叠，且未被其他对象引用。
-/// 并且这个内存块必须位于初始化时传入的起始位置之后。
-#[inline]
-pub unsafe fn transfer(region: &'static mut [u8]) {
-    let ptr = NonNull::new(region.as_mut_ptr()).unwrap();
-    HEAP.transfer(ptr, region.len());
-}
-
-/// 堆分配器。
-///
-/// 最大容量：6 + 21 + 3 = 30 -> 1 GiB。
-/// 不考虑并发使用，因此没有加锁。
-static mut HEAP: BuddyAllocator<21, UsizeBuddy, LinkedListBuddy> = BuddyAllocator::new();
-
-struct Global;
-
-#[global_allocator]
-static GLOBAL: Global = Global;
-
-unsafe impl GlobalAlloc for Global {
-    #[inline]
-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
-        if let Ok((ptr, _)) = HEAP.allocate_layout::<u8>(layout) {
-            ptr.as_ptr()
-        } else {
-            handle_alloc_error(layout)
-        }
-    }
-
-    #[inline]
-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
-        HEAP.deallocate_layout(NonNull::new(ptr).unwrap(), layout)
-    }
-}
diff --git a/config/config.mk b/config/config.mk
deleted file mode 100644
index d8cb254..0000000
--- a/config/config.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-# Basic directory/firl path definitions used throughout the Makefiel
-
-OS_ARCH                   ?= riscv64gc
-TARGET                    ?= $(OS_ARCH)-unknown-none-elf
-BUILD_MODE                ?= release
-
-ROOT_DIR                  := $(abspath $(dir $(lastword $(MAKEFILE_LIST)))/..)
-
-BOOTLOADER                := rustsbi-qemu.bin
-
-BUILD_DIR                 :=  $(ROOT_DIR)/target
-KERNEL_BUILD_DIR          :=  $(BUILD_DIR)/$(TARGET)/$(BUILD_MODE)
-
-BUILD_TARGET              := $(ROOT_DIR)/build
-
-ifeq ($(PJ), LIB)
-	include config/lib_kernel_lib_config.mk
-else
-	include config/lib_kernel_config.mk
-endif
\ No newline at end of file
diff --git a/config/lib_kernel_config.mk b/config/lib_kernel_config.mk
deleted file mode 100644
index 34c8879..0000000
--- a/config/lib_kernel_config.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-BUILD_TARGET_KERNEL       := $(BUILD_TARGET)/kernel
-kernel_static_lib         := $(BUILD_TARGET_KERNEL)/libkernel.a
-kernel_binary             := $(BUILD_TARGET_KERNEL)/kernel.bin
-
-BUILD_TARGET_ASM          := $(BUILD_TARGET)/asm
-# kernel_asm                := kernel/src/plantform/arch/riscv64gc/asm/entry.S
-# compiled_kernel_asm       := $(BUILD_TARGET_ASM)/entry.o
-
-linker_script             := kernel/src/plantform/arch/riscv64gc/link/linker.ld
-BUILD_TARGET_ABI          := riscv64gc-unknown-none-elf
\ No newline at end of file
diff --git a/config/lib_kernel_lib_config.mk b/config/lib_kernel_lib_config.mk
deleted file mode 100644
index ffbf24b..0000000
--- a/config/lib_kernel_lib_config.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-KERNEL_LIB_BUILD_DIR          :=  $(BUILD_DIR)/$(TARGET)/$(BUILD_MODE)
-
-BUILD_TARGET_KERNEL_LIB   := $(BUILD_TARGET)/kernel_lib
-kernel_lib_static_lib     := $(BUILD_TARGET_KERNEL_LIB)/libkernel_lib.a
-kernel_lib_binary         := $(BUILD_TARGET_KERNEL_LIB)/kernel_lib.bin
-
-BUILD_TARGET_ASM          := $(BUILD_TARGET)/asm
-kernel_lib_asm            := kernel_lib/src/plantform/arch/riscv64gc/asm/entry.S
-compiled_kernel_lib_asm   := $(BUILD_TARGET_ASM)/entry.o
-
-linker_script_lib         := kernel_lib/src/plantform/arch/riscv64gc/link/linker.ld
-BUILD_TARGET_ABI          := riscv64gc-unknown-none-elf
\ No newline at end of file
diff --git a/config/lib_run.mk b/config/lib_run.mk
deleted file mode 100644
index 79959cc..0000000
--- a/config/lib_run.mk
+++ /dev/null
@@ -1,35 +0,0 @@
-include config/config.mk
-.PHONY: kernel_lib lib-run lib-run-inner $(kernel_lib_binary)
-kernel_lib: 
-	@${INFO} "DEAL WITH Kernel Lib"
-	@${INFO} "Build/Kernel_Lib"
-	@${MKDIR} -p build/kernel_lib
-	@${CARGO} build -p kernel_lib --${BUILD_MODE} --target ${BUILD_TARGET_ABI}
-	@${INFO} "move to Build/Kernel_Lib and \e[35mKernel Static Lib OK\e[0m"
-	@${CP} ${KERNEL_LIB_BUILD_DIR}/libkernel_lib.a ${BUILD_TARGET_KERNEL_LIB}/
-	@${INFO} "Build/Asm"
-	@${MKDIR} -p build/asm
-	${CROSS_AS} -c $(kernel_lib_asm) -o $(compiled_kernel_lib_asm)
-	@${INFO} "move to Build/Asm and \e[35mKernel ASM OK\e[0m"
-	@${INFO} "Kernel Lib build finish."
-
-
-	
-## This builds the kernel binary itself, which is the fully-linked code that first runs right after the bootloader
-$(kernel_lib_binary): $(kernel_lib_static_lib) $(linker_script_lib)
-	$(CROSS_LD) -n -T $(linker_script_lib) -o $(kernel_lib_binary) $(compiled_kernel_lib_asm) $(kernel_lib_static_lib)
-
-
-lib-run:
-	@${MAKE} clean && ${MAKE} kernel_lib && ${MAKE} ${kernel_lib_binary}
-	@${MAKE} lib-run-inner --no-print-directory
-	@${NEWLINE}
-	@${INFO} "Kernel Lib Run finish."
-	@${MAKE} clean
-
-lib-run-inner:
-	qemu-system-riscv64 \
-		-machine virt \
-		-nographic \
-		-bios $(BOOTLOADER) \
-		-device loader,file=$(kernel_lib_binary),addr=80200000
diff --git a/config/mkEnv.mk b/config/mkEnv.mk
deleted file mode 100644
index c173193..0000000
--- a/config/mkEnv.mk
+++ /dev/null
@@ -1,19 +0,0 @@
-TOOLS_DIR     := ./tools
-RISCV_DIR     := ${TOOLS_DIR}/riscv
-RISCV_BIN_DIR := ${RISCV_DIR}/bin
-
-AUTHOR := [my]
-
-MAKE        ?= make
-MKDIR       ?= mkdir
-CP          ?= cp
-CARGO       ?= cargo 
-BASH        ?= /bin/bash
-PERL        ?= perl
-CROSS       ?=  riscv64-unknown-linux-gnu-
-CROSS_AS    ?= ${RISCV_BIN_DIR}/${CROSS}as
-CROSS_LD    ?= ${RISCV_BIN_DIR}/${CROSS}ld
-CROSS_GDB   ?= ${RISCV_BIN_DIR}/${CROSS}gdb
-PRINT       ?= /bin/echo -e "\e[37m\e[4mPRINT\e[0m "
-INFO        ?= /bin/echo -e "\e[34mNOTE\e[0m "
-NEWLINE     ?= /bin/echo -e "\n"
diff --git a/config/run.mk b/config/run.mk
deleted file mode 100644
index 7686526..0000000
--- a/config/run.mk
+++ /dev/null
@@ -1,58 +0,0 @@
-include config/config.mk
-.PHONY: kernel run run-inner $(kernel_binary)
-kernel: 
-	@${INFO} "DEAL WITH Kernel"
-	@${INFO} "Build/Kernel"
-	@${MKDIR} -p build/kernel
-	@${CARGO} build -p kernel --${BUILD_MODE} --target  $(BUILD_TARGET_ABI)
-	@${INFO} "move to Build/Kernel and \e[35mKernel Static Lib OK\e[0m"
-	@${CP} ${KERNEL_BUILD_DIR}/libkernel.a ${BUILD_TARGET_KERNEL}/
-# @${INFO} "Build/Asm"
-# @${MKDIR} -p build/asm
-# ${CROSS_AS} -c $(kernel_asm) -o $(compiled_kernel_asm)
-# @${INFO} "move to Build/Asm and \e[35mKernel ASM OK\e[0m"
-	@${INFO} "Kernel build finish."
-
-
-	
-## This builds the kernel binary itself, which is the fully-linked code that first runs right after the bootloader
-$(kernel_binary): $(kernel_static_lib) $(linker_script)
-	$(CROSS_LD) -n --static -T $(linker_script) -o $(kernel_binary) $(compiled_kernel_asm) $(kernel_static_lib)
-
-
-run:
-	@${MAKE} clean && ${MAKE} kernel && ${MAKE} ${kernel_binary} && ${MAKE} fs-img
-	@${MAKE} run-inner --no-print-directory
-	@${NEWLINE}
-	@${INFO} "Kernel Run finish."
-	@${MAKE} clean
-
-orun:
-	@${MAKE} clean && ${MAKE} kernel && ${MAKE} ${kernel_binary} && ${MAKE} fs-img
-	@${NEWLINE}
-	@${INFO} "Kernel Run finish."
-
-FS_IMG                    := target/$(TARGET)/$(MODE)fs.img
-APPS                      := user/src/bin/*
-
-fs-img: $(APPS)
-	@mkdir -p build/apps
-	@cd user && make build TEST=$(TEST)
-	@rm -f $(FS_IMG)
-	@cd easy-fs-fuse && cargo run --release -- -s ../user/src/bin/ -t ../target/riscv64gc-unknown-none-elf/release/
-	@mv target/riscv64gc-unknown-none-elf/release/fs.img build/apps
-
-run-inner:
-	qemu-system-riscv64 \
-		-machine virt \
-		-display none\
-		-nographic \
-		-bios $(BOOTLOADER) \
-		-device loader,file=$(kernel_binary),addr=80200000\
-		-drive file=build/apps/fs.img,if=none,format=raw,id=x0 \
-        -device virtio-blk-device,drive=x0 \
-		-device virtio-gpu-device  \
-		-device virtio-keyboard-device  \
-		-device virtio-mouse-device
-
-# -drive file=$(FS_IMG),if=none,format=raw,id=x0
diff --git a/console/Cargo.toml b/console/Cargo.toml
deleted file mode 100644
index a37eb47..0000000
--- a/console/Cargo.toml
+++ /dev/null
@@ -1,10 +0,0 @@
-[package]
-name = "console"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-log = "0.4.17"
-spin = "0.9.4"
diff --git a/console/src/lib.rs b/console/src/lib.rs
deleted file mode 100644
index 2742756..0000000
--- a/console/src/lib.rs
+++ /dev/null
@@ -1,129 +0,0 @@
-//! 提供可定制实现的 `print!`、`println!` 和 `log::Log`。
-
-#![no_std]
-#![deny(warnings, missing_docs)]
-
-use core::{
-    fmt::{self, Write},
-    str::FromStr,
-};
-use spin::Once;
-
-/// 向用户提供 `log`。
-pub extern crate log;
-
-/// 这个接口定义了向控制台“输出”这件事。
-pub trait Console: Sync {
-    /// 向控制台放置一个字符。
-    fn put_char(&self, c: u8);
-
-    /// 向控制台放置一个字符串。
-    ///
-    /// 如果使用了锁，覆盖这个实现以免反复获取和释放锁。
-    #[inline]
-    fn put_str(&self, s: &str) {
-        for c in s.bytes() {
-            self.put_char(c);
-        }
-    }
-}
-
-/// 库找到输出的方法：保存一个对象引用，这是一种单例。
-static CONSOLE: Once<&'static dyn Console> = Once::new();
-
-/// 用户调用这个函数设置输出的方法。
-pub fn init_console(console: &'static dyn Console) {
-    CONSOLE.call_once(|| console);
-    log::set_logger(&Logger).unwrap();
-}
-
-/// 根据环境变量设置日志级别。
-pub fn set_log_level(env: Option<&str>) {
-    use log::LevelFilter as Lv;
-    log::set_max_level(env.and_then(|s| Lv::from_str(s).ok()).unwrap_or(Lv::Trace));
-}
-
-/// 打印一些测试信息。
-pub fn test_log() {
-    println!(
-        r"
-   ______                       __
-  / ____/___  ____  _________  / /__
- / /   / __ \/ __ \/ ___/ __ \/ / _ \
-/ /___/ /_/ / / / (__  ) /_/ / /  __/
-\____/\____/_/ /_/____/\____/_/\___/
-===================================="
-    );
-    log::trace!("LOG TEST >> Hello, world!");
-    log::debug!("LOG TEST >> Hello, world!");
-    log::info!("LOG TEST >> Hello, world!");
-    log::warn!("LOG TEST >> Hello, world!");
-    log::error!("LOG TEST >> Hello, world!");
-    println!();
-}
-
-/// 打印。
-///
-/// 给宏用的，用户不会直接调它。
-#[doc(hidden)]
-#[inline]
-pub fn _print(args: fmt::Arguments) {
-    Logger.write_fmt(args).unwrap();
-}
-
-/// 格式化打印。
-#[macro_export]
-macro_rules! print {
-    ($($arg:tt)*) => {
-        $crate::_print(core::format_args!($($arg)*));
-    }
-}
-
-/// 格式化打印并换行。
-#[macro_export]
-macro_rules! println {
-    () => ($crate::print!("\n"));
-    ($($arg:tt)*) => {{
-        $crate::_print(core::format_args!($($arg)*));
-        $crate::println!();
-    }}
-}
-
-/// 这个 Unit struct 是 `core::fmt` 要求的。
-struct Logger;
-
-/// 实现 [`Write`] trait，格式化的基础。
-impl Write for Logger {
-    #[inline]
-    fn write_str(&mut self, s: &str) -> Result<(), fmt::Error> {
-        let _ = CONSOLE.get().unwrap().put_str(s);
-        Ok(())
-    }
-}
-
-/// 实现 `log::Log` trait，提供分级日志。
-impl log::Log for Logger {
-    #[inline]
-    fn enabled(&self, _metadata: &log::Metadata) -> bool {
-        true
-    }
-
-    #[inline]
-    fn log(&self, record: &log::Record) {
-        use log::Level::*;
-        let color_code: u8 = match record.level() {
-            Error => 31,
-            Warn => 93,
-            Info => 34,
-            Debug => 32,
-            Trace => 90,
-        };
-        println!(
-            "\x1b[{color_code}m[{:>5}] {}\x1b[0m",
-            record.level(),
-            record.args(),
-        );
-    }
-
-    fn flush(&self) {}
-}
diff --git a/context/Cargo.toml b/context/Cargo.toml
deleted file mode 100644
index 9c6db09..0000000
--- a/context/Cargo.toml
+++ /dev/null
@@ -1,12 +0,0 @@
-[package]
-name = "context"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[features]
-foreign = ["spin"]
-
-[dependencies]
-spin = { version = "0.9.4", optional = true }
\ No newline at end of file
diff --git a/context/src/foreign.rs b/context/src/foreign.rs
deleted file mode 100644
index 1939716..0000000
--- a/context/src/foreign.rs
+++ /dev/null
@@ -1,317 +0,0 @@
-mod multislot_portal {
-    use super::{MonoForeignPortal, PortalCache, PORTAL_TEXT};
-
-    /// 包含多个插槽的异界传送门。
-    #[repr(C)]
-    pub struct MultislotPortal {
-        slot_count: usize,
-        text_size: usize,
-    }
-
-    macro_rules! sizeof {
-        ($ty:ty) => {
-            core::mem::size_of::<$ty>()
-        };
-    }
-
-    impl MultislotPortal {
-        /// 计算包括 `slots` 个插槽的传送门总长度。
-        #[inline]
-        pub fn calculate_size(slots: usize) -> usize {
-            sizeof!(Self) + PORTAL_TEXT.aligned_size() + slots * sizeof!(PortalCache)
-        }
-
-        /// 初始化公共空间上的传送门。
-        ///
-        /// # Safety
-        ///
-        /// `transit` 必须是一个正确映射到公共地址空间上的地址。
-        pub unsafe fn init_transit(transit: usize, slots: usize) -> &'static mut Self {
-            // 判断 transit 满足对齐要求
-            debug_assert!(transit.trailing_zeros() > sizeof!(usize).trailing_zeros());
-            // 拷贝代码
-            PORTAL_TEXT.copy_to(transit + sizeof!(Self));
-            // 填写元数据
-            let mut ans = &mut *(transit as *mut Self);
-            ans.slot_count = slots;
-            ans.text_size = PORTAL_TEXT.aligned_size();
-            ans
-        }
-    }
-
-    impl MonoForeignPortal for MultislotPortal {
-        #[inline]
-        fn total_size(&self) -> usize {
-            self.cache_offset(self.slot_count)
-        }
-
-        #[inline]
-        fn transit_address(&self) -> usize {
-            self as *const _ as usize
-        }
-
-        #[inline]
-        fn text_offset(&self) -> usize {
-            sizeof!(Self)
-        }
-
-        #[inline]
-        fn cache_offset(&self, key: usize) -> usize {
-            sizeof!(Self) + self.text_size + key * sizeof!(PortalCache)
-        }
-    }
-}
-
-pub use multislot_portal::MultislotPortal;
-
-use crate::{build_sstatus, LocalContext};
-use spin::Lazy;
-
-/// 传送门缓存。
-///
-/// 映射到公共地址空间，在传送门一次往返期间暂存信息。
-#[repr(C)]
-pub struct PortalCache {
-    a0: usize,       //    (a0) 目标控制流 a0
-    a1: usize,       // 1*8(a0) 目标控制流 a1      （寄存，不用初始化）
-    satp: usize,     // 2*8(a0) 目标控制流 satp
-    sstatus: usize,  // 3*8(a0) 目标控制流 sstatus
-    sepc: usize,     // 4*8(a0) 目标控制流 sepc
-    stvec: usize,    // 5*8(a0) 当前控制流 stvec   （寄存，不用初始化）
-    sscratch: usize, // 6*8(a0) 当前控制流 sscratch（寄存，不用初始化）
-}
-
-impl PortalCache {
-    /// 初始化传送门缓存。
-    #[inline]
-    pub fn init(&mut self, satp: usize, pc: usize, a0: usize, supervisor: bool, interrupt: bool) {
-        self.satp = satp;
-        self.sepc = pc;
-        self.a0 = a0;
-        self.sstatus = build_sstatus(supervisor, interrupt);
-    }
-
-    /// 返回缓存地址。
-    #[inline]
-    pub fn address(&mut self) -> usize {
-        self as *mut _ as _
-    }
-}
-
-/// 异界传送门。
-///
-/// 用于将线程传送到另一个地址空间上执行的基础设施。
-pub trait ForeignPortal {
-    /// 映射到公共地址空间的代码入口。
-    unsafe fn transit_entry(&self) -> usize;
-    /// 映射到公共地址空间的 `key` 号传送门缓存。
-    unsafe fn transit_cache(&mut self, key: impl SlotKey) -> &mut PortalCache;
-}
-
-/// 整体式异界传送门。
-///
-/// 传送门代码和插槽紧挨着放置。这样的传送门对象映射到公共地址空间时应同时具有读、写和执行权限。
-pub trait MonoForeignPortal {
-    /// 传送门对象的总字节数。
-    fn total_size(&self) -> usize;
-
-    /// 传送门对象在公共地址空间上的地址。
-    fn transit_address(&self) -> usize;
-
-    /// 传送门代码在对象中的偏移。
-    fn text_offset(&self) -> usize;
-
-    /// `key` 号插槽在传送门对象中的偏移。
-    fn cache_offset(&self, key: usize) -> usize;
-}
-
-impl<T: MonoForeignPortal> ForeignPortal for T {
-    #[inline]
-    unsafe fn transit_entry(&self) -> usize {
-        self.transit_address() + self.text_offset()
-    }
-
-    #[inline]
-    unsafe fn transit_cache(&mut self, key: impl SlotKey) -> &mut PortalCache {
-        &mut *((self.transit_address() + self.cache_offset(key.index())) as *mut _)
-    }
-}
-
-/// 异界线程上下文。
-///
-/// 不在当前地址空间的线程。
-pub struct ForeignContext {
-    /// 目标地址空间上的线程上下文。
-    pub context: LocalContext,
-    /// 目标地址空间。
-    pub satp: usize,
-}
-
-impl ForeignContext {
-    /// 执行异界线程。
-    pub unsafe fn execute(&mut self, portal: &mut impl ForeignPortal, key: impl SlotKey) -> usize {
-        use core::mem::replace;
-        // 异界传送门需要特权态执行
-        let supervisor = replace(&mut self.context.supervisor, true);
-        // 异界传送门不能打开中断
-        let interrupt = replace(&mut self.context.interrupt, false);
-        // 找到公共空间上的缓存
-        let entry = portal.transit_entry();
-        let cache = portal.transit_cache(key);
-        // 重置传送门上下文
-        cache.init(
-            self.satp,
-            self.context.sepc,
-            self.context.a(0),
-            supervisor,
-            interrupt,
-        );
-        // 执行传送门代码
-        *self.context.pc_mut() = entry;
-        *self.context.a_mut(0) = cache.address();
-        let sstatus = self.context.execute();
-        // 恢复线程属性
-        self.context.supervisor = supervisor;
-        self.context.interrupt = interrupt;
-        // 从传送门读取上下文
-        *self.context.a_mut(0) = cache.a0;
-        sstatus
-    }
-}
-
-/// 插槽选项。
-pub trait SlotKey {
-    /// 转化为插槽序号。
-    fn index(self) -> usize;
-}
-
-impl SlotKey for () {
-    #[inline]
-    fn index(self) -> usize {
-        0
-    }
-}
-
-impl SlotKey for usize {
-    #[inline]
-    fn index(self) -> usize {
-        self
-    }
-}
-
-/// 从 `tp` 寄存器读取一个序号。
-pub struct TpReg;
-
-impl SlotKey for TpReg {
-    #[inline]
-    fn index(self) -> usize {
-        let ans: usize;
-        unsafe { core::arch::asm!("mv {}, tp", out(reg) ans) };
-        ans
-    }
-}
-
-/// 传送门代码
-struct PortalText(&'static [u16]);
-
-/// 定位传送门代码段。
-///
-/// 通过寻找结尾的 `jr a0` 和 `options(noreturn)`，在运行时定位传送门工作的裸函数代码段。
-/// 不必在链接时决定代码位置，可以在运行时将这段代码加载到任意位置。
-static PORTAL_TEXT: Lazy<PortalText> = Lazy::new(PortalText::new);
-
-impl PortalText {
-    pub fn new() -> Self {
-        // 32 是一个任取的不可能的下限
-        for len in 32.. {
-            let slice = unsafe { core::slice::from_raw_parts(foreign_execute as *const _, len) };
-            // 裸函数的 `options(noreturn)` 会在结尾生成一个 0 指令，这是一个 unstable 特性所以不一定可靠
-            if slice.ends_with(&[0x8502, 0]) {
-                return Self(slice);
-            }
-        }
-        unreachable!()
-    }
-
-    #[inline]
-    pub fn aligned_size(&self) -> usize {
-        const USIZE_MASK: usize = core::mem::size_of::<usize>() - 1;
-        (self.0.len() * core::mem::size_of::<u16>() + USIZE_MASK) & !USIZE_MASK
-    }
-
-    #[inline]
-    pub unsafe fn copy_to(&self, address: usize) {
-        (address as *mut u16).copy_from_nonoverlapping(self.0.as_ptr(), self.0.len());
-    }
-}
-
-/// 切换地址空间然后 sret。
-/// 地址空间恢复后一切都会恢复原状。
-#[naked]
-unsafe extern "C" fn foreign_execute(ctx: *mut PortalCache) {
-    core::arch::asm!(
-        // 位置无关加载
-        "   .option push
-            .option nopic
-        ",
-        // 保存 ra，ra 会用来寄存
-        "   sd    a1, 1*8(a0)",
-        // 交换地址空间
-        "   ld    a1, 2*8(a0)
-            csrrw a1, satp, a1
-            sfence.vma
-            sd    a1, 2*8(a0)
-        ",
-        // 加载 sstatus
-        "   ld    a1, 3*8(a0)
-            csrw      sstatus, a1
-        ",
-        // 加载 sepc
-        "   ld    a1, 4*8(a0)
-            csrw      sepc, a1
-        ",
-        // 交换陷入入口
-        "   la    a1, 1f
-            csrrw a1, stvec, a1
-            sd    a1, 5*8(a0)
-        ",
-        // 交换 sscratch
-        "   csrrw a1, sscratch, a0
-            sd    a1, 6*8(a0)
-        ",
-        // 加载通用寄存器
-        "   ld    a1, 1*8(a0)
-            ld    a0,    (a0)
-        ",
-        // 出发！
-        "   sret",
-        // 陷入
-        "   .align 2",
-        // 加载 a0
-        "1: csrrw a0, sscratch, a0",
-        // 保存 ra，ra 会用来寄存
-        "   sd    a1, 1*8(a0)",
-        // 交换 sscratch 并保存 a0
-        "   ld    a1, 6*8(a0)
-            csrrw a1, sscratch, a1
-            sd    a1,    (a0)
-        ",
-        // 恢复地址空间
-        "   ld    a1, 2*8(a0)
-            csrrw a1, satp, a1
-            sfence.vma
-            sd    a1, 2*8(a0)
-        ",
-        // 恢复通用寄存器
-        "   ld    a1, 1*8(a0)",
-        // 恢复陷入入口
-        "   ld    a0, 5*8(a0)
-            csrw      stvec, a0
-        ",
-        // 回家！
-        // 离开异界传送门直接跳到正常上下文的 stvec
-        "   jr    a0",
-        "   .option pop",
-        options(noreturn)
-    )
-}
diff --git a/context/src/lib.rs b/context/src/lib.rs
deleted file mode 100644
index 74128de..0000000
--- a/context/src/lib.rs
+++ /dev/null
@@ -1,252 +0,0 @@
-//! 内核上下文控制。
-
-#![no_std]
-#![feature(naked_functions, asm_const)]
-#![deny(warnings, missing_docs)]
-
-/// 不同地址空间的上下文控制。
-#[cfg(feature = "foreign")]
-pub mod foreign;
-
-/// 线程上下文。
-#[derive(Clone)]
-#[repr(C)]
-pub struct LocalContext {
-    sctx: usize,
-    x: [usize; 31],
-    sepc: usize,
-    /// 是否以特权态切换。
-    pub supervisor: bool,
-    /// 线程中断是否开启。
-    pub interrupt: bool,
-}
-
-impl LocalContext {
-    /// 创建空白上下文。
-    #[inline]
-    pub const fn empty() -> Self {
-        Self {
-            sctx: 0,
-            x: [0; 31],
-            supervisor: false,
-            interrupt: false,
-            sepc: 0,
-        }
-    }
-
-    /// 初始化指定入口的用户上下文。
-    ///
-    /// 切换到用户态时会打开内核中断。
-    #[inline]
-    pub const fn user(pc: usize) -> Self {
-        Self {
-            sctx: 0,
-            x: [0; 31],
-            supervisor: false,
-            interrupt: true,
-            sepc: pc,
-        }
-    }
-
-    /// 初始化指定入口的内核上下文。
-    #[inline]
-    pub const fn thread(pc: usize, interrupt: bool) -> Self {
-        Self {
-            sctx: 0,
-            x: [0; 31],
-            supervisor: true,
-            interrupt,
-            sepc: pc,
-        }
-    }
-
-    /// 读取用户通用寄存器。
-    #[inline]
-    pub fn x(&self, n: usize) -> usize {
-        self.x[n - 1]
-    }
-
-    /// 修改用户通用寄存器。
-    #[inline]
-    pub fn x_mut(&mut self, n: usize) -> &mut usize {
-        &mut self.x[n - 1]
-    }
-
-    /// 读取用户参数寄存器。
-    #[inline]
-    pub fn a(&self, n: usize) -> usize {
-        self.x(n + 10)
-    }
-
-    /// 修改用户参数寄存器。
-    #[inline]
-    pub fn a_mut(&mut self, n: usize) -> &mut usize {
-        self.x_mut(n + 10)
-    }
-
-    /// 读取用户栈指针。
-    #[inline]
-    pub fn ra(&self) -> usize {
-        self.x(1)
-    }
-
-    /// 读取用户栈指针。
-    #[inline]
-    pub fn sp(&self) -> usize {
-        self.x(2)
-    }
-
-    /// 修改用户栈指针。
-    #[inline]
-    pub fn sp_mut(&mut self) -> &mut usize {
-        self.x_mut(2)
-    }
-
-    /// 当前上下文的 pc。
-    #[inline]
-    pub fn pc(&self) -> usize {
-        self.sepc
-    }
-
-    /// 修改上下文的 pc。
-    #[inline]
-    pub fn pc_mut(&mut self) -> &mut usize {
-        &mut self.sepc
-    }
-
-    /// 将 pc 移至下一条指令。
-    ///
-    /// # Notice
-    ///
-    /// 假设这一条指令不是压缩版本。
-    #[inline]
-    pub fn move_next(&mut self) {
-        self.sepc = self.sepc.wrapping_add(4);
-    }
-
-    /// 执行此线程，并返回 `sstatus`。
-    ///
-    /// # Safety
-    ///
-    /// 将修改 `sscratch`、`sepc`、`sstatus` 和 `stvec`。
-    #[inline]
-    pub unsafe fn execute(&mut self) -> usize {
-        let mut sstatus = build_sstatus(self.supervisor, self.interrupt);
-        core::arch::asm!(
-            "   csrrw {sscratch}, sscratch, {sscratch}
-                csrw  sepc    , {sepc}
-                csrw  sstatus , {sstatus}
-                addi  sp, sp, -8
-                sd    ra, (sp)
-                call  {execute_naked}
-                ld    ra, (sp)
-                addi  sp, sp,  8
-                csrw  sscratch, {sscratch}
-                csrr  {sepc}   , sepc
-                csrr  {sstatus}, sstatus
-            ",
-            sscratch      = in       (reg) self,
-            sepc          = inlateout(reg) self.sepc,
-            sstatus       = inlateout(reg) sstatus,
-            execute_naked = sym execute_naked,
-        );
-        sstatus
-    }
-}
-
-#[inline]
-fn build_sstatus(supervisor: bool, interrupt: bool) -> usize {
-    let mut sstatus: usize;
-    // 只是读 sstatus，安全的
-    unsafe { core::arch::asm!("csrr {}, sstatus", out(reg) sstatus) };
-    const PREVILEGE_BIT: usize = 1 << 8;
-    const INTERRUPT_BIT: usize = 1 << 5;
-    match supervisor {
-        false => sstatus &= !PREVILEGE_BIT,
-        true => sstatus |= PREVILEGE_BIT,
-    }
-    match interrupt {
-        false => sstatus &= !INTERRUPT_BIT,
-        true => sstatus |= INTERRUPT_BIT,
-    }
-    sstatus
-}
-
-/// 线程切换核心部分。
-///
-/// 通用寄存器压栈，然后从预存在 `sscratch` 里的上下文指针恢复线程通用寄存器。
-///
-/// # Safety
-///
-/// 裸函数。
-#[naked]
-unsafe extern "C" fn execute_naked() {
-    core::arch::asm!(
-        r"  .altmacro
-            .macro SAVE n
-                sd x\n, \n*8(sp)
-            .endm
-            .macro SAVE_ALL
-                sd x1, 1*8(sp)
-                .set n, 3
-                .rept 29
-                    SAVE %n
-                    .set n, n+1
-                .endr
-            .endm
-            .macro LOAD n
-                ld x\n, \n*8(sp)
-            .endm
-            .macro LOAD_ALL
-                ld x1, 1*8(sp)
-                .set n, 3
-                .rept 29
-                    LOAD %n
-                    .set n, n+1
-                .endr
-            .endm
-        ",
-        // 位置无关加载
-        "   .option push
-            .option nopic
-        ",
-        // 保存调度上下文
-        "   addi sp, sp, -32*8
-            SAVE_ALL
-        ",
-        // 设置陷入入口
-        "   la   t0, 1f
-            csrw stvec, t0
-        ",
-        // 保存调度上下文地址并切换上下文
-        "   csrr t0, sscratch
-            sd   sp, (t0)
-            mv   sp, t0
-        ",
-        // 恢复线程上下文
-        "   LOAD_ALL
-            ld   sp, 2*8(sp)
-        ",
-        // 执行线程
-        "   sret",
-        // 陷入
-        "   .align 2",
-        // 切换上下文
-        "1: csrrw sp, sscratch, sp",
-        // 保存线程上下文
-        "   SAVE_ALL
-            csrrw t0, sscratch, sp
-            sd    t0, 2*8(sp)
-        ",
-        // 切换上下文
-        "   ld sp, (sp)",
-        // 恢复调度上下文
-        "   LOAD_ALL
-            addi sp, sp, 32*8
-        ",
-        // 返回调度
-        "   ret",
-        "   .option pop",
-        options(noreturn)
-    )
-}
diff --git a/easy-fs-fuse/Cargo.toml b/easy-fs-fuse/Cargo.toml
deleted file mode 100644
index 4a8e9ee..0000000
--- a/easy-fs-fuse/Cargo.toml
+++ /dev/null
@@ -1,16 +0,0 @@
-[package]
-name = "easy-fs-fuse"
-version = "0.1.0"
-authors = ["Yifan Wu <shinbokuow@163.com>"]
-edition = "2018"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-clap = "2.33.3"
-easy-fs = { path = "../easy-fs" }
-rand = "0.8.0"
-
-# [features]
-# board_qemu = []
-# board_k210 = []
\ No newline at end of file
diff --git a/easy-fs-fuse/rust-toolchain.toml b/easy-fs-fuse/rust-toolchain.toml
deleted file mode 100644
index 9b65d88..0000000
--- a/easy-fs-fuse/rust-toolchain.toml
+++ /dev/null
@@ -1,5 +0,0 @@
-[toolchain]
-profile = "minimal"
-channel = "nightly-2022-11-03"
-components = ["rust-src", "llvm-tools-preview", "rustfmt", "rust-std", "clippy"]
-targets = ["x86_64-unknown-linux-gnu"]
\ No newline at end of file
diff --git a/easy-fs-fuse/src/main.rs b/easy-fs-fuse/src/main.rs
deleted file mode 100644
index 799507a..0000000
--- a/easy-fs-fuse/src/main.rs
+++ /dev/null
@@ -1,155 +0,0 @@
-use clap::{App, Arg};
-use easy_fs::{BlockDevice, EasyFileSystem};
-use std::fs::{read_dir, File, OpenOptions};
-use std::io::{Read, Seek, SeekFrom, Write};
-use std::sync::Arc;
-use std::sync::Mutex;
-
-const BLOCK_SZ: usize = 512;
-
-struct BlockFile(Mutex<File>);
-
-impl BlockDevice for BlockFile {
-    fn read_block(&self, block_id: usize, buf: &mut [u8]) {
-        let mut file = self.0.lock().unwrap();
-        file.seek(SeekFrom::Start((block_id * BLOCK_SZ) as u64))
-            .expect("Error when seeking!");
-        assert_eq!(file.read(buf).unwrap(), BLOCK_SZ, "Not a complete block!");
-    }
-
-    fn write_block(&self, block_id: usize, buf: &[u8]) {
-        let mut file = self.0.lock().unwrap();
-        file.seek(SeekFrom::Start((block_id * BLOCK_SZ) as u64))
-            .expect("Error when seeking!");
-        assert_eq!(file.write(buf).unwrap(), BLOCK_SZ, "Not a complete block!");
-    }
-
-    fn handle_irq(&self) {
-        unimplemented!();
-    }
-}
-
-fn main() {
-    easy_fs_pack().expect("Error when packing easy-fs!");
-}
-
-fn easy_fs_pack() -> std::io::Result<()> {
-    let matches = App::new("EasyFileSystem packer")
-        .arg(
-            Arg::with_name("source")
-                .short("s")
-                .long("source")
-                .takes_value(true)
-                .help("Executable source dir(with backslash)"),
-        )
-        .arg(
-            Arg::with_name("target")
-                .short("t")
-                .long("target")
-                .takes_value(true)
-                .help("Executable target dir(with backslash)"),
-        )
-        .get_matches();
-    let src_path = matches.value_of("source").unwrap();
-    let target_path = matches.value_of("target").unwrap();
-    println!("src_path = {}\ntarget_path = {}", src_path, target_path);
-    let block_file = Arc::new(BlockFile(Mutex::new({
-        let f = OpenOptions::new()
-            .read(true)
-            .write(true)
-            .create(true)
-            .open(format!("{}{}", target_path, "fs.img"))?;
-        f.set_len(16 * 2048 * 512).unwrap();
-        f
-    })));
-    // 16MiB, at most 4095 files
-    let efs = EasyFileSystem::create(block_file, 16 * 2048, 1);
-    let root_inode = Arc::new(EasyFileSystem::root_inode(&efs));
-    let apps: Vec<_> = read_dir(src_path)
-        .unwrap()
-        .into_iter()
-        .map(|dir_entry| {
-            let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap();
-            name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len());
-            name_with_ext
-        })
-        .collect();
-    for app in apps {
-        // load app data from host file system
-        let mut host_file = File::open(format!("{}{}", target_path, app)).unwrap();
-        let mut all_data: Vec<u8> = Vec::new();
-        host_file.read_to_end(&mut all_data).unwrap();
-        // create a file in easy-fs
-        let inode = root_inode.create(app.as_str()).unwrap();
-        // write data to easy-fs
-        inode.write_at(0, all_data.as_slice());
-    }
-    // list apps
-    // for app in root_inode.ls() {
-    //     println!("{}", app);
-    // }
-    Ok(())
-}
-
-#[test]
-fn efs_test() -> std::io::Result<()> {
-    let block_file = Arc::new(BlockFile(Mutex::new({
-        let f = OpenOptions::new()
-            .read(true)
-            .write(true)
-            .create(true)
-            .open("target/fs.img")?;
-        f.set_len(8192 * 512).unwrap();
-        f
-    })));
-    EasyFileSystem::create(block_file.clone(), 4096, 1);
-    let efs = EasyFileSystem::open(block_file.clone());
-    let root_inode = EasyFileSystem::root_inode(&efs);
-    root_inode.create("filea");
-    root_inode.create("fileb");
-    for name in root_inode.ls() {
-        println!("{}", name);
-    }
-    let filea = root_inode.find("filea").unwrap();
-    let greet_str = "Hello, world!";
-    filea.write_at(0, greet_str.as_bytes());
-    //let mut buffer = [0u8; 512];
-    let mut buffer = [0u8; 233];
-    let len = filea.read_at(0, &mut buffer);
-    assert_eq!(greet_str, core::str::from_utf8(&buffer[..len]).unwrap(),);
-
-    let mut random_str_test = |len: usize| {
-        filea.clear();
-        assert_eq!(filea.read_at(0, &mut buffer), 0,);
-        let mut str = String::new();
-        use rand;
-        // random digit
-        for _ in 0..len {
-            str.push(char::from('0' as u8 + rand::random::<u8>() % 10));
-        }
-        filea.write_at(0, str.as_bytes());
-        let mut read_buffer = [0u8; 127];
-        let mut offset = 0usize;
-        let mut read_str = String::new();
-        loop {
-            let len = filea.read_at(offset, &mut read_buffer);
-            if len == 0 {
-                break;
-            }
-            offset += len;
-            read_str.push_str(core::str::from_utf8(&read_buffer[..len]).unwrap());
-        }
-        assert_eq!(str, read_str);
-    };
-
-    random_str_test(4 * BLOCK_SZ);
-    random_str_test(8 * BLOCK_SZ + BLOCK_SZ / 2);
-    random_str_test(100 * BLOCK_SZ);
-    random_str_test(70 * BLOCK_SZ + BLOCK_SZ / 7);
-    random_str_test((12 + 128) * BLOCK_SZ);
-    random_str_test(400 * BLOCK_SZ);
-    random_str_test(1000 * BLOCK_SZ);
-    random_str_test(2000 * BLOCK_SZ);
-
-    Ok(())
-}
diff --git a/easy-fs/Cargo.toml b/easy-fs/Cargo.toml
deleted file mode 100644
index 77afb89..0000000
--- a/easy-fs/Cargo.toml
+++ /dev/null
@@ -1,18 +0,0 @@
-[package]
-name = "easy-fs"
-version = "0.1.0"
-authors = ["Yifan Wu <shinbokuow@163.com>"]
-edition = "2018"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-spin = "0.7.0"
-lazy_static = { version = "1.4.0", features = ["spin_no_std"] }
-
-[profile.release]
-debug = true
-
-[features]
-board_qemu = []
-board_k210 = []
\ No newline at end of file
diff --git a/easy-fs/src/bitmap.rs b/easy-fs/src/bitmap.rs
deleted file mode 100644
index 3fc0999..0000000
--- a/easy-fs/src/bitmap.rs
+++ /dev/null
@@ -1,69 +0,0 @@
-use super::{get_block_cache, BlockDevice, BLOCK_SZ};
-use alloc::sync::Arc;
-
-type BitmapBlock = [u64; 64];
-
-const BLOCK_BITS: usize = BLOCK_SZ * 8;
-
-pub struct Bitmap {
-    start_block_id: usize,
-    blocks: usize,
-}
-
-/// Return (block_pos, bits64_pos, inner_pos)
-fn decomposition(mut bit: usize) -> (usize, usize, usize) {
-    let block_pos = bit / BLOCK_BITS;
-    bit %= BLOCK_BITS;
-    (block_pos, bit / 64, bit % 64)
-}
-
-impl Bitmap {
-    pub fn new(start_block_id: usize, blocks: usize) -> Self {
-        Self {
-            start_block_id,
-            blocks,
-        }
-    }
-
-    pub fn alloc(&self, block_device: &Arc<dyn BlockDevice>) -> Option<usize> {
-        for block_id in 0..self.blocks {
-            let pos = get_block_cache(
-                block_id + self.start_block_id as usize,
-                Arc::clone(block_device),
-            )
-            .lock()
-            .modify(0, |bitmap_block: &mut BitmapBlock| {
-                if let Some((bits64_pos, inner_pos)) = bitmap_block
-                    .iter()
-                    .enumerate()
-                    .find(|(_, bits64)| **bits64 != u64::MAX)
-                    .map(|(bits64_pos, bits64)| (bits64_pos, bits64.trailing_ones() as usize))
-                {
-                    // modify cache
-                    bitmap_block[bits64_pos] |= 1u64 << inner_pos;
-                    Some(block_id * BLOCK_BITS + bits64_pos * 64 + inner_pos as usize)
-                } else {
-                    None
-                }
-            });
-            if pos.is_some() {
-                return pos;
-            }
-        }
-        None
-    }
-
-    pub fn dealloc(&self, block_device: &Arc<dyn BlockDevice>, bit: usize) {
-        let (block_pos, bits64_pos, inner_pos) = decomposition(bit);
-        get_block_cache(block_pos + self.start_block_id, Arc::clone(block_device))
-            .lock()
-            .modify(0, |bitmap_block: &mut BitmapBlock| {
-                assert!(bitmap_block[bits64_pos] & (1u64 << inner_pos) > 0);
-                bitmap_block[bits64_pos] -= 1u64 << inner_pos;
-            });
-    }
-
-    pub fn maximum(&self) -> usize {
-        self.blocks * BLOCK_BITS
-    }
-}
diff --git a/easy-fs/src/block_cache.rs b/easy-fs/src/block_cache.rs
deleted file mode 100644
index ff44204..0000000
--- a/easy-fs/src/block_cache.rs
+++ /dev/null
@@ -1,142 +0,0 @@
-use super::{BlockDevice, BLOCK_SZ};
-use alloc::collections::VecDeque;
-use alloc::sync::Arc;
-use alloc::vec;
-use alloc::vec::Vec;
-use lazy_static::*;
-use spin::Mutex;
-
-pub struct BlockCache {
-    cache: Vec<u8>,
-    block_id: usize,
-    block_device: Arc<dyn BlockDevice>,
-    modified: bool,
-}
-
-impl BlockCache {
-    /// Load a new BlockCache from disk.
-    pub fn new(block_id: usize, block_device: Arc<dyn BlockDevice>) -> Self {
-        // for alignment and move effciency
-        let mut cache = vec![0u8; BLOCK_SZ];
-        block_device.read_block(block_id, &mut cache);
-        Self {
-            cache,
-            block_id,
-            block_device,
-            modified: false,
-        }
-    }
-
-    fn addr_of_offset(&self, offset: usize) -> usize {
-        &self.cache[offset] as *const _ as usize
-    }
-
-    pub fn get_ref<T>(&self, offset: usize) -> &T
-    where
-        T: Sized,
-    {
-        let type_size = core::mem::size_of::<T>();
-        assert!(offset + type_size <= BLOCK_SZ);
-        let addr = self.addr_of_offset(offset);
-        unsafe { &*(addr as *const T) }
-    }
-
-    pub fn get_mut<T>(&mut self, offset: usize) -> &mut T
-    where
-        T: Sized,
-    {
-        let type_size = core::mem::size_of::<T>();
-        assert!(offset + type_size <= BLOCK_SZ);
-        self.modified = true;
-        let addr = self.addr_of_offset(offset);
-        unsafe { &mut *(addr as *mut T) }
-    }
-
-    pub fn read<T, V>(&self, offset: usize, f: impl FnOnce(&T) -> V) -> V {
-        f(self.get_ref(offset))
-    }
-
-    pub fn modify<T, V>(&mut self, offset: usize, f: impl FnOnce(&mut T) -> V) -> V {
-        f(self.get_mut(offset))
-    }
-
-    pub fn sync(&mut self) {
-        if self.modified {
-            self.modified = false;
-            self.block_device.write_block(self.block_id, &self.cache);
-        }
-    }
-}
-
-impl Drop for BlockCache {
-    fn drop(&mut self) {
-        self.sync()
-    }
-}
-
-const BLOCK_CACHE_SIZE: usize = 16;
-
-pub struct BlockCacheManager {
-    queue: VecDeque<(usize, Arc<Mutex<BlockCache>>)>,
-}
-
-impl BlockCacheManager {
-    pub fn new() -> Self {
-        Self {
-            queue: VecDeque::new(),
-        }
-    }
-
-    pub fn get_block_cache(
-        &mut self,
-        block_id: usize,
-        block_device: Arc<dyn BlockDevice>,
-    ) -> Arc<Mutex<BlockCache>> {
-        if let Some(pair) = self.queue.iter().find(|pair| pair.0 == block_id) {
-            Arc::clone(&pair.1)
-        } else {
-            // substitute
-            if self.queue.len() == BLOCK_CACHE_SIZE {
-                // from front to tail
-                if let Some((idx, _)) = self
-                    .queue
-                    .iter()
-                    .enumerate()
-                    .find(|(_, pair)| Arc::strong_count(&pair.1) == 1)
-                {
-                    self.queue.drain(idx..=idx);
-                } else {
-                    panic!("Run out of BlockCache!");
-                }
-            }
-            // load block into mem and push back
-            let block_cache = Arc::new(Mutex::new(BlockCache::new(
-                block_id,
-                Arc::clone(&block_device),
-            )));
-            self.queue.push_back((block_id, Arc::clone(&block_cache)));
-            block_cache
-        }
-    }
-}
-
-lazy_static! {
-    pub static ref BLOCK_CACHE_MANAGER: Mutex<BlockCacheManager> =
-        Mutex::new(BlockCacheManager::new());
-}
-
-pub fn get_block_cache(
-    block_id: usize,
-    block_device: Arc<dyn BlockDevice>,
-) -> Arc<Mutex<BlockCache>> {
-    BLOCK_CACHE_MANAGER
-        .lock()
-        .get_block_cache(block_id, block_device)
-}
-
-pub fn block_cache_sync_all() {
-    let manager = BLOCK_CACHE_MANAGER.lock();
-    for (_, cache) in manager.queue.iter() {
-        cache.lock().sync();
-    }
-}
diff --git a/easy-fs/src/block_dev.rs b/easy-fs/src/block_dev.rs
deleted file mode 100644
index 6c49aef..0000000
--- a/easy-fs/src/block_dev.rs
+++ /dev/null
@@ -1,7 +0,0 @@
-use core::any::Any;
-
-pub trait BlockDevice: Send + Sync + Any {
-    fn read_block(&self, block_id: usize, buf: &mut [u8]);
-    fn write_block(&self, block_id: usize, buf: &[u8]);
-    fn handle_irq(&self);
-}
diff --git a/easy-fs/src/efs.rs b/easy-fs/src/efs.rs
deleted file mode 100644
index 9d3c005..0000000
--- a/easy-fs/src/efs.rs
+++ /dev/null
@@ -1,147 +0,0 @@
-use super::{
-    block_cache_sync_all, get_block_cache, Bitmap, BlockDevice, DiskInode, DiskInodeType, Inode,
-    SuperBlock,
-};
-use crate::BLOCK_SZ;
-use alloc::sync::Arc;
-use spin::Mutex;
-
-pub struct EasyFileSystem {
-    pub block_device: Arc<dyn BlockDevice>,
-    pub inode_bitmap: Bitmap,
-    pub data_bitmap: Bitmap,
-    inode_area_start_block: u32,
-    data_area_start_block: u32,
-}
-
-type DataBlock = [u8; BLOCK_SZ];
-
-impl EasyFileSystem {
-    pub fn create(
-        block_device: Arc<dyn BlockDevice>,
-        total_blocks: u32,
-        inode_bitmap_blocks: u32,
-    ) -> Arc<Mutex<Self>> {
-        // calculate block size of areas & create bitmaps
-        let inode_bitmap = Bitmap::new(1, inode_bitmap_blocks as usize);
-        let inode_num = inode_bitmap.maximum();
-        let inode_area_blocks =
-            ((inode_num * core::mem::size_of::<DiskInode>() + BLOCK_SZ - 1) / BLOCK_SZ) as u32;
-        let inode_total_blocks = inode_bitmap_blocks + inode_area_blocks;
-        let data_total_blocks = total_blocks - 1 - inode_total_blocks;
-        let data_bitmap_blocks = (data_total_blocks + 4096) / 4097;
-        let data_area_blocks = data_total_blocks - data_bitmap_blocks;
-        let data_bitmap = Bitmap::new(
-            (1 + inode_bitmap_blocks + inode_area_blocks) as usize,
-            data_bitmap_blocks as usize,
-        );
-        let mut efs = Self {
-            block_device: Arc::clone(&block_device),
-            inode_bitmap,
-            data_bitmap,
-            inode_area_start_block: 1 + inode_bitmap_blocks,
-            data_area_start_block: 1 + inode_total_blocks + data_bitmap_blocks,
-        };
-        // clear all blocks
-        for i in 0..total_blocks {
-            get_block_cache(i as usize, Arc::clone(&block_device))
-                .lock()
-                .modify(0, |data_block: &mut DataBlock| {
-                    for byte in data_block.iter_mut() {
-                        *byte = 0;
-                    }
-                });
-        }
-        // initialize SuperBlock
-        get_block_cache(0, Arc::clone(&block_device)).lock().modify(
-            0,
-            |super_block: &mut SuperBlock| {
-                super_block.initialize(
-                    total_blocks,
-                    inode_bitmap_blocks,
-                    inode_area_blocks,
-                    data_bitmap_blocks,
-                    data_area_blocks,
-                );
-            },
-        );
-        // write back immediately
-        // create a inode for root node "/"
-        assert_eq!(efs.alloc_inode(), 0);
-        let (root_inode_block_id, root_inode_offset) = efs.get_disk_inode_pos(0);
-        get_block_cache(root_inode_block_id as usize, Arc::clone(&block_device))
-            .lock()
-            .modify(root_inode_offset, |disk_inode: &mut DiskInode| {
-                disk_inode.initialize(DiskInodeType::Directory);
-            });
-        block_cache_sync_all();
-        Arc::new(Mutex::new(efs))
-    }
-
-    pub fn open(block_device: Arc<dyn BlockDevice>) -> Arc<Mutex<Self>> {
-        // read SuperBlock
-        get_block_cache(0, Arc::clone(&block_device))
-            .lock()
-            .read(0, |super_block: &SuperBlock| {
-                assert!(super_block.is_valid(), "Error loading EFS!");
-                let inode_total_blocks =
-                    super_block.inode_bitmap_blocks + super_block.inode_area_blocks;
-                let efs = Self {
-                    block_device,
-                    inode_bitmap: Bitmap::new(1, super_block.inode_bitmap_blocks as usize),
-                    data_bitmap: Bitmap::new(
-                        (1 + inode_total_blocks) as usize,
-                        super_block.data_bitmap_blocks as usize,
-                    ),
-                    inode_area_start_block: 1 + super_block.inode_bitmap_blocks,
-                    data_area_start_block: 1 + inode_total_blocks + super_block.data_bitmap_blocks,
-                };
-                Arc::new(Mutex::new(efs))
-            })
-    }
-
-    pub fn root_inode(efs: &Arc<Mutex<Self>>) -> Inode {
-        let block_device = Arc::clone(&efs.lock().block_device);
-        // acquire efs lock temporarily
-        let (block_id, block_offset) = efs.lock().get_disk_inode_pos(0);
-        // release efs lock
-        Inode::new(block_id, block_offset, Arc::clone(efs), block_device)
-    }
-
-    pub fn get_disk_inode_pos(&self, inode_id: u32) -> (u32, usize) {
-        let inode_size = core::mem::size_of::<DiskInode>();
-        let inodes_per_block = (BLOCK_SZ / inode_size) as u32;
-        let block_id = self.inode_area_start_block + inode_id / inodes_per_block;
-        (
-            block_id,
-            (inode_id % inodes_per_block) as usize * inode_size,
-        )
-    }
-
-    pub fn get_data_block_id(&self, data_block_id: u32) -> u32 {
-        self.data_area_start_block + data_block_id
-    }
-
-    pub fn alloc_inode(&mut self) -> u32 {
-        self.inode_bitmap.alloc(&self.block_device).unwrap() as u32
-    }
-
-    /// Return a block ID not ID in the data area.
-    pub fn alloc_data(&mut self) -> u32 {
-        self.data_bitmap.alloc(&self.block_device).unwrap() as u32 + self.data_area_start_block
-    }
-
-    pub fn dealloc_data(&mut self, block_id: u32) {
-        get_block_cache(block_id as usize, Arc::clone(&self.block_device))
-            .lock()
-            .modify(0, |data_block: &mut DataBlock| {
-                data_block.iter_mut().for_each(|p| {
-                    *p = 0;
-                })
-            });
-        self.data_bitmap.dealloc(
-            &self.block_device,
-            (block_id - self.data_area_start_block) as usize,
-        )
-    }
-}
diff --git a/easy-fs/src/layout.rs b/easy-fs/src/layout.rs
deleted file mode 100644
index 66221cc..0000000
--- a/easy-fs/src/layout.rs
+++ /dev/null
@@ -1,409 +0,0 @@
-use super::{get_block_cache, BlockDevice, BLOCK_SZ};
-use alloc::sync::Arc;
-use alloc::vec::Vec;
-use core::fmt::{Debug, Formatter, Result};
-
-const EFS_MAGIC: u32 = 0x3b800001;
-const INODE_DIRECT_COUNT: usize = 28;
-const NAME_LENGTH_LIMIT: usize = 27;
-const INODE_INDIRECT1_COUNT: usize = BLOCK_SZ / 4;
-const INODE_INDIRECT2_COUNT: usize = INODE_INDIRECT1_COUNT * INODE_INDIRECT1_COUNT;
-const DIRECT_BOUND: usize = INODE_DIRECT_COUNT;
-const INDIRECT1_BOUND: usize = DIRECT_BOUND + INODE_INDIRECT1_COUNT;
-#[allow(unused)]
-const INDIRECT2_BOUND: usize = INDIRECT1_BOUND + INODE_INDIRECT2_COUNT;
-
-#[repr(C)]
-pub struct SuperBlock {
-    magic: u32,
-    pub total_blocks: u32,
-    pub inode_bitmap_blocks: u32,
-    pub inode_area_blocks: u32,
-    pub data_bitmap_blocks: u32,
-    pub data_area_blocks: u32,
-}
-
-impl Debug for SuperBlock {
-    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
-        f.debug_struct("SuperBlock")
-            .field("total_blocks", &self.total_blocks)
-            .field("inode_bitmap_blocks", &self.inode_bitmap_blocks)
-            .field("inode_area_blocks", &self.inode_area_blocks)
-            .field("data_bitmap_blocks", &self.data_bitmap_blocks)
-            .field("data_area_blocks", &self.data_area_blocks)
-            .finish()
-    }
-}
-
-impl SuperBlock {
-    pub fn initialize(
-        &mut self,
-        total_blocks: u32,
-        inode_bitmap_blocks: u32,
-        inode_area_blocks: u32,
-        data_bitmap_blocks: u32,
-        data_area_blocks: u32,
-    ) {
-        *self = Self {
-            magic: EFS_MAGIC,
-            total_blocks,
-            inode_bitmap_blocks,
-            inode_area_blocks,
-            data_bitmap_blocks,
-            data_area_blocks,
-        }
-    }
-    pub fn is_valid(&self) -> bool {
-        self.magic == EFS_MAGIC
-    }
-}
-
-#[derive(PartialEq)]
-pub enum DiskInodeType {
-    File,
-    Directory,
-}
-
-type IndirectBlock = [u32; BLOCK_SZ / 4];
-type DataBlock = [u8; BLOCK_SZ];
-
-#[repr(C)]
-pub struct DiskInode {
-    pub size: u32,
-    pub direct: [u32; INODE_DIRECT_COUNT],
-    pub indirect1: u32,
-    pub indirect2: u32,
-    type_: DiskInodeType,
-}
-
-impl DiskInode {
-    /// indirect1 and indirect2 block are allocated only when they are needed.
-    pub fn initialize(&mut self, type_: DiskInodeType) {
-        self.size = 0;
-        self.direct.iter_mut().for_each(|v| *v = 0);
-        self.indirect1 = 0;
-        self.indirect2 = 0;
-        self.type_ = type_;
-    }
-    pub fn is_dir(&self) -> bool {
-        self.type_ == DiskInodeType::Directory
-    }
-    #[allow(unused)]
-    pub fn is_file(&self) -> bool {
-        self.type_ == DiskInodeType::File
-    }
-    /// Return block number correspond to size.
-    pub fn data_blocks(&self) -> u32 {
-        Self::_data_blocks(self.size)
-    }
-    fn _data_blocks(size: u32) -> u32 {
-        (size + BLOCK_SZ as u32 - 1) / BLOCK_SZ as u32
-    }
-    /// Return number of blocks needed include indirect1/2.
-    pub fn total_blocks(size: u32) -> u32 {
-        let data_blocks = Self::_data_blocks(size) as usize;
-        let mut total = data_blocks as usize;
-        // indirect1
-        if data_blocks > INODE_DIRECT_COUNT {
-            total += 1;
-        }
-        // indirect2
-        if data_blocks > INDIRECT1_BOUND {
-            total += 1;
-            // sub indirect1
-            total +=
-                (data_blocks - INDIRECT1_BOUND + INODE_INDIRECT1_COUNT - 1) / INODE_INDIRECT1_COUNT;
-        }
-        total as u32
-    }
-    pub fn blocks_num_needed(&self, new_size: u32) -> u32 {
-        assert!(new_size >= self.size);
-        Self::total_blocks(new_size) - Self::total_blocks(self.size)
-    }
-    pub fn get_block_id(&self, inner_id: u32, block_device: &Arc<dyn BlockDevice>) -> u32 {
-        let inner_id = inner_id as usize;
-        if inner_id < INODE_DIRECT_COUNT {
-            self.direct[inner_id]
-        } else if inner_id < INDIRECT1_BOUND {
-            get_block_cache(self.indirect1 as usize, Arc::clone(block_device))
-                .lock()
-                .read(0, |indirect_block: &IndirectBlock| {
-                    indirect_block[inner_id - INODE_DIRECT_COUNT]
-                })
-        } else {
-            let last = inner_id - INDIRECT1_BOUND;
-            let indirect1 = get_block_cache(self.indirect2 as usize, Arc::clone(block_device))
-                .lock()
-                .read(0, |indirect2: &IndirectBlock| {
-                    indirect2[last / INODE_INDIRECT1_COUNT]
-                });
-            get_block_cache(indirect1 as usize, Arc::clone(block_device))
-                .lock()
-                .read(0, |indirect1: &IndirectBlock| {
-                    indirect1[last % INODE_INDIRECT1_COUNT]
-                })
-        }
-    }
-    pub fn increase_size(
-        &mut self,
-        new_size: u32,
-        new_blocks: Vec<u32>,
-        block_device: &Arc<dyn BlockDevice>,
-    ) {
-        let mut current_blocks = self.data_blocks();
-        self.size = new_size;
-        let mut total_blocks = self.data_blocks();
-        let mut new_blocks = new_blocks.into_iter();
-        // fill direct
-        while current_blocks < total_blocks.min(INODE_DIRECT_COUNT as u32) {
-            self.direct[current_blocks as usize] = new_blocks.next().unwrap();
-            current_blocks += 1;
-        }
-        // alloc indirect1
-        if total_blocks > INODE_DIRECT_COUNT as u32 {
-            if current_blocks == INODE_DIRECT_COUNT as u32 {
-                self.indirect1 = new_blocks.next().unwrap();
-            }
-            current_blocks -= INODE_DIRECT_COUNT as u32;
-            total_blocks -= INODE_DIRECT_COUNT as u32;
-        } else {
-            return;
-        }
-        // fill indirect1
-        get_block_cache(self.indirect1 as usize, Arc::clone(block_device))
-            .lock()
-            .modify(0, |indirect1: &mut IndirectBlock| {
-                while current_blocks < total_blocks.min(INODE_INDIRECT1_COUNT as u32) {
-                    indirect1[current_blocks as usize] = new_blocks.next().unwrap();
-                    current_blocks += 1;
-                }
-            });
-        // alloc indirect2
-        if total_blocks > INODE_INDIRECT1_COUNT as u32 {
-            if current_blocks == INODE_INDIRECT1_COUNT as u32 {
-                self.indirect2 = new_blocks.next().unwrap();
-            }
-            current_blocks -= INODE_INDIRECT1_COUNT as u32;
-            total_blocks -= INODE_INDIRECT1_COUNT as u32;
-        } else {
-            return;
-        }
-        // fill indirect2 from (a0, b0) -> (a1, b1)
-        let mut a0 = current_blocks as usize / INODE_INDIRECT1_COUNT;
-        let mut b0 = current_blocks as usize % INODE_INDIRECT1_COUNT;
-        let a1 = total_blocks as usize / INODE_INDIRECT1_COUNT;
-        let b1 = total_blocks as usize % INODE_INDIRECT1_COUNT;
-        // alloc low-level indirect1
-        get_block_cache(self.indirect2 as usize, Arc::clone(block_device))
-            .lock()
-            .modify(0, |indirect2: &mut IndirectBlock| {
-                while (a0 < a1) || (a0 == a1 && b0 < b1) {
-                    if b0 == 0 {
-                        indirect2[a0] = new_blocks.next().unwrap();
-                    }
-                    // fill current
-                    get_block_cache(indirect2[a0] as usize, Arc::clone(block_device))
-                        .lock()
-                        .modify(0, |indirect1: &mut IndirectBlock| {
-                            indirect1[b0] = new_blocks.next().unwrap();
-                        });
-                    // move to next
-                    b0 += 1;
-                    if b0 == INODE_INDIRECT1_COUNT {
-                        b0 = 0;
-                        a0 += 1;
-                    }
-                }
-            });
-    }
-
-    /// Clear size to zero and return blocks that should be deallocated.
-    ///
-    /// We will clear the block contents to zero later.
-    pub fn clear_size(&mut self, block_device: &Arc<dyn BlockDevice>) -> Vec<u32> {
-        let mut v: Vec<u32> = Vec::new();
-        let mut data_blocks = self.data_blocks() as usize;
-        self.size = 0;
-        let mut current_blocks = 0usize;
-        // direct
-        while current_blocks < data_blocks.min(INODE_DIRECT_COUNT) {
-            v.push(self.direct[current_blocks]);
-            self.direct[current_blocks] = 0;
-            current_blocks += 1;
-        }
-        // indirect1 block
-        if data_blocks > INODE_DIRECT_COUNT {
-            v.push(self.indirect1);
-            data_blocks -= INODE_DIRECT_COUNT;
-            current_blocks = 0;
-        } else {
-            return v;
-        }
-        // indirect1
-        get_block_cache(self.indirect1 as usize, Arc::clone(block_device))
-            .lock()
-            .modify(0, |indirect1: &mut IndirectBlock| {
-                while current_blocks < data_blocks.min(INODE_INDIRECT1_COUNT) {
-                    v.push(indirect1[current_blocks]);
-                    //indirect1[current_blocks] = 0;
-                    current_blocks += 1;
-                }
-            });
-        self.indirect1 = 0;
-        // indirect2 block
-        if data_blocks > INODE_INDIRECT1_COUNT {
-            v.push(self.indirect2);
-            data_blocks -= INODE_INDIRECT1_COUNT;
-        } else {
-            return v;
-        }
-        // indirect2
-        assert!(data_blocks <= INODE_INDIRECT2_COUNT);
-        let a1 = data_blocks / INODE_INDIRECT1_COUNT;
-        let b1 = data_blocks % INODE_INDIRECT1_COUNT;
-        get_block_cache(self.indirect2 as usize, Arc::clone(block_device))
-            .lock()
-            .modify(0, |indirect2: &mut IndirectBlock| {
-                // full indirect1 blocks
-                for entry in indirect2.iter_mut().take(a1) {
-                    v.push(*entry);
-                    get_block_cache(*entry as usize, Arc::clone(block_device))
-                        .lock()
-                        .modify(0, |indirect1: &mut IndirectBlock| {
-                            for entry in indirect1.iter() {
-                                v.push(*entry);
-                            }
-                        });
-                }
-                // last indirect1 block
-                if b1 > 0 {
-                    v.push(indirect2[a1]);
-                    get_block_cache(indirect2[a1] as usize, Arc::clone(block_device))
-                        .lock()
-                        .modify(0, |indirect1: &mut IndirectBlock| {
-                            for entry in indirect1.iter().take(b1) {
-                                v.push(*entry);
-                            }
-                        });
-                    //indirect2[a1] = 0;
-                }
-            });
-        self.indirect2 = 0;
-        v
-    }
-    pub fn read_at(
-        &self,
-        offset: usize,
-        buf: &mut [u8],
-        block_device: &Arc<dyn BlockDevice>,
-    ) -> usize {
-        let mut start = offset;
-        let end = (offset + buf.len()).min(self.size as usize);
-        if start >= end {
-            return 0;
-        }
-        let mut start_block = start / BLOCK_SZ;
-        let mut read_size = 0usize;
-        loop {
-            // calculate end of current block
-            let mut end_current_block = (start / BLOCK_SZ + 1) * BLOCK_SZ;
-            end_current_block = end_current_block.min(end);
-            // read and update read size
-            let block_read_size = end_current_block - start;
-            let dst = &mut buf[read_size..read_size + block_read_size];
-            get_block_cache(
-                self.get_block_id(start_block as u32, block_device) as usize,
-                Arc::clone(block_device),
-            )
-            .lock()
-            .read(0, |data_block: &DataBlock| {
-                let src = &data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];
-                dst.copy_from_slice(src);
-            });
-            read_size += block_read_size;
-            // move to next block
-            if end_current_block == end {
-                break;
-            }
-            start_block += 1;
-            start = end_current_block;
-        }
-        read_size
-    }
-    /// File size must be adjusted before.
-    pub fn write_at(
-        &mut self,
-        offset: usize,
-        buf: &[u8],
-        block_device: &Arc<dyn BlockDevice>,
-    ) -> usize {
-        let mut start = offset;
-        let end = (offset + buf.len()).min(self.size as usize);
-        assert!(start <= end);
-        let mut start_block = start / BLOCK_SZ;
-        let mut write_size = 0usize;
-        loop {
-            // calculate end of current block
-            let mut end_current_block = (start / BLOCK_SZ + 1) * BLOCK_SZ;
-            end_current_block = end_current_block.min(end);
-            // write and update write size
-            let block_write_size = end_current_block - start;
-            get_block_cache(
-                self.get_block_id(start_block as u32, block_device) as usize,
-                Arc::clone(block_device),
-            )
-            .lock()
-            .modify(0, |data_block: &mut DataBlock| {
-                let src = &buf[write_size..write_size + block_write_size];
-                let dst = &mut data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_write_size];
-                dst.copy_from_slice(src);
-            });
-            write_size += block_write_size;
-            // move to next block
-            if end_current_block == end {
-                break;
-            }
-            start_block += 1;
-            start = end_current_block;
-        }
-        write_size
-    }
-}
-
-#[repr(C)]
-pub struct DirEntry {
-    name: [u8; NAME_LENGTH_LIMIT + 1],
-    inode_number: u32,
-}
-
-pub const DIRENT_SZ: usize = 32;
-
-impl DirEntry {
-    pub fn empty() -> Self {
-        Self {
-            name: [0u8; NAME_LENGTH_LIMIT + 1],
-            inode_number: 0,
-        }
-    }
-    pub fn new(name: &str, inode_number: u32) -> Self {
-        let mut bytes = [0u8; NAME_LENGTH_LIMIT + 1];
-        bytes[..name.len()].copy_from_slice(name.as_bytes());
-        Self {
-            name: bytes,
-            inode_number,
-        }
-    }
-    pub fn as_bytes(&self) -> &[u8] {
-        unsafe { core::slice::from_raw_parts(self as *const _ as usize as *const u8, DIRENT_SZ) }
-    }
-    pub fn as_bytes_mut(&mut self) -> &mut [u8] {
-        unsafe { core::slice::from_raw_parts_mut(self as *mut _ as usize as *mut u8, DIRENT_SZ) }
-    }
-    pub fn name(&self) -> &str {
-        let len = (0usize..).find(|i| self.name[*i] == 0).unwrap();
-        core::str::from_utf8(&self.name[..len]).unwrap()
-    }
-    pub fn inode_number(&self) -> u32 {
-        self.inode_number
-    }
-}
diff --git a/easy-fs/src/lib.rs b/easy-fs/src/lib.rs
deleted file mode 100644
index 866a737..0000000
--- a/easy-fs/src/lib.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-#![no_std]
-
-extern crate alloc;
-
-mod bitmap;
-mod block_cache;
-mod block_dev;
-mod efs;
-mod layout;
-mod vfs;
-
-pub const BLOCK_SZ: usize = 512;
-use bitmap::Bitmap;
-use block_cache::{block_cache_sync_all, get_block_cache};
-pub use block_dev::BlockDevice;
-pub use efs::EasyFileSystem;
-use layout::*;
-pub use vfs::Inode;
diff --git a/easy-fs/src/vfs.rs b/easy-fs/src/vfs.rs
deleted file mode 100644
index d082a6b..0000000
--- a/easy-fs/src/vfs.rs
+++ /dev/null
@@ -1,186 +0,0 @@
-use super::{
-    block_cache_sync_all, get_block_cache, BlockDevice, DirEntry, DiskInode, DiskInodeType,
-    EasyFileSystem, DIRENT_SZ,
-};
-use alloc::string::String;
-use alloc::sync::Arc;
-use alloc::vec::Vec;
-use spin::{Mutex, MutexGuard};
-
-pub struct Inode {
-    block_id: usize,
-    block_offset: usize,
-    fs: Arc<Mutex<EasyFileSystem>>,
-    block_device: Arc<dyn BlockDevice>,
-}
-
-impl Inode {
-    /// We should not acquire efs lock here.
-    pub fn new(
-        block_id: u32,
-        block_offset: usize,
-        fs: Arc<Mutex<EasyFileSystem>>,
-        block_device: Arc<dyn BlockDevice>,
-    ) -> Self {
-        Self {
-            block_id: block_id as usize,
-            block_offset,
-            fs,
-            block_device,
-        }
-    }
-
-    fn read_disk_inode<V>(&self, f: impl FnOnce(&DiskInode) -> V) -> V {
-        get_block_cache(self.block_id, Arc::clone(&self.block_device))
-            .lock()
-            .read(self.block_offset, f)
-    }
-
-    fn modify_disk_inode<V>(&self, f: impl FnOnce(&mut DiskInode) -> V) -> V {
-        get_block_cache(self.block_id, Arc::clone(&self.block_device))
-            .lock()
-            .modify(self.block_offset, f)
-    }
-
-    fn find_inode_id(&self, name: &str, disk_inode: &DiskInode) -> Option<u32> {
-        // assert it is a directory
-        assert!(disk_inode.is_dir());
-        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
-        let mut dirent = DirEntry::empty();
-        for i in 0..file_count {
-            assert_eq!(
-                disk_inode.read_at(DIRENT_SZ * i, dirent.as_bytes_mut(), &self.block_device,),
-                DIRENT_SZ,
-            );
-            if dirent.name() == name {
-                return Some(dirent.inode_number() as u32);
-            }
-        }
-        None
-    }
-
-    pub fn find(&self, name: &str) -> Option<Arc<Inode>> {
-        let fs = self.fs.lock();
-        self.read_disk_inode(|disk_inode| {
-            self.find_inode_id(name, disk_inode).map(|inode_id| {
-                let (block_id, block_offset) = fs.get_disk_inode_pos(inode_id);
-                Arc::new(Self::new(
-                    block_id,
-                    block_offset,
-                    self.fs.clone(),
-                    self.block_device.clone(),
-                ))
-            })
-        })
-    }
-
-    fn increase_size(
-        &self,
-        new_size: u32,
-        disk_inode: &mut DiskInode,
-        fs: &mut MutexGuard<EasyFileSystem>,
-    ) {
-        if new_size < disk_inode.size {
-            return;
-        }
-        let blocks_needed = disk_inode.blocks_num_needed(new_size);
-        let mut v: Vec<u32> = Vec::new();
-        for _ in 0..blocks_needed {
-            v.push(fs.alloc_data());
-        }
-        disk_inode.increase_size(new_size, v, &self.block_device);
-    }
-
-    pub fn create(&self, name: &str) -> Option<Arc<Inode>> {
-        let mut fs = self.fs.lock();
-        let op = |root_inode: &mut DiskInode| {
-            // assert it is a directory
-            assert!(root_inode.is_dir());
-            // has the file been created?
-            self.find_inode_id(name, root_inode)
-        };
-        if self.modify_disk_inode(op).is_some() {
-            return None;
-        }
-        // create a new file
-        // alloc a inode with an indirect block
-        let new_inode_id = fs.alloc_inode();
-        // initialize inode
-        let (new_inode_block_id, new_inode_block_offset) = fs.get_disk_inode_pos(new_inode_id);
-        get_block_cache(new_inode_block_id as usize, Arc::clone(&self.block_device))
-            .lock()
-            .modify(new_inode_block_offset, |new_inode: &mut DiskInode| {
-                new_inode.initialize(DiskInodeType::File);
-            });
-        self.modify_disk_inode(|root_inode| {
-            // append file in the dirent
-            let file_count = (root_inode.size as usize) / DIRENT_SZ;
-            let new_size = (file_count + 1) * DIRENT_SZ;
-            // increase size
-            self.increase_size(new_size as u32, root_inode, &mut fs);
-            // write dirent
-            let dirent = DirEntry::new(name, new_inode_id);
-            root_inode.write_at(
-                file_count * DIRENT_SZ,
-                dirent.as_bytes(),
-                &self.block_device,
-            );
-        });
-
-        let (block_id, block_offset) = fs.get_disk_inode_pos(new_inode_id);
-        block_cache_sync_all();
-        // return inode
-        Some(Arc::new(Self::new(
-            block_id,
-            block_offset,
-            self.fs.clone(),
-            self.block_device.clone(),
-        )))
-        // release efs lock automatically by compiler
-    }
-
-    pub fn ls(&self) -> Vec<String> {
-        let _fs = self.fs.lock();
-        self.read_disk_inode(|disk_inode| {
-            let file_count = (disk_inode.size as usize) / DIRENT_SZ;
-            let mut v: Vec<String> = Vec::new();
-            for i in 0..file_count {
-                let mut dirent = DirEntry::empty();
-                assert_eq!(
-                    disk_inode.read_at(i * DIRENT_SZ, dirent.as_bytes_mut(), &self.block_device,),
-                    DIRENT_SZ,
-                );
-                v.push(String::from(dirent.name()));
-            }
-            v
-        })
-    }
-
-    pub fn read_at(&self, offset: usize, buf: &mut [u8]) -> usize {
-        let _fs = self.fs.lock();
-        self.read_disk_inode(|disk_inode| disk_inode.read_at(offset, buf, &self.block_device))
-    }
-
-    pub fn write_at(&self, offset: usize, buf: &[u8]) -> usize {
-        let mut fs = self.fs.lock();
-        let size = self.modify_disk_inode(|disk_inode| {
-            self.increase_size((offset + buf.len()) as u32, disk_inode, &mut fs);
-            disk_inode.write_at(offset, buf, &self.block_device)
-        });
-        block_cache_sync_all();
-        size
-    }
-
-    pub fn clear(&self) {
-        let mut fs = self.fs.lock();
-        self.modify_disk_inode(|disk_inode| {
-            let size = disk_inode.size;
-            let data_blocks_dealloc = disk_inode.clear_size(&self.block_device);
-            assert!(data_blocks_dealloc.len() == DiskInode::total_blocks(size) as usize);
-            for data_block in data_blocks_dealloc.into_iter() {
-                fs.dealloc_data(data_block);
-            }
-        });
-        block_cache_sync_all();
-    }
-}
diff --git a/kernel/Cargo.toml b/kernel/Cargo.toml
index 229ab2c..9c1cee5 100644
--- a/kernel/Cargo.toml
+++ b/kernel/Cargo.toml
@@ -12,24 +12,27 @@ bitflags = "1.2.1"
 xmas-elf = "0.7.0"
 volatile = "0.3"
 virtio-drivers = { git = "https://github.com/rcore-os/virtio-drivers", rev = "4ee80e5" }
-easy-fs = { path = "../easy-fs" }
+easy-fs = { path = "../application/easy-fs" }
 embedded-graphics = "0.7.1"
 tinybmp = "0.3.1"
+woke = "0.0.2"
+config = { path = "../tconfig", package = "tconfig" }
 
 [dependencies.riscv]
 git = "https://github.com/Andre-HJR/riscv.git"
 rev = "031d548a"
 
+
 # [dependencies.sbi-rt]
 # version = "^0.0.2"
 # features = ["legacy"]
 
 [dependencies.linker]
-path = "../linker"
+path = "../other_libs/linker"
 
 
 [build-dependencies.linker]
-path = "../linker"
+path = "../other_libs/linker"
 
 [lib]
 bench = false
diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs
index a74b32d..ea2dc90 100644
--- a/kernel/src/lib.rs
+++ b/kernel/src/lib.rs
@@ -1,7 +1,8 @@
 #![no_main]
 #![no_std]
 #![feature(naked_functions, asm_const, alloc_error_handler, panic_info_message)]
-#![deny(warnings, unused_imports)]
+#![deny(warnings, unused_imports, dead_code)]
+#![allow(unused_imports, dead_code)]
 
 //use crate::drivers::{GPU_DEVICE, KEYBOARD_DEVICE, MOUSE_DEVICE, INPUT_CONDVAR};
 use crate::drivers::{GPU_DEVICE, KEYBOARD_DEVICE, MOUSE_DEVICE};
@@ -15,12 +16,14 @@ mod plantform;
 #[macro_use]
 extern crate bitflags;
 
+extern crate config;
+
+use config::*;
 #[path = "boards/qemu.rs"]
 mod board;
 
 #[macro_use]
 mod console;
-mod config;
 mod drivers;
 mod fs;
 mod lang_items;
@@ -32,6 +35,7 @@ mod task;
 mod timer;
 mod trap;
 
+
 use crate::drivers::chardev::CharDevice;
 use crate::drivers::chardev::UART;
 
diff --git a/kernel/src/trap/mod.rs b/kernel/src/trap/mod.rs
index 82834b3..b69d6ea 100644
--- a/kernel/src/trap/mod.rs
+++ b/kernel/src/trap/mod.rs
@@ -1,4 +1,5 @@
 mod context;
+// #[deprecated] mod switch;
 
 use crate::config::TRAMPOLINE;
 use crate::syscall::syscall;
@@ -167,3 +168,5 @@ pub fn trap_from_kernel(_trap_cx: &TrapContext) {
 }
 
 pub use context::TrapContext;
+
+// pub use switch::*;
\ No newline at end of file
diff --git a/kernel_lib/.cargo/config.toml b/kernel_lib/.cargo/config.toml
deleted file mode 100644
index 6a5ba74..0000000
--- a/kernel_lib/.cargo/config.toml
+++ /dev/null
@@ -1,2 +0,0 @@
-[build]
-target = "riscv64gc-unknown-none-elf"
\ No newline at end of file
diff --git a/kernel_lib/.gitignore b/kernel_lib/.gitignore
deleted file mode 100644
index 4fffb2f..0000000
--- a/kernel_lib/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/target
-/Cargo.lock
diff --git a/kernel_lib/Cargo.toml b/kernel_lib/Cargo.toml
deleted file mode 100644
index 03b94dd..0000000
--- a/kernel_lib/Cargo.toml
+++ /dev/null
@@ -1,31 +0,0 @@
-[package]
-name = "kernel_lib"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-
-[dependencies.sbi-rt]
-version = "^0.0.2"
-features = ["legacy"]
-
-[dependencies.linker]
-path = "../linker"
-
-
-[build-dependencies.linker]
-path = "../linker"
-
-[lib]
-bench = false
-# staticlib is required to build a self-contained, fully-linked .a file
-# that we can jump to from the bootloader
-crate-type = ["staticlib"]
-
-[profile.dev]
-panic = "abort"
-
-[profile.release]
-panic = "abort"
\ No newline at end of file
diff --git a/kernel_lib/build.rs b/kernel_lib/build.rs
deleted file mode 100644
index 0bac1dc..0000000
--- a/kernel_lib/build.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-fn main() {
-    use std::{env, fs, path::PathBuf};
-
-    let ld = &PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("linker.ld");
-    fs::write(ld, linker::SCRIPT).unwrap();
-
-    println!("cargo:rerun-if-changed=build.rs");
-    println!("cargo:rerun-if-env-changed=LOG");
-    println!("cargo:rerun-if-env-changed=APP_ASM");
-    println!("cargo:rustc-link-arg=-T{}", ld.display());
-}
diff --git a/kernel_lib/src/lib.rs b/kernel_lib/src/lib.rs
deleted file mode 100644
index d81bb12..0000000
--- a/kernel_lib/src/lib.rs
+++ /dev/null
@@ -1,32 +0,0 @@
-#![no_main]
-#![no_std]
-#![feature(naked_functions, asm_const)]
-#![deny(warnings)]
-
-#[cfg(test)]
-mod test {}
-
-pub mod plantform;
-
-/// 非常简单的 Supervisor 裸机程序。
-///
-/// 打印 `Hello, World!`，然后关机。
-#[no_mangle]
-extern "C" fn rcore_main() -> ! {
-    use sbi_rt::*;
-    for c in b"Hello, world!" {
-        #[allow(deprecated)]
-        legacy::console_putchar(*c as _);
-    }
-    system_reset(Shutdown, NoReason);
-    unreachable!()
-}
-
-use core::panic::PanicInfo;
-
-#[panic_handler]
-pub fn panic(_info: &PanicInfo) -> ! {
-    use sbi_rt::*;
-    system_reset(Shutdown, SystemFailure);
-    loop {}
-}
diff --git a/kernel_lib/src/plantform/arch/mod.rs b/kernel_lib/src/plantform/arch/mod.rs
deleted file mode 100644
index 3974001..0000000
--- a/kernel_lib/src/plantform/arch/mod.rs
+++ /dev/null
@@ -1,5 +0,0 @@
-// arch dependent kernel code
-// for arch or device dependent code, e.g. boot, drivers -> use src/drivers or support/arch
-
-// #[cfg(target_arch = "riscv64")]
-pub mod riscv64gc;
diff --git a/kernel_lib/src/plantform/arch/riscv64gc/asm/entry.S b/kernel_lib/src/plantform/arch/riscv64gc/asm/entry.S
deleted file mode 100644
index 8267fb4..0000000
--- a/kernel_lib/src/plantform/arch/riscv64gc/asm/entry.S
+++ /dev/null
@@ -1,11 +0,0 @@
-    .section .text.entry
-    .globl _start
-_start:
-    la sp, boot_stack_top
-    call rcore_main
-    .section .bss.stack
-    .globl boot_stack_lower_bound
-boot_stack_lower_bound:
-    .space 4096 * 16
-    .globl boot_stack_top
-boot_stack_top:
diff --git a/kernel_lib/src/plantform/arch/riscv64gc/link/linker.ld b/kernel_lib/src/plantform/arch/riscv64gc/link/linker.ld
deleted file mode 100644
index f5b7f65..0000000
--- a/kernel_lib/src/plantform/arch/riscv64gc/link/linker.ld
+++ /dev/null
@@ -1,29 +0,0 @@
-OUTPUT_ARCH(riscv)
-SECTIONS {
-    .text 0x80200000 : {
-        __start = .;
-        *(.text.entry)
-        *(.text .text.*)
-    }
-    .rodata : ALIGN(4K) {
-        __rodata = .;
-        *(.rodata .rodata.*)
-        *(.srodata .srodata.*)
-    }
-    .data : ALIGN(4K) {
-        __data = .;
-        *(.data .data.*)
-        *(.sdata .sdata.*)
-    }
-    .bss : ALIGN(8) {
-        __sbss = .;
-        *(.bss .bss.*)
-        *(.sbss .sbss.*)
-        __ebss = .;
-    }
-    .boot : ALIGN(4K) {
-        __boot = .;
-        KEEP(*(.boot.stack))
-    }
-    __end = .;
-}
\ No newline at end of file
diff --git a/kernel_lib/src/plantform/arch/riscv64gc/mod.rs b/kernel_lib/src/plantform/arch/riscv64gc/mod.rs
deleted file mode 100644
index 24d91fb..0000000
--- a/kernel_lib/src/plantform/arch/riscv64gc/mod.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-// Supervisor 汇编入口。
-//
-// 设置栈并跳转到 Rust。
-//
-// ```rust
-// #[naked]
-// #[no_mangle]
-// #[link_section = ".text.entry"]
-// unsafe extern "C" fn _start() -> ! {
-//     const STACK_SIZE: usize = 4096;
-//
-//     #[link_section = ".bss.uninit"]
-//     static mut STACK: [u8; STACK_SIZE] = [0u8; STACK_SIZE];
-//
-//     core::arch::asm!(
-//         "la sp, {stack} + {stack_size}",
-//         "j  {main}",
-//         stack_size = const STACK_SIZE,
-//         stack      =   sym STACK,
-//         main       =   sym rcore_main,
-//         options(noreturn),
-//     )
-// }
-// ```
-
-use crate::rcore_main;
-
-linker::boot0!(rcore_main; stack = 16 * 4096);
diff --git a/kernel_lib/src/plantform/mod.rs b/kernel_lib/src/plantform/mod.rs
deleted file mode 100644
index 5f798bc..0000000
--- a/kernel_lib/src/plantform/mod.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-// ARCH DEPENDENT STUFF
-
-pub mod arch;
-// pub mod posix; // not finished
-
-// INTERFACE TO HANDLE DEPENDENT + INDEPENDENT CODE TOGETHER
-// prob cant test directly, at least easily
-
-// NON-ARCH KERNEL STUFF
-
-// extern crate alloc;
-// use alloc::vec;
-
-// use crate::filesystem::{Filesystem, File};
-
-// pub struct KernelManager {
-//     filesystem: Filesystem
-// }
-
-// impl KernelManager {
-//     fn k_main(&self) {
-//         loop {}
-//     }
-
-//     // create a default Kernel Manager with a single empty file (dir) in the HFS
-//     pub fn new() -> KernelManager {
-//         KernelManager {filesystem: Filesystem{files: vec!(File{size: 0})}}
-//     }
-// }
diff --git a/linker/Cargo.toml b/linker/Cargo.toml
deleted file mode 100644
index f4e697b..0000000
--- a/linker/Cargo.toml
+++ /dev/null
@@ -1,8 +0,0 @@
-[package]
-name = "linker"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
diff --git a/linker/src/lib.rs b/linker/src/lib.rs
deleted file mode 100644
index aa6ad5a..0000000
--- a/linker/src/lib.rs
+++ /dev/null
@@ -1,320 +0,0 @@
-//! 这个板块为内核提供链接脚本的文本，以及依赖于定制链接脚本的功能。
-//!
-//! build.rs 文件可依赖此板块，并将 [`SCRIPT`] 文本常量写入链接脚本文件：
-//!
-//! ```rust
-//! use std::{env, fs, path::PathBuf};
-//!
-//! let ld = &PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("linker.ld");
-//! fs::write(ld, linker::SCRIPT).unwrap();
-//!
-//! println!("cargo:rerun-if-changed=build.rs");
-//! println!("cargo:rustc-link-arg=-T{}", ld.display());
-//! ```
-//!
-//! 内核使用 [`boot0`] 宏定义内核启动栈和高级语言入口：
-//!
-//! ```rust
-//! linker::boot0!(rcore_main; stack = 4 * 4096);
-//! ```
-//!
-//! 内核所在内核区域定义成 4 个部分（[`KernelRegionTitle`]）:
-//!
-//! 1. 代码段
-//! 2. 只读数据段
-//! 3. 数据段
-//! 4. 启动数据段
-//!
-//! 启动数据段放在最后，以便启动完成后换栈。届时可放弃启动数据段，将其加入动态内存区。
-//!
-//! 用 [`KernelLayout`] 结构体定位、保存和访问内核内存布局。
-
-#![no_std]
-#![deny(warnings, missing_docs)]
-
-mod app {
-    /// 应用程序元数据。
-    #[repr(C)]
-    pub struct AppMeta {
-        base: u64,
-        step: u64,
-        count: u64,
-        first: u64,
-    }
-
-    impl AppMeta {
-        /// 定位应用程序。
-        #[inline]
-        pub fn locate() -> &'static Self {
-            extern "C" {
-                static apps: AppMeta;
-            }
-            unsafe { &apps }
-        }
-
-        /// 遍历链接进来的应用程序。
-        #[inline]
-        pub fn iter(&'static self) -> AppIterator {
-            AppIterator { meta: self, i: 0 }
-        }
-    }
-
-    /// 应用程序迭代器。
-    pub struct AppIterator {
-        meta: &'static AppMeta,
-        i: u64,
-    }
-
-    impl Iterator for AppIterator {
-        type Item = &'static [u8];
-
-        fn next(&mut self) -> Option<Self::Item> {
-            if self.i >= self.meta.count {
-                None
-            } else {
-                let i = self.i as usize;
-                self.i += 1;
-                unsafe {
-                    let slice = core::slice::from_raw_parts(
-                        &self.meta.first as *const _ as *const usize,
-                        (self.meta.count + 1) as _,
-                    );
-                    let pos = slice[i];
-                    let size = slice[i + 1] - pos;
-                    let base = self.meta.base as usize + i * self.meta.step as usize;
-                    if base != 0 {
-                        core::ptr::copy_nonoverlapping::<u8>(pos as _, base as _, size);
-                        core::slice::from_raw_parts_mut(base as *mut u8, 0x20_0000)[size..].fill(0);
-                        Some(core::slice::from_raw_parts(base as _, size))
-                    } else {
-                        Some(core::slice::from_raw_parts(pos as _, size))
-                    }
-                }
-            }
-        }
-    }
-}
-
-pub use app::{AppIterator, AppMeta};
-
-/// 链接脚本。
-pub const SCRIPT: &[u8] = b"\
-OUTPUT_ARCH(riscv)
-SECTIONS {
-    .text 0x80200000 : {
-        __start = .;
-        *(.text.entry)
-        *(.text .text.*)
-    }
-    .rodata : ALIGN(4K) {
-        __rodata = .;
-        *(.rodata .rodata.*)
-        *(.srodata .srodata.*)
-    }
-    .data : ALIGN(4K) {
-        __data = .;
-        *(.data .data.*)
-        *(.sdata .sdata.*)
-    }
-    .bss : ALIGN(8) {
-        __sbss = .;
-        *(.bss .bss.*)
-        *(.sbss .sbss.*)
-        __ebss = .;
-    }
-    .boot : ALIGN(4K) {
-        __boot = .;
-        KEEP(*(.boot.stack))
-    }
-    __end = .;
-}";
-
-/// 定义内核入口。
-///
-/// 将设置一个启动栈，并在启动栈上调用高级语言入口。
-#[macro_export]
-macro_rules! boot0 {
-    ($entry:ident; stack = $stack:expr) => {
-        #[naked]
-        #[no_mangle]
-        #[link_section = ".text.entry"]
-        unsafe extern "C" fn _start() -> ! {
-            #[link_section = ".boot.stack"]
-            static mut STACK: [u8; $stack] = [0u8; $stack];
-
-            core::arch::asm!(
-                "la sp, __end",
-                "j  {main}",
-                main = sym $entry,
-                options(noreturn),
-            )
-        }
-    };
-}
-
-/// 内核地址信息。
-#[derive(Debug)]
-pub struct KernelLayout {
-    text: usize,
-    rodata: usize,
-    data: usize,
-    sbss: usize,
-    ebss: usize,
-    boot: usize,
-    end: usize,
-}
-
-impl KernelLayout {
-    /// 非零初始化，避免 bss。
-    pub const INIT: Self = Self {
-        text: usize::MAX,
-        rodata: usize::MAX,
-        data: usize::MAX,
-        sbss: usize::MAX,
-        ebss: usize::MAX,
-        boot: usize::MAX,
-        end: usize::MAX,
-    };
-
-    /// 定位内核布局。
-    #[inline]
-    pub fn locate() -> Self {
-        extern "C" {
-            fn __start();
-            fn __rodata();
-            fn __data();
-            fn __sbss();
-            fn __ebss();
-            fn __boot();
-            fn __end();
-        }
-
-        Self {
-            text: __start as _,
-            rodata: __rodata as _,
-            data: __data as _,
-            sbss: __sbss as _,
-            ebss: __ebss as _,
-            boot: __boot as _,
-            end: __end as _,
-        }
-    }
-
-    /// 内核起始地址。
-    #[inline]
-    pub const fn start(&self) -> usize {
-        self.text
-    }
-
-    /// 内核结尾地址。
-    #[inline]
-    pub const fn end(&self) -> usize {
-        self.end
-    }
-
-    /// 内核静态二进制长度。
-    #[inline]
-    pub const fn len(&self) -> usize {
-        self.end - self.text
-    }
-
-    /// 清零 .bss 段。
-    #[inline]
-    pub unsafe fn zero_bss(&self) {
-        let mut ptr = self.sbss as *mut u8;
-        let end = self.ebss as *mut u8;
-        while ptr < end {
-            // **NOTICE** 单核其实无所谓，多核必须 volatile write 其他核才能看见
-            ptr.write_volatile(0);
-            ptr = ptr.offset(1);
-        }
-    }
-
-    /// 内核区段迭代器。
-    #[inline]
-    pub fn iter(&self) -> KernelRegionIterator {
-        KernelRegionIterator {
-            layout: self,
-            next: Some(KernelRegionTitle::Text),
-        }
-    }
-}
-
-use core::{fmt, ops::Range};
-
-/// 内核内存分区迭代器。
-pub struct KernelRegionIterator<'a> {
-    layout: &'a KernelLayout,
-    next: Option<KernelRegionTitle>,
-}
-
-/// 内核内存分区名称。
-#[derive(Clone, Copy)]
-pub enum KernelRegionTitle {
-    /// 代码段。
-    Text,
-    /// 只读数据段。
-    Rodata,
-    /// 数据段。
-    Data,
-    /// 启动数据段。
-    Boot,
-}
-
-/// 内核内存分区。
-pub struct KernelRegion {
-    /// 分区名称。
-    pub title: KernelRegionTitle,
-    /// 分区地址范围。
-    pub range: Range<usize>,
-}
-
-impl fmt::Display for KernelRegion {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self.title {
-            KernelRegionTitle::Text => write!(f, ".text ----> ")?,
-            KernelRegionTitle::Rodata => write!(f, ".rodata --> ")?,
-            KernelRegionTitle::Data => write!(f, ".data ----> ")?,
-            KernelRegionTitle::Boot => write!(f, ".boot ----> ")?,
-        }
-        write!(f, "{:#10x}..{:#10x}", self.range.start, self.range.end)
-    }
-}
-
-impl Iterator for KernelRegionIterator<'_> {
-    type Item = KernelRegion;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        use KernelRegionTitle::*;
-        match self.next? {
-            Text => {
-                self.next = Some(Rodata);
-                Some(KernelRegion {
-                    title: Text,
-                    range: self.layout.text..self.layout.rodata,
-                })
-            }
-            Rodata => {
-                self.next = Some(Data);
-                Some(KernelRegion {
-                    title: Rodata,
-                    range: self.layout.rodata..self.layout.data,
-                })
-            }
-            Data => {
-                self.next = Some(Boot);
-                Some(KernelRegion {
-                    title: Data,
-                    range: self.layout.data..self.layout.ebss,
-                })
-            }
-            Boot => {
-                self.next = None;
-                Some(KernelRegion {
-                    title: Boot,
-                    range: self.layout.boot..self.layout.end,
-                })
-            }
-        }
-    }
-}
diff --git a/signal-defs/Cargo.toml b/signal-defs/Cargo.toml
deleted file mode 100644
index cbe322c..0000000
--- a/signal-defs/Cargo.toml
+++ /dev/null
@@ -1,9 +0,0 @@
-[package]
-name = "signal-defs"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-numeric-enum-macro = "0.2.0"
\ No newline at end of file
diff --git a/signal-defs/src/lib.rs b/signal-defs/src/lib.rs
deleted file mode 100644
index 8b5bd9c..0000000
--- a/signal-defs/src/lib.rs
+++ /dev/null
@@ -1,96 +0,0 @@
-#![no_std]
-
-#[repr(C)]
-#[derive(Debug, Clone, Copy, Default)]
-/// 信号处理函数的定义
-pub struct SignalAction {
-    pub handler: usize,
-    pub mask: usize,
-}
-
-/// 最大的信号编号
-pub const MAX_SIG: usize = 31;
-
-// 信号标号的定义
-// 目前 rCore-Tutorial 没有用到 [32, 64) 部分的实时信号，但仍给出定义
-numeric_enum_macro::numeric_enum! {
-    #[repr(u8)]
-    #[allow(missing_docs)]
-    #[derive(Eq, PartialEq, Debug, Copy, Clone)]
-    /// 信号编号。
-    ///
-    /// 从 32 开始的部分为 SIGRT，其中 RT 表示 real time。
-    /// 但目前实现时没有通过 ipi 等手段即时处理，而是像其他信号一样等到 trap 再处理
-    pub enum SignalNo {
-        ERR = 0,
-        SIGHUP = 1,
-        SIGINT = 2,
-        SIGQUIT = 3,
-        SIGILL = 4,
-        SIGTRAP = 5,
-        SIGABRT = 6,
-        SIGBUS = 7,
-        SIGFPE = 8,
-        SIGKILL = 9,
-        SIGUSR1 = 10,
-        SIGSEGV = 11,
-        SIGUSR2 = 12,
-        SIGPIPE = 13,
-        SIGALRM = 14,
-        SIGTERM = 15,
-        SIGSTKFLT = 16,
-        SIGCHLD = 17,
-        SIGCONT = 18,
-        SIGSTOP = 19,
-        SIGTSTP = 20,
-        SIGTTIN = 21,
-        SIGTTOU = 22,
-        SIGURG = 23,
-        SIGXCPU = 24,
-        SIGXFSZ = 25,
-        SIGVTALRM = 26,
-        SIGPROF = 27,
-        SIGWINCH = 28,
-        SIGIO = 29,
-        SIGPWR = 30,
-        SIGSYS = 31,
-        SIGRTMIN = 32,
-        SIGRT1 = 33,
-        SIGRT2 = 34,
-        SIGRT3 = 35,
-        SIGRT4 = 36,
-        SIGRT5 = 37,
-        SIGRT6 = 38,
-        SIGRT7 = 39,
-        SIGRT8 = 40,
-        SIGRT9 = 41,
-        SIGRT10 = 42,
-        SIGRT11 = 43,
-        SIGRT12 = 44,
-        SIGRT13 = 45,
-        SIGRT14 = 46,
-        SIGRT15 = 47,
-        SIGRT16 = 48,
-        SIGRT17 = 49,
-        SIGRT18 = 50,
-        SIGRT19 = 51,
-        SIGRT20 = 52,
-        SIGRT21 = 53,
-        SIGRT22 = 54,
-        SIGRT23 = 55,
-        SIGRT24 = 56,
-        SIGRT25 = 57,
-        SIGRT26 = 58,
-        SIGRT27 = 59,
-        SIGRT28 = 60,
-        SIGRT29 = 61,
-        SIGRT30 = 62,
-        SIGRT31 = 63,
-    }
-}
-
-impl From<usize> for SignalNo {
-    fn from(num: usize) -> Self {
-        Self::try_from(num as u8).unwrap_or(Self::ERR)
-    }
-}
diff --git a/signal-impl/Cargo.toml b/signal-impl/Cargo.toml
deleted file mode 100644
index a593dcf..0000000
--- a/signal-impl/Cargo.toml
+++ /dev/null
@@ -1,10 +0,0 @@
-[package]
-name = "signal-impl"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-kernel-context = { path = "../context", package = "context"}
-signal = { path = "../signal" }
\ No newline at end of file
diff --git a/signal-impl/src/default_action.rs b/signal-impl/src/default_action.rs
deleted file mode 100644
index 6cf904d..0000000
--- a/signal-impl/src/default_action.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-use super::{SignalNo, SignalResult};
-
-/// 没有处理函数时的默认行为。
-/// 参见 `https://venam.nixers.net/blog/unix/2016/10/21/unix-signals.html`
-pub enum DefaultAction {
-    Terminate(i32), // 结束进程。其实更标准的实现应该细分为 terminate / terminate(core dump) / stop
-    Ignore,         // 忽略信号
-}
-
-impl From<SignalNo> for DefaultAction {
-    fn from(signal_no: SignalNo) -> Self {
-        match signal_no {
-            SignalNo::SIGCHLD | SignalNo::SIGURG => Self::Ignore,
-            _ => Self::Terminate(-(signal_no as i32)),
-        }
-    }
-}
-
-impl Into<SignalResult> for DefaultAction {
-    fn into(self) -> SignalResult {
-        match self {
-            Self::Terminate(exit_code) => SignalResult::ProcessKilled(exit_code),
-            Self::Ignore => SignalResult::Ignored,
-        }
-    }
-}
diff --git a/signal-impl/src/lib.rs b/signal-impl/src/lib.rs
deleted file mode 100644
index b6daf63..0000000
--- a/signal-impl/src/lib.rs
+++ /dev/null
@@ -1,182 +0,0 @@
-//! 一种信号模块的实现
-
-#![no_std]
-
-extern crate alloc;
-use alloc::boxed::Box;
-use kernel_context::LocalContext;
-use signal::{Signal, SignalAction, SignalNo, SignalResult, MAX_SIG};
-
-mod default_action;
-use default_action::DefaultAction;
-mod signal_set;
-use signal_set::SignalSet;
-
-/// 正在处理的信号
-pub enum HandlingSignal {
-    Frozen,                   // 是内核信号，需要暂停当前进程
-    UserSignal(LocalContext), // 是用户信号，需要保存之前的用户栈
-}
-
-/// 管理一个进程中的信号
-pub struct SignalImpl {
-    /// 已收到的信号
-    pub received: SignalSet,
-    /// 屏蔽的信号掩码
-    pub mask: SignalSet,
-    /// 在信号处理函数中，保存之前的用户栈
-    pub handling: Option<HandlingSignal>,
-    /// 当前任务的信号处理函数集
-    pub actions: [Option<SignalAction>; MAX_SIG + 1],
-}
-
-impl SignalImpl {
-    pub fn new() -> Self {
-        Self {
-            received: SignalSet::empty(),
-            mask: SignalSet::empty(),
-            handling: None,
-            actions: [None; MAX_SIG + 1],
-        }
-    }
-}
-
-impl SignalImpl {
-    /// 获取一个没有被 mask 屏蔽的信号，并从已收到的信号集合中删除它。如果没有这样的信号，则返回空
-    fn fetch_signal(&mut self) -> Option<SignalNo> {
-        // 在已收到的信号中，寻找一个没有被 mask 屏蔽的信号
-        self.received.find_first_one(self.mask).map(|num| {
-            self.received.remove_bit(num);
-            num.into()
-        })
-    }
-
-    /// 检查是否收到一个信号，如果是，则接收并删除它
-    fn fetch_and_remove(&mut self, signal_no: SignalNo) -> bool {
-        if self.received.contain_bit(signal_no as usize)
-            && !self.mask.contain_bit(signal_no as usize)
-        {
-            self.received.remove_bit(signal_no as usize);
-            true
-        } else {
-            false
-        }
-    }
-}
-
-impl Signal for SignalImpl {
-    fn from_fork(&mut self) -> Box<dyn Signal> {
-        Box::new(Self {
-            received: SignalSet::empty(),
-            mask: self.mask,
-            handling: None,
-            actions: {
-                let mut actions = [None; MAX_SIG + 1];
-                actions.copy_from_slice(&self.actions);
-                actions
-            },
-        })
-    }
-
-    fn clear(&mut self) {
-        for action in &mut self.actions {
-            action.take();
-        }
-    }
-
-    /// 添加一个信号
-    fn add_signal(&mut self, signal: SignalNo) {
-        self.received.add_bit(signal as usize)
-    }
-
-    /// 是否当前正在处理信号
-    fn is_handling_signal(&self) -> bool {
-        self.handling.is_some()
-    }
-
-    /// 设置一个信号处理函数。`sys_sigaction` 会使用
-    fn set_action(&mut self, signum: SignalNo, action: &SignalAction) -> bool {
-        if signum == SignalNo::SIGKILL || signum == SignalNo::SIGSTOP {
-            false
-        } else {
-            self.actions[signum as usize] = Some(*action);
-            true
-        }
-    }
-
-    /// 获取一个信号处理函数的值。`sys_sigaction` 会使用
-    fn get_action_ref(&self, signum: SignalNo) -> Option<SignalAction> {
-        if signum == SignalNo::SIGKILL || signum == SignalNo::SIGSTOP {
-            None
-        } else {
-            Some(self.actions[signum as usize].unwrap_or(SignalAction::default()))
-        }
-    }
-
-    /// 设置信号掩码，并获取旧的信号掩码，`sys_procmask` 会使用
-    fn update_mask(&mut self, mask: usize) -> usize {
-        self.mask.set_new(mask.into())
-    }
-
-    fn handle_signals(&mut self, current_context: &mut LocalContext) -> SignalResult {
-        if self.is_handling_signal() {
-            match self.handling.as_ref().unwrap() {
-                // 如果当前正在暂停状态
-                HandlingSignal::Frozen => {
-                    // 则检查是否收到 SIGCONT，如果收到则当前任务需要从暂停状态中恢复
-                    if self.fetch_and_remove(SignalNo::SIGCONT) {
-                        self.handling.take();
-                        SignalResult::Handled
-                    } else {
-                        // 否则，继续暂停
-                        SignalResult::ProcessSuspended
-                    }
-                } // 其他情况下，需要等待当前信号处理结束
-                _ => SignalResult::IsHandlingSignal,
-            }
-        } else if let Some(signal) = self.fetch_signal() {
-            match signal {
-                // SIGKILL 信号不能被捕获或忽略
-                SignalNo::SIGKILL => SignalResult::ProcessKilled(-(signal as i32)),
-                SignalNo::SIGSTOP => {
-                    self.handling = Some(HandlingSignal::Frozen);
-                    SignalResult::ProcessSuspended
-                }
-                _ => {
-                    if let Some(action) = self.actions[signal as usize] {
-                        // 如果用户给定了处理方式，则按照 SignalAction 中的描述处理
-                        // 保存原来用户程序的上下文信息
-                        self.handling = Some(HandlingSignal::UserSignal(current_context.clone()));
-                        // 修改返回后的 pc 值为 handler，修改 a0 为信号编号
-                        //println!("handle pre {:x}, after {:x}", current_context.pc(), action.handler);
-                        *current_context.pc_mut() = action.handler;
-                        *current_context.a_mut(0) = signal as usize;
-                        SignalResult::Handled
-                    } else {
-                        // 否则，使用自定义的 DefaultAction 类来处理
-                        // 然后再转换成 SignalResult
-                        DefaultAction::from(signal).into()
-                    }
-                }
-            }
-        } else {
-            SignalResult::NoSignal
-        }
-    }
-
-    fn sig_return(&mut self, current_context: &mut LocalContext) -> bool {
-        let handling_signal = self.handling.take();
-        match handling_signal {
-            Some(HandlingSignal::UserSignal(old_ctx)) => {
-                //println!("return to {:x} a0 {}", old_ctx.pc(), old_ctx.a(0));
-                *current_context = old_ctx;
-                true
-            }
-            // 如果当前在处理内核信号，或者没有在处理信号，也就谈不上“返回”了
-            _ => {
-                self.handling = handling_signal;
-                false
-            }
-        }
-    }
-}
diff --git a/signal-impl/src/signal_set.rs b/signal-impl/src/signal_set.rs
deleted file mode 100644
index b332b91..0000000
--- a/signal-impl/src/signal_set.rs
+++ /dev/null
@@ -1,70 +0,0 @@
-//! 字符数组。可取并集和差集，也可对给定的 mask 取首位
-//!
-
-#[derive(Clone, Copy, Debug)]
-/// bit数组
-pub struct SignalSet(pub usize);
-
-impl SignalSet {
-    /// 新建一个空的数组
-    pub fn empty() -> Self {
-        Self(0)
-    }
-    /// 新建一个数组，长为 usize = 8Byte
-    pub fn new(v: usize) -> Self {
-        Self(v)
-    }
-    /// 直接暴力写入 SignalSet
-    pub fn reset(&mut self, v: usize) {
-        self.0 = v;
-    }
-    /// 清空 SignalSet
-    pub fn clear(&mut self) {
-        self.0 = 0;
-    }
-    /// 是否包含第 k 个 bit
-    pub fn contain_bit(&self, kth: usize) -> bool {
-        ((self.0 >> kth) & 1) > 0
-    }
-    /// 新增一个 bit
-    pub fn add_bit(&mut self, kth: usize) {
-        self.0 |= 1 << kth;
-    }
-    /// 删除一个 bit
-    pub fn remove_bit(&mut self, kth: usize) {
-        self.0 &= !(1 << kth);
-    }
-    /// 取交集
-    pub fn get_union(&mut self, set: SignalSet) {
-        self.0 |= set.0;
-    }
-    /// 取差集，即去掉 set 中的内容
-    pub fn get_difference(&mut self, set: SignalSet) {
-        self.0 &= !(set.0);
-    }
-    /// 直接设置为新值
-    pub fn set_new(&mut self, set: SignalSet) -> usize {
-        let old = self.0;
-        self.0 = set.0;
-        old
-    }
-    /// 获取后缀0个数，可以用来寻找最小的1
-    pub fn get_trailing_zeros(&self) -> u32 {
-        self.0.trailing_zeros()
-    }
-    /// 寻找不在mask中的最小的 1 的位置，如果有，返回其位置，如没有则返回 None。
-    pub fn find_first_one(&self, mask: SignalSet) -> Option<usize> {
-        let ans = (self.0 & !mask.0).trailing_zeros() as usize;
-        if ans == 64 {
-            None
-        } else {
-            Some(ans)
-        }
-    }
-}
-
-impl From<usize> for SignalSet {
-    fn from(v: usize) -> Self {
-        Self(v)
-    }
-}
diff --git a/signal/Cargo.toml b/signal/Cargo.toml
deleted file mode 100644
index 870901d..0000000
--- a/signal/Cargo.toml
+++ /dev/null
@@ -1,10 +0,0 @@
-[package]
-name = "signal"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-kernel-context = { path = "../context",  package = "context"}
-signal-defs = { path = "../signal-defs" }
\ No newline at end of file
diff --git a/signal/src/lib.rs b/signal/src/lib.rs
deleted file mode 100644
index 8bf3619..0000000
--- a/signal/src/lib.rs
+++ /dev/null
@@ -1,49 +0,0 @@
-//! 信号的管理和处理模块
-//!
-//! 信号模块的实际实现见 `signal_impl` 子模块
-//!
-//!
-
-#![no_std]
-
-extern crate alloc;
-use alloc::boxed::Box;
-use kernel_context::LocalContext;
-pub use signal_defs::{SignalAction, SignalNo, MAX_SIG};
-
-mod signal_result;
-pub use signal_result::SignalResult;
-
-/// 一个信号模块需要对外暴露的接口
-pub trait Signal: Send + Sync {
-    /// 当 fork 一个任务时(在通常的`linux syscall`中，fork是某种参数形式的sys_clone)，
-    /// 需要**继承原任务的信号处理函数和掩码**。
-    /// 此时 `task` 模块会调用此函数，根据原任务的信号模块生成新任务的信号模块
-    fn from_fork(&mut self) -> Box<dyn Signal>;
-
-    /// `sys_exec`会使用。** `sys_exec` 不会继承信号处理函数和掩码**
-    fn clear(&mut self);
-
-    /// 添加一个信号
-    fn add_signal(&mut self, signal: SignalNo);
-
-    /// 是否当前正在处理信号
-    fn is_handling_signal(&self) -> bool;
-
-    /// 设置一个信号处理函数，返回设置是否成功。`sys_sigaction` 会使用。
-    /// （**不成功说明设置是无效的，需要在 sig_action 中返回EINVAL**）
-    fn set_action(&mut self, signum: SignalNo, action: &SignalAction) -> bool;
-
-    /// 获取一个信号处理函数的值，返回设置是否成功。`sys_sigaction` 会使用
-    ///（**不成功说明设置是无效的，需要在 sig_action 中返回EINVAL**）
-    fn get_action_ref(&self, signum: SignalNo) -> Option<SignalAction>;
-
-    /// 设置信号掩码，并获取旧的信号掩码，`sys_procmask` 会使用
-    fn update_mask(&mut self, mask: usize) -> usize;
-
-    /// 进程执行结果，可能是直接返回用户程序或存栈或暂停或退出
-    fn handle_signals(&mut self, current_context: &mut LocalContext) -> SignalResult;
-
-    /// 从信号处理函数中退出，返回值表示是否成功。`sys_sigreturn` 会使用
-    fn sig_return(&mut self, current_context: &mut LocalContext) -> bool;
-}
diff --git a/signal/src/signal_result.rs b/signal/src/signal_result.rs
deleted file mode 100644
index 341f332..0000000
--- a/signal/src/signal_result.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-/// 信号处理函数返回得到的结果
-pub enum SignalResult {
-    /// 没有信号需要处理
-    NoSignal,
-    /// 目前正在处理信号，因而无法接受其他信号
-    IsHandlingSignal,
-    /// 已经处理了一个信号，接下来正常返回用户态即可
-    Ignored,
-    /// 已经处理了一个信号，并修改了用户上下文
-    Handled,
-    /// 需要结束当前进程，并给出退出时向父进程返回的 errno
-    ProcessKilled(i32),
-    /// 需要暂停当前进程，直到其他进程给出继续执行的信号
-    ProcessSuspended,
-}
diff --git a/sync/.cargo/config.toml b/sync/.cargo/config.toml
deleted file mode 100644
index 6a5ba74..0000000
--- a/sync/.cargo/config.toml
+++ /dev/null
@@ -1,2 +0,0 @@
-[build]
-target = "riscv64gc-unknown-none-elf"
\ No newline at end of file
diff --git a/sync/Cargo.toml b/sync/Cargo.toml
deleted file mode 100644
index 294563e..0000000
--- a/sync/Cargo.toml
+++ /dev/null
@@ -1,11 +0,0 @@
-[package]
-name = "sync"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-riscv = "0.10"
-spin = "0.9.4"
-rcore-task-manage = { path = "../task-manage", features = ["thread"], package = "task-manage"}
\ No newline at end of file
diff --git a/sync/src/condvar.rs b/sync/src/condvar.rs
deleted file mode 100644
index bf54f2d..0000000
--- a/sync/src/condvar.rs
+++ /dev/null
@@ -1,61 +0,0 @@
-use super::{Mutex, UPIntrFreeCell};
-use alloc::{collections::VecDeque, sync::Arc};
-use rcore_task_manage::ThreadId;
-
-/// Condvar
-pub struct Condvar {
-    /// UPIntrFreeCell<CondvarInner>
-    pub inner: UPIntrFreeCell<CondvarInner>,
-}
-
-/// CondvarInner
-pub struct CondvarInner {
-    /// block queue
-    pub wait_queue: VecDeque<ThreadId>,
-}
-
-impl Condvar {
-    /// new
-    pub fn new() -> Self {
-        Self {
-            inner: unsafe {
-                UPIntrFreeCell::new(CondvarInner {
-                    wait_queue: VecDeque::new(),
-                })
-            },
-        }
-    }
-    /// 唤醒某个阻塞在当前条件变量上的线程
-    pub fn signal(&self) -> Option<ThreadId> {
-        let mut inner = self.inner.exclusive_access();
-        inner.wait_queue.pop_front()
-    }
-
-    /*
-    pub fn wait(&self) {
-        let mut inner = self.inner.exclusive_access();
-        inner.wait_queue.push_back(current_task().unwrap());
-        drop(inner);
-        block_current_and_run_next();
-    }
-    */
-    /// 将当前线程阻塞在条件变量上
-    pub fn wait_no_sched(&self, tid: ThreadId) -> bool {
-        self.inner.exclusive_session(|inner| {
-            inner.wait_queue.push_back(tid);
-        });
-        false
-    }
-    /// 从 mutex 的锁中释放一个线程，并将其阻塞在条件变量的等待队列中，等待其他线程运行完毕，当前的线程再试图获取这个锁
-    ///
-    /// 注意：下面是简化版的实现，在 mutex 唤醒一个线程之后，当前线程就直接获取这个 mutex，不管能不能获取成功
-    /// 这里是单纯为了过测例，
-    pub fn wait_with_mutex(
-        &self,
-        tid: ThreadId,
-        mutex: Arc<dyn Mutex>,
-    ) -> (bool, Option<ThreadId>) {
-        let waking_tid = mutex.unlock().unwrap();
-        (mutex.lock(tid), Some(waking_tid))
-    }
-}
diff --git a/sync/src/lib.rs b/sync/src/lib.rs
deleted file mode 100644
index 6938d96..0000000
--- a/sync/src/lib.rs
+++ /dev/null
@@ -1,16 +0,0 @@
-//! 同步互斥模块
-
-#![no_std]
-#![deny(warnings, missing_docs)]
-
-mod condvar;
-mod mutex;
-mod semaphore;
-mod up;
-
-extern crate alloc;
-
-pub use condvar::Condvar;
-pub use mutex::{Mutex, MutexBlocking};
-pub use semaphore::Semaphore;
-pub use up::{UPIntrFreeCell, UPIntrRefMut};
diff --git a/sync/src/mutex.rs b/sync/src/mutex.rs
deleted file mode 100644
index 6dd74c9..0000000
--- a/sync/src/mutex.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use super::UPIntrFreeCell;
-use alloc::collections::VecDeque;
-use rcore_task_manage::ThreadId;
-
-/// Mutex trait
-pub trait Mutex: Sync + Send {
-    /// tid 表示的线程试图获取锁，并返回结果
-    fn lock(&self, tid: ThreadId) -> bool;
-    /// 当前线程释放锁，并唤醒某个阻塞在这个锁上的线程
-    fn unlock(&self) -> Option<ThreadId>;
-}
-
-/// MutexBlocking
-pub struct MutexBlocking {
-    inner: UPIntrFreeCell<MutexBlockingInner>,
-}
-
-/// MutexBlockingInner
-pub struct MutexBlockingInner {
-    locked: bool,
-    wait_queue: VecDeque<ThreadId>,
-}
-
-impl MutexBlocking {
-    /// new
-    pub fn new() -> Self {
-        Self {
-            inner: unsafe {
-                UPIntrFreeCell::new(MutexBlockingInner {
-                    locked: false,
-                    wait_queue: VecDeque::new(),
-                })
-            },
-        }
-    }
-}
-
-impl Mutex for MutexBlocking {
-    // 获取锁，如果获取成功，返回 true，否则会返回 false，要求阻塞对应的线程
-    fn lock(&self, tid: ThreadId) -> bool {
-        let mut mutex_inner = self.inner.exclusive_access();
-        if mutex_inner.locked {
-            mutex_inner.wait_queue.push_back(tid);
-            drop(mutex_inner);
-            false
-        } else {
-            mutex_inner.locked = true;
-            true
-        }
-    }
-    // 释放锁，释放之后会唤醒一个被阻塞的进程，要求重新进入调度队列
-    fn unlock(&self) -> Option<ThreadId> {
-        let mut mutex_inner = self.inner.exclusive_access();
-        assert!(mutex_inner.locked);
-        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
-            Some(waking_task)
-        } else {
-            mutex_inner.locked = false;
-            None
-        }
-    }
-}
diff --git a/sync/src/semaphore.rs b/sync/src/semaphore.rs
deleted file mode 100644
index 7e81d25..0000000
--- a/sync/src/semaphore.rs
+++ /dev/null
@@ -1,47 +0,0 @@
-use super::UPIntrFreeCell;
-use alloc::collections::VecDeque;
-use rcore_task_manage::ThreadId;
-
-/// Semaphore
-pub struct Semaphore {
-    /// UPIntrFreeCell<SemaphoreInner>
-    pub inner: UPIntrFreeCell<SemaphoreInner>,
-}
-
-/// SemaphoreInner
-pub struct SemaphoreInner {
-    pub count: isize,
-    pub wait_queue: VecDeque<ThreadId>,
-}
-
-impl Semaphore {
-    /// new
-    pub fn new(res_count: usize) -> Self {
-        Self {
-            inner: unsafe {
-                UPIntrFreeCell::new(SemaphoreInner {
-                    count: res_count as isize,
-                    wait_queue: VecDeque::new(),
-                })
-            },
-        }
-    }
-    /// 当前线程释放信号量表示的一个资源，并唤醒一个阻塞的线程
-    pub fn up(&self) -> Option<ThreadId> {
-        let mut inner = self.inner.exclusive_access();
-        inner.count += 1;
-        inner.wait_queue.pop_front()
-    }
-    /// 当前线程试图获取信号量表示的资源，并返回结果
-    pub fn down(&self, tid: ThreadId) -> bool {
-        let mut inner = self.inner.exclusive_access();
-        inner.count -= 1;
-        if inner.count < 0 {
-            inner.wait_queue.push_back(tid);
-            drop(inner);
-            false
-        } else {
-            true
-        }
-    }
-}
diff --git a/sync/src/up.rs b/sync/src/up.rs
deleted file mode 100644
index b75892c..0000000
--- a/sync/src/up.rs
+++ /dev/null
@@ -1,141 +0,0 @@
-use core::cell::{RefCell, RefMut, UnsafeCell};
-use core::ops::{Deref, DerefMut};
-use riscv::register::sstatus;
-use spin::Lazy;
-
-/*
-/// Wrap a static data structure inside it so that we are
-/// able to access it without any `unsafe`.
-///
-/// We should only use it in uniprocessor.
-///
-/// In order to get mutable reference of inner data, call
-/// `exclusive_access`.
-pub struct UPSafeCell<T> {
-    /// inner data
-    inner: RefCell<T>,
-}
-unsafe impl<T> Sync for UPSafeCell<T> {}
-impl<T> UPSafeCell<T> {
-    /// User is responsible to guarantee that inner struct is only used in
-    /// uniprocessor.
-    pub unsafe fn new(value: T) -> Self {
-        Self {
-            inner: RefCell::new(value),
-        }
-    }
-    /// Panic if the data has been borrowed.
-    pub fn exclusive_access(&self) -> RefMut<'_, T> {
-        self.inner.borrow_mut()
-    }
-}
-*/
-
-/// interior mutability
-pub struct UPSafeCellRaw<T> {
-    inner: UnsafeCell<T>,
-}
-
-unsafe impl<T> Sync for UPSafeCellRaw<T> {}
-
-impl<T> UPSafeCellRaw<T> {
-    pub unsafe fn new(value: T) -> Self {
-        Self {
-            inner: UnsafeCell::new(value),
-        }
-    }
-    pub fn get_mut(&self) -> &mut T {
-        unsafe { &mut (*self.inner.get()) }
-    }
-}
-
-/// 中断屏蔽信息
-pub struct IntrMaskingInfo {
-    nested_level: usize,
-    sie_before_masking: bool,
-}
-
-pub static INTR_MASKING_INFO: Lazy<UPSafeCellRaw<IntrMaskingInfo>> =
-    Lazy::new(|| unsafe { UPSafeCellRaw::new(IntrMaskingInfo::new()) });
-
-impl IntrMaskingInfo {
-    pub fn new() -> Self {
-        Self {
-            nested_level: 0,
-            sie_before_masking: false,
-        }
-    }
-
-    pub fn enter(&mut self) {
-        let sie = sstatus::read().sie();
-        unsafe {
-            sstatus::clear_sie();
-        }
-        if self.nested_level == 0 {
-            self.sie_before_masking = sie;
-        }
-        self.nested_level += 1;
-    }
-
-    pub fn exit(&mut self) {
-        self.nested_level -= 1;
-        if self.nested_level == 0 && self.sie_before_masking {
-            unsafe {
-                sstatus::set_sie();
-            }
-        }
-    }
-}
-
-/// A mutable memory location with dynamically checked borrow rules
-pub struct UPIntrFreeCell<T> {
-    /// inner data
-    inner: RefCell<T>,
-}
-
-unsafe impl<T> Sync for UPIntrFreeCell<T> {}
-
-/// A wrapper type for a mutably borrowed value from a RefCell<T>
-pub struct UPIntrRefMut<'a, T>(Option<RefMut<'a, T>>);
-
-impl<T> UPIntrFreeCell<T> {
-    ///
-    pub unsafe fn new(value: T) -> Self {
-        Self {
-            inner: RefCell::new(value),
-        }
-    }
-
-    /// Panic if the data has been borrowed.
-    pub fn exclusive_access(&self) -> UPIntrRefMut<'_, T> {
-        INTR_MASKING_INFO.get_mut().enter();
-        UPIntrRefMut(Some(self.inner.borrow_mut()))
-    }
-    /// exclusive_session
-    pub fn exclusive_session<F, V>(&self, f: F) -> V
-    where
-        F: FnOnce(&mut T) -> V,
-    {
-        let mut inner = self.exclusive_access();
-        f(inner.deref_mut())
-    }
-}
-
-impl<'a, T> Drop for UPIntrRefMut<'a, T> {
-    fn drop(&mut self) {
-        self.0 = None;
-        INTR_MASKING_INFO.get_mut().exit();
-    }
-}
-
-impl<'a, T> Deref for UPIntrRefMut<'a, T> {
-    type Target = T;
-    fn deref(&self) -> &Self::Target {
-        self.0.as_ref().unwrap().deref()
-    }
-}
-impl<'a, T> DerefMut for UPIntrRefMut<'a, T> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        self.0.as_mut().unwrap().deref_mut()
-    }
-}
diff --git a/syscall/Cargo.toml b/syscall/Cargo.toml
deleted file mode 100644
index 7bae2f8..0000000
--- a/syscall/Cargo.toml
+++ /dev/null
@@ -1,15 +0,0 @@
-[package]
-name = "syscall"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-spin = "0.9.4"
-bitflags = "1.2.1"
-signal-defs = { path = "../signal-defs" }
-
-[features]
-kernel = []
-user = []
\ No newline at end of file
diff --git a/syscall/build.rs b/syscall/build.rs
deleted file mode 100644
index ce3a0d8..0000000
--- a/syscall/build.rs
+++ /dev/null
@@ -1,33 +0,0 @@
-fn main() {
-    use std::{
-        fs::{self, File},
-        io::Write,
-    };
-
-    const SYSCALL_H_IN: &str = "src/syscall.h.in";
-    println!("cargo:rerun-if-changed=build.rs");
-    println!("cargo:rerun-if-changed={SYSCALL_H_IN}");
-
-    let mut fout = File::create("src/syscalls.rs").unwrap();
-    writeln!(
-        fout,
-        "\
-//! Generated by build.rs. DO NOT EDIT.
-impl crate::SyscallId {{"
-    )
-    .unwrap();
-    fs::read_to_string(SYSCALL_H_IN)
-        .unwrap()
-        .lines()
-        .filter_map(|line| line.strip_prefix("#define __NR_"))
-        .filter_map(|line| line.split_once(' '))
-        .for_each(|(name, num)| {
-            writeln!(
-                fout,
-                "    pub const {name}: Self = Self({num});",
-                name = name.to_uppercase()
-            )
-            .unwrap();
-        });
-    writeln!(fout, "}}").unwrap();
-}
diff --git a/syscall/src/io.rs b/syscall/src/io.rs
deleted file mode 100644
index b47db88..0000000
--- a/syscall/src/io.rs
+++ /dev/null
@@ -1,3 +0,0 @@
-pub const STDIN: usize = 0;
-pub const STDOUT: usize = 1;
-pub const STDDEBUG: usize = 2;
diff --git a/syscall/src/kernel.rs b/syscall/src/kernel.rs
deleted file mode 100644
index b62f140..0000000
--- a/syscall/src/kernel.rs
+++ /dev/null
@@ -1,277 +0,0 @@
-#![allow(unused_variables)]
-
-use crate::{ClockId, SyscallId};
-use spin::Once;
-
-/// 系统调用的发起者信息。
-///
-/// 没有办法（也没有必要？）调整发起者的描述，只好先用两个 `usize` 了。
-/// 至少在一个类 Linux 的宏内核系统这是够用的。
-pub struct Caller {
-    /// 发起者拥有的资源集的标记，相当于进程号。
-    pub entity: usize,
-    /// 发起者的控制流的标记，相当于线程号。
-    pub flow: usize,
-}
-
-pub trait Process: Sync {
-    fn exit(&self, caller: Caller, status: usize) -> isize {
-        unimplemented!()
-    }
-    fn fork(&self, caller: Caller) -> isize {
-        unimplemented!()
-    }
-    fn exec(&self, caller: Caller, path: usize, count: usize) -> isize {
-        unimplemented!()
-    }
-    fn wait(&self, caller: Caller, pid: isize, exit_code_ptr: usize) -> isize {
-        unimplemented!()
-    }
-    fn getpid(&self, caller: Caller) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait IO: Sync {
-    fn read(&self, caller: Caller, fd: usize, buf: usize, count: usize) -> isize {
-        unimplemented!()
-    }
-    fn write(&self, caller: Caller, fd: usize, buf: usize, count: usize) -> isize {
-        unimplemented!()
-    }
-    fn open(&self, caller: Caller, path: usize, flags: usize) -> isize {
-        unimplemented!()
-    }
-    fn close(&self, caller: Caller, fd: usize) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait Memory: Sync {
-    fn mmap(
-        &self,
-        caller: Caller,
-        addr: usize,
-        length: usize,
-        prot: i32,
-        flags: i32,
-        fd: i32,
-        offset: usize,
-    ) -> isize {
-        unimplemented!()
-    }
-
-    fn munmap(&self, caller: Caller, addr: usize, length: usize) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait Scheduling: Sync {
-    fn sched_yield(&self, caller: Caller) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait Clock: Sync {
-    fn clock_gettime(&self, caller: Caller, clock_id: ClockId, tp: usize) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait Signal: Sync {
-    fn kill(&self, caller: Caller, pid: isize, signum: u8) -> isize {
-        unimplemented!()
-    }
-
-    fn sigaction(&self, caller: Caller, signum: u8, action: usize, old_action: usize) -> isize {
-        unimplemented!()
-    }
-
-    fn sigprocmask(&self, caller: Caller, mask: usize) -> isize {
-        unimplemented!()
-    }
-
-    fn sigreturn(&self, caller: Caller) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait Thread: Sync {
-    fn thread_create(&self, caller: Caller, entry: usize, arg: usize) -> isize {
-        unimplemented!()
-    }
-    fn waittid(&self, caller: Caller, tid: usize) -> isize {
-        unimplemented!()
-    }
-    fn gettid(&self, caller: Caller) -> isize {
-        unimplemented!()
-    }
-}
-
-pub trait SyncMutex: Sync {
-    fn semaphore_create(&self, caller: Caller, res_count: usize) -> isize {
-        unimplemented!()
-    }
-    fn semaphore_up(&self, caller: Caller, sem_id: usize) -> isize {
-        unimplemented!()
-    }
-    fn semaphore_down(&self, caller: Caller, sem_id: usize) -> isize {
-        unimplemented!()
-    }
-    fn mutex_create(&self, caller: Caller, blocking: bool) -> isize {
-        unimplemented!()
-    }
-    fn mutex_lock(&self, caller: Caller, mutex_id: usize) -> isize {
-        unimplemented!()
-    }
-    fn mutex_unlock(&self, caller: Caller, mutex_id: usize) -> isize {
-        unimplemented!()
-    }
-    fn condvar_create(&self, caller: Caller, arg: usize) -> isize {
-        unimplemented!()
-    }
-    fn condvar_signal(&self, caller: Caller, condvar_id: usize) -> isize {
-        unimplemented!()
-    }
-    fn condvar_wait(&self, caller: Caller, condvar_id: usize, mutex_id: usize) -> isize {
-        unimplemented!()
-    }
-}
-
-static PROCESS: Container<dyn Process> = Container::new();
-static IO: Container<dyn IO> = Container::new();
-static MEMORY: Container<dyn Memory> = Container::new();
-static SCHEDULING: Container<dyn Scheduling> = Container::new();
-static CLOCK: Container<dyn Clock> = Container::new();
-static SIGNAL: Container<dyn Signal> = Container::new();
-static THREAD: Container<dyn Thread> = Container::new();
-static SYNC_MUTEX: Container<dyn SyncMutex> = Container::new();
-
-#[inline]
-pub fn init_process(process: &'static dyn Process) {
-    PROCESS.init(process);
-}
-
-#[inline]
-pub fn init_io(io: &'static dyn IO) {
-    IO.init(io);
-}
-
-#[inline]
-pub fn init_memory(memory: &'static dyn Memory) {
-    MEMORY.init(memory);
-}
-
-#[inline]
-pub fn init_scheduling(scheduling: &'static dyn Scheduling) {
-    SCHEDULING.init(scheduling);
-}
-
-#[inline]
-pub fn init_clock(clock: &'static dyn Clock) {
-    CLOCK.init(clock);
-}
-
-#[inline]
-pub fn init_signal(signal: &'static dyn Signal) {
-    SIGNAL.init(signal);
-}
-
-#[inline]
-pub fn init_thread(thread: &'static dyn Thread) {
-    THREAD.init(thread);
-}
-
-#[inline]
-pub fn init_sync_mutex(sync_mutex: &'static dyn SyncMutex) {
-    SYNC_MUTEX.init(sync_mutex);
-}
-
-pub enum SyscallResult {
-    Done(isize),
-    Unsupported(SyscallId),
-}
-
-pub fn handle(caller: Caller, id: SyscallId, args: [usize; 6]) -> SyscallResult {
-    use SyscallId as Id;
-    match id {
-        Id::WRITE => IO.call(id, |io| io.write(caller, args[0], args[1], args[2])),
-        Id::READ => IO.call(id, |io| io.read(caller, args[0], args[1], args[2])),
-        Id::OPENAT => IO.call(id, |io| io.open(caller, args[0], args[1])),
-        Id::CLOSE => IO.call(id, |io| io.close(caller, args[0])),
-        Id::EXIT => PROCESS.call(id, |proc| proc.exit(caller, args[0])),
-        Id::CLONE => PROCESS.call(id, |proc| proc.fork(caller)),
-        Id::EXECVE => PROCESS.call(id, |proc| proc.exec(caller, args[0], args[1])),
-        Id::WAIT4 => PROCESS.call(id, |proc| proc.wait(caller, args[0] as _, args[1])),
-        Id::GETPID => PROCESS.call(id, |proc| proc.getpid(caller)),
-        Id::CLOCK_GETTIME => CLOCK.call(id, |clock| {
-            clock.clock_gettime(caller, ClockId(args[0]), args[1])
-        }),
-        Id::SCHED_YIELD => SCHEDULING.call(id, |sched| sched.sched_yield(caller)),
-        Id::MUNMAP => MEMORY.call(id, |memory| memory.munmap(caller, args[0], args[1])),
-        Id::MMAP => MEMORY.call(id, |memory| {
-            let [addr, length, prot, flags, fd, offset] = args;
-            memory.mmap(caller, addr, length, prot as _, flags as _, fd as _, offset)
-        }),
-        Id::KILL => SIGNAL.call(id, |signal| signal.kill(caller, args[0] as _, args[1] as _)),
-        Id::RT_SIGACTION => SIGNAL.call(id, |signal| {
-            signal.sigaction(caller, args[0] as _, args[1], args[2])
-        }),
-        Id::RT_SIGPROCMASK => SIGNAL.call(id, |signal| signal.sigprocmask(caller, args[0])),
-        Id::RT_SIGRETURN => SIGNAL.call(id, |signal| signal.sigreturn(caller)),
-        Id::WAITID => THREAD.call(id, |thread| thread.waittid(caller, args[0])),
-        Id::GETTID => THREAD.call(id, |thread| thread.gettid(caller)),
-        Id::THREAD_CREATE => {
-            THREAD.call(id, |thread| thread.thread_create(caller, args[0], args[1]))
-        }
-        Id::SEMAPHORE_CREATE => SYNC_MUTEX.call(id, |sync_mutex| {
-            sync_mutex.semaphore_create(caller, args[0])
-        }),
-        Id::SEMAPHORE_UP => {
-            SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.semaphore_up(caller, args[0]))
-        }
-        Id::SEMAPHORE_DOWN => {
-            SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.semaphore_down(caller, args[0]))
-        }
-        Id::MUTEX_CREATE => SYNC_MUTEX.call(id, |sync_mutex| {
-            sync_mutex.mutex_create(caller, args[0] != 0)
-        }),
-        Id::MUTEX_LOCK => SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.mutex_lock(caller, args[0])),
-        Id::MUTEX_UNLOCK => {
-            SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.mutex_unlock(caller, args[0]))
-        }
-        Id::CONDVAR_CREATE => {
-            SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.condvar_create(caller, args[0]))
-        }
-        Id::CONDVAR_SIGNAL => {
-            SYNC_MUTEX.call(id, |sync_mutex| sync_mutex.condvar_signal(caller, args[0]))
-        }
-        Id::CONDVAR_WAIT => SYNC_MUTEX.call(id, |sync_mutex| {
-            sync_mutex.condvar_wait(caller, args[0], args[1])
-        }),
-        _ => SyscallResult::Unsupported(id),
-    }
-}
-
-struct Container<T: 'static + ?Sized>(spin::Once<&'static T>);
-
-impl<T: 'static + ?Sized> Container<T> {
-    #[inline]
-    const fn new() -> Self {
-        Self(Once::new())
-    }
-
-    #[inline]
-    fn init(&self, val: &'static T) {
-        self.0.call_once(|| val);
-    }
-
-    #[inline]
-    fn call(&self, id: SyscallId, f: impl FnOnce(&T) -> isize) -> SyscallResult {
-        self.0
-            .get()
-            .map_or(SyscallResult::Unsupported(id), |clock| {
-                SyscallResult::Done(f(clock))
-            })
-    }
-}
diff --git a/syscall/src/lib.rs b/syscall/src/lib.rs
deleted file mode 100644
index 3e64027..0000000
--- a/syscall/src/lib.rs
+++ /dev/null
@@ -1,39 +0,0 @@
-#![no_std]
-#![deny(warnings)]
-
-#[cfg(all(feature = "kernel", feature = "user"))]
-compile_error!("You can only use one of `supervisor` or `user` features at a time");
-
-mod io;
-mod syscalls;
-mod time;
-
-pub use io::*;
-pub use signal_defs::{SignalAction, SignalNo, MAX_SIG};
-pub use time::*;
-
-#[cfg(feature = "user")]
-mod user;
-
-#[cfg(feature = "user")]
-pub use user::*;
-
-#[cfg(feature = "kernel")]
-mod kernel;
-
-#[cfg(feature = "kernel")]
-pub use kernel::*;
-
-/// 系统调用号。
-///
-/// 实现为包装类型，在不损失扩展性的情况下实现类型安全性。
-#[derive(PartialEq, Eq, Clone, Copy, Debug)]
-#[repr(transparent)]
-pub struct SyscallId(pub usize);
-
-impl From<usize> for SyscallId {
-    #[inline]
-    fn from(val: usize) -> Self {
-        Self(val)
-    }
-}
diff --git a/syscall/src/syscall.h.in b/syscall/src/syscall.h.in
deleted file mode 100644
index 8c3fccf..0000000
--- a/syscall/src/syscall.h.in
+++ /dev/null
@@ -1,322 +0,0 @@
-// Copied from <https://git.musl-libc.org/cgit/musl/tree/arch/riscv64/bits/syscall.h.in>.
-
-#define __NR_io_setup 0
-#define __NR_io_destroy 1
-#define __NR_io_submit 2
-#define __NR_io_cancel 3
-#define __NR_io_getevents 4
-#define __NR_setxattr 5
-#define __NR_lsetxattr 6
-#define __NR_fsetxattr 7
-#define __NR_getxattr 8
-#define __NR_lgetxattr 9
-#define __NR_fgetxattr 10
-#define __NR_listxattr 11
-#define __NR_llistxattr 12
-#define __NR_flistxattr 13
-#define __NR_removexattr 14
-#define __NR_lremovexattr 15
-#define __NR_fremovexattr 16
-#define __NR_getcwd 17
-#define __NR_lookup_dcookie 18
-#define __NR_eventfd2 19
-#define __NR_epoll_create1 20
-#define __NR_epoll_ctl 21
-#define __NR_epoll_pwait 22
-#define __NR_dup 23
-#define __NR_dup3 24
-#define __NR_fcntl 25
-#define __NR_inotify_init1 26
-#define __NR_inotify_add_watch 27
-#define __NR_inotify_rm_watch 28
-#define __NR_ioctl 29
-#define __NR_ioprio_set 30
-#define __NR_ioprio_get 31
-#define __NR_flock 32
-#define __NR_mknodat 33
-#define __NR_mkdirat 34
-#define __NR_unlinkat 35
-#define __NR_symlinkat 36
-#define __NR_linkat 37
-#define __NR_umount2 39
-#define __NR_mount 40
-#define __NR_pivot_root 41
-#define __NR_nfsservctl 42
-#define __NR_statfs 43
-#define __NR_fstatfs 44
-#define __NR_truncate 45
-#define __NR_ftruncate 46
-#define __NR_fallocate 47
-#define __NR_faccessat 48
-#define __NR_chdir 49
-#define __NR_fchdir 50
-#define __NR_chroot 51
-#define __NR_fchmod 52
-#define __NR_fchmodat 53
-#define __NR_fchownat 54
-#define __NR_fchown 55
-#define __NR_openat 56
-#define __NR_close 57
-#define __NR_vhangup 58
-#define __NR_pipe2 59
-#define __NR_quotactl 60
-#define __NR_getdents64 61
-#define __NR_lseek 62
-#define __NR_read 63
-#define __NR_write 64
-#define __NR_readv 65
-#define __NR_writev 66
-#define __NR_pread64 67
-#define __NR_pwrite64 68
-#define __NR_preadv 69
-#define __NR_pwritev 70
-#define __NR_sendfile 71
-#define __NR_pselect6 72
-#define __NR_ppoll 73
-#define __NR_signalfd4 74
-#define __NR_vmsplice 75
-#define __NR_splice 76
-#define __NR_tee 77
-#define __NR_readlinkat 78
-#define __NR_newfstatat 79
-#define __NR_fstat 80
-#define __NR_sync 81
-#define __NR_fsync 82
-#define __NR_fdatasync 83
-#define __NR_sync_file_range 84
-#define __NR_timerfd_create 85
-#define __NR_timerfd_settime 86
-#define __NR_timerfd_gettime 87
-#define __NR_utimensat 88
-#define __NR_acct 89
-#define __NR_capget 90
-#define __NR_capset 91
-#define __NR_personality 92
-#define __NR_exit 93
-#define __NR_exit_group 94
-#define __NR_waitid 95
-#define __NR_set_tid_address 96
-#define __NR_unshare 97
-#define __NR_futex 98
-#define __NR_set_robust_list 99
-#define __NR_get_robust_list 100
-#define __NR_nanosleep 101
-#define __NR_getitimer 102
-#define __NR_setitimer 103
-#define __NR_kexec_load 104
-#define __NR_init_module 105
-#define __NR_delete_module 106
-#define __NR_timer_create 107
-#define __NR_timer_gettime 108
-#define __NR_timer_getoverrun 109
-#define __NR_timer_settime 110
-#define __NR_timer_delete 111
-#define __NR_clock_settime 112
-#define __NR_clock_gettime 113
-#define __NR_clock_getres 114
-#define __NR_clock_nanosleep 115
-#define __NR_syslog 116
-#define __NR_ptrace 117
-#define __NR_sched_setparam 118
-#define __NR_sched_setscheduler 119
-#define __NR_sched_getscheduler 120
-#define __NR_sched_getparam 121
-#define __NR_sched_setaffinity 122
-#define __NR_sched_getaffinity 123
-#define __NR_sched_yield 124
-#define __NR_sched_get_priority_max 125
-#define __NR_sched_get_priority_min 126
-#define __NR_sched_rr_get_interval 127
-#define __NR_restart_syscall 128
-#define __NR_kill 129
-#define __NR_tkill 130
-#define __NR_tgkill 131
-#define __NR_sigaltstack 132
-#define __NR_rt_sigsuspend 133
-#define __NR_rt_sigaction 134
-#define __NR_rt_sigprocmask 135
-#define __NR_rt_sigpending 136
-#define __NR_rt_sigtimedwait 137
-#define __NR_rt_sigqueueinfo 138
-#define __NR_rt_sigreturn 139
-#define __NR_setpriority 140
-#define __NR_getpriority 141
-#define __NR_reboot 142
-#define __NR_setregid 143
-#define __NR_setgid 144
-#define __NR_setreuid 145
-#define __NR_setuid 146
-#define __NR_setresuid 147
-#define __NR_getresuid 148
-#define __NR_setresgid 149
-#define __NR_getresgid 150
-#define __NR_setfsuid 151
-#define __NR_setfsgid 152
-#define __NR_times 153
-#define __NR_setpgid 154
-#define __NR_getpgid 155
-#define __NR_getsid 156
-#define __NR_setsid 157
-#define __NR_getgroups 158
-#define __NR_setgroups 159
-#define __NR_uname 160
-#define __NR_sethostname 161
-#define __NR_setdomainname 162
-#define __NR_getrlimit 163
-#define __NR_setrlimit 164
-#define __NR_getrusage 165
-#define __NR_umask 166
-#define __NR_prctl 167
-#define __NR_getcpu 168
-#define __NR_gettimeofday 169
-#define __NR_settimeofday 170
-#define __NR_adjtimex 171
-#define __NR_getpid 172
-#define __NR_getppid 173
-#define __NR_getuid 174
-#define __NR_geteuid 175
-#define __NR_getgid 176
-#define __NR_getegid 177
-#define __NR_gettid 178
-#define __NR_sysinfo 179
-#define __NR_mq_open 180
-#define __NR_mq_unlink 181
-#define __NR_mq_timedsend 182
-#define __NR_mq_timedreceive 183
-#define __NR_mq_notify 184
-#define __NR_mq_getsetattr 185
-#define __NR_msgget 186
-#define __NR_msgctl 187
-#define __NR_msgrcv 188
-#define __NR_msgsnd 189
-#define __NR_semget 190
-#define __NR_semctl 191
-#define __NR_semtimedop 192
-#define __NR_semop 193
-#define __NR_shmget 194
-#define __NR_shmctl 195
-#define __NR_shmat 196
-#define __NR_shmdt 197
-#define __NR_socket 198
-#define __NR_socketpair 199
-#define __NR_bind 200
-#define __NR_listen 201
-#define __NR_accept 202
-#define __NR_connect 203
-#define __NR_getsockname 204
-#define __NR_getpeername 205
-#define __NR_sendto 206
-#define __NR_recvfrom 207
-#define __NR_setsockopt 208
-#define __NR_getsockopt 209
-#define __NR_shutdown 210
-#define __NR_sendmsg 211
-#define __NR_recvmsg 212
-#define __NR_readahead 213
-#define __NR_brk 214
-#define __NR_munmap 215
-#define __NR_mremap 216
-#define __NR_add_key 217
-#define __NR_request_key 218
-#define __NR_keyctl 219
-#define __NR_clone 220
-#define __NR_execve 221
-#define __NR_mmap 222
-#define __NR_fadvise64 223
-#define __NR_swapon 224
-#define __NR_swapoff 225
-#define __NR_mprotect 226
-#define __NR_msync 227
-#define __NR_mlock 228
-#define __NR_munlock 229
-#define __NR_mlockall 230
-#define __NR_munlockall 231
-#define __NR_mincore 232
-#define __NR_madvise 233
-#define __NR_remap_file_pages 234
-#define __NR_mbind 235
-#define __NR_get_mempolicy 236
-#define __NR_set_mempolicy 237
-#define __NR_migrate_pages 238
-#define __NR_move_pages 239
-#define __NR_rt_tgsigqueueinfo 240
-#define __NR_perf_event_open 241
-#define __NR_accept4 242
-#define __NR_recvmmsg 243
-#define __NR_arch_specific_syscall 244
-#define __NR_wait4 260
-#define __NR_prlimit64 261
-#define __NR_fanotify_init 262
-#define __NR_fanotify_mark 263
-#define __NR_name_to_handle_at 264
-#define __NR_open_by_handle_at 265
-#define __NR_clock_adjtime 266
-#define __NR_syncfs 267
-#define __NR_setns 268
-#define __NR_sendmmsg 269
-#define __NR_process_vm_readv 270
-#define __NR_process_vm_writev 271
-#define __NR_kcmp 272
-#define __NR_finit_module 273
-#define __NR_sched_setattr 274
-#define __NR_sched_getattr 275
-#define __NR_renameat2 276
-#define __NR_seccomp 277
-#define __NR_getrandom 278
-#define __NR_memfd_create 279
-#define __NR_bpf 280
-#define __NR_execveat 281
-#define __NR_userfaultfd 282
-#define __NR_membarrier 283
-#define __NR_mlock2 284
-#define __NR_copy_file_range 285
-#define __NR_preadv2 286
-#define __NR_pwritev2 287
-#define __NR_pkey_mprotect 288
-#define __NR_pkey_alloc 289
-#define __NR_pkey_free 290
-#define __NR_statx 291
-#define __NR_io_pgetevents 292
-#define __NR_rseq 293
-#define __NR_kexec_file_load 294
-#define __NR_pidfd_send_signal 424
-#define __NR_io_uring_setup 425
-#define __NR_io_uring_enter 426
-#define __NR_io_uring_register 427
-#define __NR_open_tree		428
-#define __NR_move_mount		429
-#define __NR_fsopen		430
-#define __NR_fsconfig		431
-#define __NR_fsmount		432
-#define __NR_fspick		433
-#define __NR_pidfd_open		434
-#define __NR_clone3		435
-#define __NR_close_range	436
-#define __NR_openat2		437
-#define __NR_pidfd_getfd	438
-#define __NR_faccessat2		439
-#define __NR_process_madvise	440
-#define __NR_epoll_pwait2	441
-#define __NR_mount_setattr	442
-#define __NR_landlock_create_ruleset	444
-#define __NR_landlock_add_rule	445
-#define __NR_landlock_restrict_self	446
-
-// 
-#define __NR_thread_create 1000
-//
-#define __NR_mutex_create 1010
-#define __NR_mutex_lock 1011
-#define __NR_mutex_unlock 1012
-//
-#define __NR_semaphore_create 1020
-#define __NR_semaphore_up 1021
-#define __NR_semaphore_down 1022
-//
-#define __NR_condvar_create 1030
-#define __NR_condvar_signal 1031
-#define __NR_condvar_wait 1032
-
-
-// #define __NR_sysriscv __NR_arch_specific_syscall
-// #define __NR_riscv_flush_icache (__NR_sysriscv + 15)
diff --git a/syscall/src/syscalls.rs b/syscall/src/syscalls.rs
deleted file mode 100644
index 61c2071..0000000
--- a/syscall/src/syscalls.rs
+++ /dev/null
@@ -1,296 +0,0 @@
-//! Generated by build.rs. DO NOT EDIT.
-impl crate::SyscallId {
-    pub const IO_SETUP: Self = Self(0);
-    pub const IO_DESTROY: Self = Self(1);
-    pub const IO_SUBMIT: Self = Self(2);
-    pub const IO_CANCEL: Self = Self(3);
-    pub const IO_GETEVENTS: Self = Self(4);
-    pub const SETXATTR: Self = Self(5);
-    pub const LSETXATTR: Self = Self(6);
-    pub const FSETXATTR: Self = Self(7);
-    pub const GETXATTR: Self = Self(8);
-    pub const LGETXATTR: Self = Self(9);
-    pub const FGETXATTR: Self = Self(10);
-    pub const LISTXATTR: Self = Self(11);
-    pub const LLISTXATTR: Self = Self(12);
-    pub const FLISTXATTR: Self = Self(13);
-    pub const REMOVEXATTR: Self = Self(14);
-    pub const LREMOVEXATTR: Self = Self(15);
-    pub const FREMOVEXATTR: Self = Self(16);
-    pub const GETCWD: Self = Self(17);
-    pub const LOOKUP_DCOOKIE: Self = Self(18);
-    pub const EVENTFD2: Self = Self(19);
-    pub const EPOLL_CREATE1: Self = Self(20);
-    pub const EPOLL_CTL: Self = Self(21);
-    pub const EPOLL_PWAIT: Self = Self(22);
-    pub const DUP: Self = Self(23);
-    pub const DUP3: Self = Self(24);
-    pub const FCNTL: Self = Self(25);
-    pub const INOTIFY_INIT1: Self = Self(26);
-    pub const INOTIFY_ADD_WATCH: Self = Self(27);
-    pub const INOTIFY_RM_WATCH: Self = Self(28);
-    pub const IOCTL: Self = Self(29);
-    pub const IOPRIO_SET: Self = Self(30);
-    pub const IOPRIO_GET: Self = Self(31);
-    pub const FLOCK: Self = Self(32);
-    pub const MKNODAT: Self = Self(33);
-    pub const MKDIRAT: Self = Self(34);
-    pub const UNLINKAT: Self = Self(35);
-    pub const SYMLINKAT: Self = Self(36);
-    pub const LINKAT: Self = Self(37);
-    pub const UMOUNT2: Self = Self(39);
-    pub const MOUNT: Self = Self(40);
-    pub const PIVOT_ROOT: Self = Self(41);
-    pub const NFSSERVCTL: Self = Self(42);
-    pub const STATFS: Self = Self(43);
-    pub const FSTATFS: Self = Self(44);
-    pub const TRUNCATE: Self = Self(45);
-    pub const FTRUNCATE: Self = Self(46);
-    pub const FALLOCATE: Self = Self(47);
-    pub const FACCESSAT: Self = Self(48);
-    pub const CHDIR: Self = Self(49);
-    pub const FCHDIR: Self = Self(50);
-    pub const CHROOT: Self = Self(51);
-    pub const FCHMOD: Self = Self(52);
-    pub const FCHMODAT: Self = Self(53);
-    pub const FCHOWNAT: Self = Self(54);
-    pub const FCHOWN: Self = Self(55);
-    pub const OPENAT: Self = Self(56);
-    pub const CLOSE: Self = Self(57);
-    pub const VHANGUP: Self = Self(58);
-    pub const PIPE2: Self = Self(59);
-    pub const QUOTACTL: Self = Self(60);
-    pub const GETDENTS64: Self = Self(61);
-    pub const LSEEK: Self = Self(62);
-    pub const READ: Self = Self(63);
-    pub const WRITE: Self = Self(64);
-    pub const READV: Self = Self(65);
-    pub const WRITEV: Self = Self(66);
-    pub const PREAD64: Self = Self(67);
-    pub const PWRITE64: Self = Self(68);
-    pub const PREADV: Self = Self(69);
-    pub const PWRITEV: Self = Self(70);
-    pub const SENDFILE: Self = Self(71);
-    pub const PSELECT6: Self = Self(72);
-    pub const PPOLL: Self = Self(73);
-    pub const SIGNALFD4: Self = Self(74);
-    pub const VMSPLICE: Self = Self(75);
-    pub const SPLICE: Self = Self(76);
-    pub const TEE: Self = Self(77);
-    pub const READLINKAT: Self = Self(78);
-    pub const NEWFSTATAT: Self = Self(79);
-    pub const FSTAT: Self = Self(80);
-    pub const SYNC: Self = Self(81);
-    pub const FSYNC: Self = Self(82);
-    pub const FDATASYNC: Self = Self(83);
-    pub const SYNC_FILE_RANGE: Self = Self(84);
-    pub const TIMERFD_CREATE: Self = Self(85);
-    pub const TIMERFD_SETTIME: Self = Self(86);
-    pub const TIMERFD_GETTIME: Self = Self(87);
-    pub const UTIMENSAT: Self = Self(88);
-    pub const ACCT: Self = Self(89);
-    pub const CAPGET: Self = Self(90);
-    pub const CAPSET: Self = Self(91);
-    pub const PERSONALITY: Self = Self(92);
-    pub const EXIT: Self = Self(93);
-    pub const EXIT_GROUP: Self = Self(94);
-    pub const WAITID: Self = Self(95);
-    pub const SET_TID_ADDRESS: Self = Self(96);
-    pub const UNSHARE: Self = Self(97);
-    pub const FUTEX: Self = Self(98);
-    pub const SET_ROBUST_LIST: Self = Self(99);
-    pub const GET_ROBUST_LIST: Self = Self(100);
-    pub const NANOSLEEP: Self = Self(101);
-    pub const GETITIMER: Self = Self(102);
-    pub const SETITIMER: Self = Self(103);
-    pub const KEXEC_LOAD: Self = Self(104);
-    pub const INIT_MODULE: Self = Self(105);
-    pub const DELETE_MODULE: Self = Self(106);
-    pub const TIMER_CREATE: Self = Self(107);
-    pub const TIMER_GETTIME: Self = Self(108);
-    pub const TIMER_GETOVERRUN: Self = Self(109);
-    pub const TIMER_SETTIME: Self = Self(110);
-    pub const TIMER_DELETE: Self = Self(111);
-    pub const CLOCK_SETTIME: Self = Self(112);
-    pub const CLOCK_GETTIME: Self = Self(113);
-    pub const CLOCK_GETRES: Self = Self(114);
-    pub const CLOCK_NANOSLEEP: Self = Self(115);
-    pub const SYSLOG: Self = Self(116);
-    pub const PTRACE: Self = Self(117);
-    pub const SCHED_SETPARAM: Self = Self(118);
-    pub const SCHED_SETSCHEDULER: Self = Self(119);
-    pub const SCHED_GETSCHEDULER: Self = Self(120);
-    pub const SCHED_GETPARAM: Self = Self(121);
-    pub const SCHED_SETAFFINITY: Self = Self(122);
-    pub const SCHED_GETAFFINITY: Self = Self(123);
-    pub const SCHED_YIELD: Self = Self(124);
-    pub const SCHED_GET_PRIORITY_MAX: Self = Self(125);
-    pub const SCHED_GET_PRIORITY_MIN: Self = Self(126);
-    pub const SCHED_RR_GET_INTERVAL: Self = Self(127);
-    pub const RESTART_SYSCALL: Self = Self(128);
-    pub const KILL: Self = Self(129);
-    pub const TKILL: Self = Self(130);
-    pub const TGKILL: Self = Self(131);
-    pub const SIGALTSTACK: Self = Self(132);
-    pub const RT_SIGSUSPEND: Self = Self(133);
-    pub const RT_SIGACTION: Self = Self(134);
-    pub const RT_SIGPROCMASK: Self = Self(135);
-    pub const RT_SIGPENDING: Self = Self(136);
-    pub const RT_SIGTIMEDWAIT: Self = Self(137);
-    pub const RT_SIGQUEUEINFO: Self = Self(138);
-    pub const RT_SIGRETURN: Self = Self(139);
-    pub const SETPRIORITY: Self = Self(140);
-    pub const GETPRIORITY: Self = Self(141);
-    pub const REBOOT: Self = Self(142);
-    pub const SETREGID: Self = Self(143);
-    pub const SETGID: Self = Self(144);
-    pub const SETREUID: Self = Self(145);
-    pub const SETUID: Self = Self(146);
-    pub const SETRESUID: Self = Self(147);
-    pub const GETRESUID: Self = Self(148);
-    pub const SETRESGID: Self = Self(149);
-    pub const GETRESGID: Self = Self(150);
-    pub const SETFSUID: Self = Self(151);
-    pub const SETFSGID: Self = Self(152);
-    pub const TIMES: Self = Self(153);
-    pub const SETPGID: Self = Self(154);
-    pub const GETPGID: Self = Self(155);
-    pub const GETSID: Self = Self(156);
-    pub const SETSID: Self = Self(157);
-    pub const GETGROUPS: Self = Self(158);
-    pub const SETGROUPS: Self = Self(159);
-    pub const UNAME: Self = Self(160);
-    pub const SETHOSTNAME: Self = Self(161);
-    pub const SETDOMAINNAME: Self = Self(162);
-    pub const GETRLIMIT: Self = Self(163);
-    pub const SETRLIMIT: Self = Self(164);
-    pub const GETRUSAGE: Self = Self(165);
-    pub const UMASK: Self = Self(166);
-    pub const PRCTL: Self = Self(167);
-    pub const GETCPU: Self = Self(168);
-    pub const GETTIMEOFDAY: Self = Self(169);
-    pub const SETTIMEOFDAY: Self = Self(170);
-    pub const ADJTIMEX: Self = Self(171);
-    pub const GETPID: Self = Self(172);
-    pub const GETPPID: Self = Self(173);
-    pub const GETUID: Self = Self(174);
-    pub const GETEUID: Self = Self(175);
-    pub const GETGID: Self = Self(176);
-    pub const GETEGID: Self = Self(177);
-    pub const GETTID: Self = Self(178);
-    pub const SYSINFO: Self = Self(179);
-    pub const MQ_OPEN: Self = Self(180);
-    pub const MQ_UNLINK: Self = Self(181);
-    pub const MQ_TIMEDSEND: Self = Self(182);
-    pub const MQ_TIMEDRECEIVE: Self = Self(183);
-    pub const MQ_NOTIFY: Self = Self(184);
-    pub const MQ_GETSETATTR: Self = Self(185);
-    pub const MSGGET: Self = Self(186);
-    pub const MSGCTL: Self = Self(187);
-    pub const MSGRCV: Self = Self(188);
-    pub const MSGSND: Self = Self(189);
-    pub const SEMGET: Self = Self(190);
-    pub const SEMCTL: Self = Self(191);
-    pub const SEMTIMEDOP: Self = Self(192);
-    pub const SEMOP: Self = Self(193);
-    pub const SHMGET: Self = Self(194);
-    pub const SHMCTL: Self = Self(195);
-    pub const SHMAT: Self = Self(196);
-    pub const SHMDT: Self = Self(197);
-    pub const SOCKET: Self = Self(198);
-    pub const SOCKETPAIR: Self = Self(199);
-    pub const BIND: Self = Self(200);
-    pub const LISTEN: Self = Self(201);
-    pub const ACCEPT: Self = Self(202);
-    pub const CONNECT: Self = Self(203);
-    pub const GETSOCKNAME: Self = Self(204);
-    pub const GETPEERNAME: Self = Self(205);
-    pub const SENDTO: Self = Self(206);
-    pub const RECVFROM: Self = Self(207);
-    pub const SETSOCKOPT: Self = Self(208);
-    pub const GETSOCKOPT: Self = Self(209);
-    pub const SHUTDOWN: Self = Self(210);
-    pub const SENDMSG: Self = Self(211);
-    pub const RECVMSG: Self = Self(212);
-    pub const READAHEAD: Self = Self(213);
-    pub const BRK: Self = Self(214);
-    pub const MUNMAP: Self = Self(215);
-    pub const MREMAP: Self = Self(216);
-    pub const ADD_KEY: Self = Self(217);
-    pub const REQUEST_KEY: Self = Self(218);
-    pub const KEYCTL: Self = Self(219);
-    pub const CLONE: Self = Self(220);
-    pub const EXECVE: Self = Self(221);
-    pub const MMAP: Self = Self(222);
-    pub const FADVISE64: Self = Self(223);
-    pub const SWAPON: Self = Self(224);
-    pub const SWAPOFF: Self = Self(225);
-    pub const MPROTECT: Self = Self(226);
-    pub const MSYNC: Self = Self(227);
-    pub const MLOCK: Self = Self(228);
-    pub const MUNLOCK: Self = Self(229);
-    pub const MLOCKALL: Self = Self(230);
-    pub const MUNLOCKALL: Self = Self(231);
-    pub const MINCORE: Self = Self(232);
-    pub const MADVISE: Self = Self(233);
-    pub const REMAP_FILE_PAGES: Self = Self(234);
-    pub const MBIND: Self = Self(235);
-    pub const GET_MEMPOLICY: Self = Self(236);
-    pub const SET_MEMPOLICY: Self = Self(237);
-    pub const MIGRATE_PAGES: Self = Self(238);
-    pub const MOVE_PAGES: Self = Self(239);
-    pub const RT_TGSIGQUEUEINFO: Self = Self(240);
-    pub const PERF_EVENT_OPEN: Self = Self(241);
-    pub const ACCEPT4: Self = Self(242);
-    pub const RECVMMSG: Self = Self(243);
-    pub const ARCH_SPECIFIC_SYSCALL: Self = Self(244);
-    pub const WAIT4: Self = Self(260);
-    pub const PRLIMIT64: Self = Self(261);
-    pub const FANOTIFY_INIT: Self = Self(262);
-    pub const FANOTIFY_MARK: Self = Self(263);
-    pub const NAME_TO_HANDLE_AT: Self = Self(264);
-    pub const OPEN_BY_HANDLE_AT: Self = Self(265);
-    pub const CLOCK_ADJTIME: Self = Self(266);
-    pub const SYNCFS: Self = Self(267);
-    pub const SETNS: Self = Self(268);
-    pub const SENDMMSG: Self = Self(269);
-    pub const PROCESS_VM_READV: Self = Self(270);
-    pub const PROCESS_VM_WRITEV: Self = Self(271);
-    pub const KCMP: Self = Self(272);
-    pub const FINIT_MODULE: Self = Self(273);
-    pub const SCHED_SETATTR: Self = Self(274);
-    pub const SCHED_GETATTR: Self = Self(275);
-    pub const RENAMEAT2: Self = Self(276);
-    pub const SECCOMP: Self = Self(277);
-    pub const GETRANDOM: Self = Self(278);
-    pub const MEMFD_CREATE: Self = Self(279);
-    pub const BPF: Self = Self(280);
-    pub const EXECVEAT: Self = Self(281);
-    pub const USERFAULTFD: Self = Self(282);
-    pub const MEMBARRIER: Self = Self(283);
-    pub const MLOCK2: Self = Self(284);
-    pub const COPY_FILE_RANGE: Self = Self(285);
-    pub const PREADV2: Self = Self(286);
-    pub const PWRITEV2: Self = Self(287);
-    pub const PKEY_MPROTECT: Self = Self(288);
-    pub const PKEY_ALLOC: Self = Self(289);
-    pub const PKEY_FREE: Self = Self(290);
-    pub const STATX: Self = Self(291);
-    pub const IO_PGETEVENTS: Self = Self(292);
-    pub const RSEQ: Self = Self(293);
-    pub const KEXEC_FILE_LOAD: Self = Self(294);
-    pub const PIDFD_SEND_SIGNAL: Self = Self(424);
-    pub const IO_URING_SETUP: Self = Self(425);
-    pub const IO_URING_ENTER: Self = Self(426);
-    pub const IO_URING_REGISTER: Self = Self(427);
-    pub const THREAD_CREATE: Self = Self(1000);
-    pub const MUTEX_CREATE: Self = Self(1010);
-    pub const MUTEX_LOCK: Self = Self(1011);
-    pub const MUTEX_UNLOCK: Self = Self(1012);
-    pub const SEMAPHORE_CREATE: Self = Self(1020);
-    pub const SEMAPHORE_UP: Self = Self(1021);
-    pub const SEMAPHORE_DOWN: Self = Self(1022);
-    pub const CONDVAR_CREATE: Self = Self(1030);
-    pub const CONDVAR_SIGNAL: Self = Self(1031);
-    pub const CONDVAR_WAIT: Self = Self(1032);
-}
diff --git a/syscall/src/time.rs b/syscall/src/time.rs
deleted file mode 100644
index 2fff03a..0000000
--- a/syscall/src/time.rs
+++ /dev/null
@@ -1,79 +0,0 @@
-//! see <https://github.com/torvalds/linux/blob/master/include/uapi/linux/time.h>.
-
-#[derive(Clone, Copy, PartialEq, Eq, Debug)]
-#[repr(transparent)]
-pub struct ClockId(pub usize);
-
-impl ClockId {
-    pub const CLOCK_REALTIME: Self = Self(0);
-    pub const CLOCK_MONOTONIC: Self = Self(1);
-    pub const CLOCK_PROCESS_CPUTIME_ID: Self = Self(2);
-    pub const CLOCK_THREAD_CPUTIME_ID: Self = Self(3);
-    pub const CLOCK_MONOTONIC_RAW: Self = Self(4);
-    pub const CLOCK_REALTIME_COARSE: Self = Self(5);
-    pub const CLOCK_MONOTONIC_COARSE: Self = Self(6);
-    pub const CLOCK_BOOTTIME: Self = Self(7);
-    pub const CLOCK_REALTIME_ALARM: Self = Self(8);
-    pub const CLOCK_BOOTTIME_ALARM: Self = Self(9);
-    pub const CLOCK_SGI_CYCLE: Self = Self(10);
-    pub const CLOCK_TAI: Self = Self(11);
-}
-
-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug)]
-#[repr(C)]
-pub struct TimeSpec {
-    // seconds
-    pub tv_sec: usize,
-    // nanoseconds
-    pub tv_nsec: usize,
-}
-
-impl TimeSpec {
-    pub const ZERO: Self = Self {
-        tv_sec: 0,
-        tv_nsec: 0,
-    };
-    pub const SECOND: Self = Self {
-        tv_sec: 1,
-        tv_nsec: 0,
-    };
-    pub const MILLSECOND: Self = Self {
-        tv_sec: 0,
-        tv_nsec: 1_000_000,
-    };
-    pub const MICROSECOND: Self = Self {
-        tv_sec: 0,
-        tv_nsec: 1_000,
-    };
-    pub const NANOSECOND: Self = Self {
-        tv_sec: 0,
-        tv_nsec: 1,
-    };
-    pub fn from_millsecond(millsecond: usize) -> Self {
-        Self {
-            tv_sec: millsecond / 1_000,
-            tv_nsec: millsecond % 1_000 * 1_000_000,
-        }
-    }
-}
-
-impl core::ops::Add<TimeSpec> for TimeSpec {
-    type Output = Self;
-    fn add(self, rhs: Self) -> Self::Output {
-        let mut ans = Self {
-            tv_sec: self.tv_sec + rhs.tv_sec,
-            tv_nsec: self.tv_nsec + rhs.tv_nsec,
-        };
-        if ans.tv_nsec > 1_000_000_000 {
-            ans.tv_sec += 1;
-            ans.tv_nsec -= 1_000_000_000;
-        }
-        ans
-    }
-}
-
-impl core::fmt::Display for TimeSpec {
-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
-        write!(f, "TimeSpec({}.{:09})", self.tv_sec, self.tv_nsec)
-    }
-}
diff --git a/syscall/src/user.rs b/syscall/src/user.rs
deleted file mode 100644
index 81eba1f..0000000
--- a/syscall/src/user.rs
+++ /dev/null
@@ -1,296 +0,0 @@
-use crate::{ClockId, SignalAction, SignalNo, SyscallId, TimeSpec};
-use bitflags::*;
-use native::*;
-
-/// see <https://man7.org/linux/man-pages/man2/write.2.html>.
-#[inline]
-pub fn write(fd: usize, buffer: &[u8]) -> isize {
-    unsafe { syscall3(SyscallId::WRITE, fd, buffer.as_ptr() as _, buffer.len()) }
-}
-
-#[inline]
-pub fn read(fd: usize, buffer: &[u8]) -> isize {
-    unsafe { syscall3(SyscallId::READ, fd, buffer.as_ptr() as _, buffer.len()) }
-}
-
-bitflags! {
-    pub struct OpenFlags: u32 {
-        const RDONLY = 0;
-        const WRONLY = 1 << 0;
-        const RDWR = 1 << 1;
-        const CREATE = 1 << 9;
-        const TRUNC = 1 << 10;
-    }
-}
-
-#[inline]
-pub fn open(path: &str, flags: OpenFlags) -> isize {
-    unsafe {
-        syscall2(
-            SyscallId::OPENAT,
-            path.as_ptr() as usize,
-            flags.bits as usize,
-        )
-    }
-}
-
-#[inline]
-pub fn close(fd: usize) -> isize {
-    unsafe { syscall1(SyscallId::CLOSE, fd) }
-}
-
-/// see <https://man7.org/linux/man-pages/man2/exit.2.html>.
-#[inline]
-pub fn exit(exit_code: i32) -> isize {
-    unsafe { syscall1(SyscallId::EXIT, exit_code as _) }
-}
-
-/// see <https://man7.org/linux/man-pages/man2/sched_yield.2.html>.
-#[inline]
-pub fn sched_yield() -> isize {
-    unsafe { syscall0(SyscallId::SCHED_YIELD) }
-}
-
-/// see <https://man7.org/linux/man-pages/man2/clock_gettime.2.html>.
-#[inline]
-pub fn clock_gettime(clockid: ClockId, tp: *mut TimeSpec) -> isize {
-    unsafe { syscall2(SyscallId::CLOCK_GETTIME, clockid.0, tp as _) }
-}
-
-pub fn fork() -> isize {
-    unsafe { syscall0(SyscallId::CLONE) }
-}
-
-pub fn exec(path: &str) -> isize {
-    unsafe { syscall2(SyscallId::EXECVE, path.as_ptr() as usize, path.len()) }
-}
-
-pub fn wait(exit_code_ptr: *mut i32) -> isize {
-    loop {
-        match unsafe { syscall2(SyscallId::WAIT4, usize::MAX, exit_code_ptr as usize) } {
-            -2 => {
-                sched_yield();
-            }
-            exit_pid => return exit_pid,
-        }
-    }
-}
-
-pub fn waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize {
-    loop {
-        match unsafe { syscall2(SyscallId::WAIT4, pid as usize, exit_code_ptr as usize) } {
-            -2 => {
-                sched_yield();
-            }
-            exit_pid => return exit_pid,
-        }
-    }
-}
-
-pub fn getpid() -> isize {
-    unsafe { syscall0(SyscallId::GETPID) }
-}
-
-#[inline]
-pub fn kill(pid: isize, signum: SignalNo) -> isize {
-    unsafe { syscall2(SyscallId::KILL, pid as _, signum as _) }
-}
-
-#[inline]
-pub fn sigaction(
-    signum: SignalNo,
-    action: *const SignalAction,
-    old_action: *const SignalAction,
-) -> isize {
-    unsafe {
-        syscall3(
-            SyscallId::RT_SIGACTION,
-            signum as _,
-            action as _,
-            old_action as _,
-        )
-    }
-}
-
-#[inline]
-pub fn sigprocmask(mask: usize) -> isize {
-    unsafe { syscall1(SyscallId::RT_SIGPROCMASK, mask) }
-}
-
-#[inline]
-pub fn sigreturn() -> isize {
-    unsafe { syscall0(SyscallId::RT_SIGRETURN) }
-}
-
-#[inline]
-pub fn thread_create(entry: usize, arg: usize) -> isize {
-    unsafe { syscall2(SyscallId::THREAD_CREATE, entry, arg) }
-}
-
-#[inline]
-pub fn gettid() -> isize {
-    unsafe { syscall0(SyscallId::GETTID) }
-}
-
-#[inline]
-pub fn waittid(tid: usize) -> isize {
-    loop {
-        match unsafe { syscall1(SyscallId::WAITID, tid) } {
-            -2 => {
-                sched_yield();
-            }
-            exit_code => return exit_code,
-        }
-    }
-}
-
-#[inline]
-pub fn semaphore_create(res_count: usize) -> isize {
-    unsafe { syscall1(SyscallId::SEMAPHORE_CREATE, res_count) }
-}
-
-#[inline]
-pub fn semaphore_up(sem_id: usize) -> isize {
-    unsafe { syscall1(SyscallId::SEMAPHORE_UP, sem_id) }
-}
-
-#[inline]
-pub fn semaphore_down(sem_id: usize) -> isize {
-    unsafe { syscall1(SyscallId::SEMAPHORE_DOWN, sem_id) }
-}
-
-#[inline]
-pub fn mutex_create(blocking: bool) -> isize {
-    unsafe { syscall1(SyscallId::MUTEX_CREATE, blocking as _) }
-}
-
-#[inline]
-pub fn mutex_lock(mutex_id: usize) -> isize {
-    unsafe { syscall1(SyscallId::MUTEX_LOCK, mutex_id) }
-}
-
-#[inline]
-pub fn mutex_unlock(mutex_id: usize) -> isize {
-    unsafe { syscall1(SyscallId::MUTEX_UNLOCK, mutex_id) }
-}
-
-#[inline]
-pub fn condvar_create() -> isize {
-    unsafe { syscall1(SyscallId::CONDVAR_CREATE, 0) }
-}
-
-#[inline]
-pub fn condvar_signal(condvar_id: usize) -> isize {
-    unsafe { syscall1(SyscallId::CONDVAR_SIGNAL, condvar_id) }
-}
-
-#[inline]
-pub fn condvar_wait(condvar_id: usize, mutex_id: usize) -> isize {
-    unsafe { syscall2(SyscallId::CONDVAR_WAIT, condvar_id, mutex_id) }
-}
-
-/// 这个模块包含调用系统调用的最小封装，用户可以直接使用这些函数调用自定义的系统调用。
-pub mod native {
-    use crate::SyscallId;
-    use core::arch::asm;
-
-    #[inline(always)]
-    pub unsafe fn syscall0(id: SyscallId) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            out("a0") ret,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall1(id: SyscallId, a0: usize) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            inlateout("a0") a0 => ret,
-            in("a7") id.0,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall2(id: SyscallId, a0: usize, a1: usize) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            inlateout("a0") a0 => ret,
-            in("a1") a1,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall3(id: SyscallId, a0: usize, a1: usize, a2: usize) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            inlateout("a0") a0 => ret,
-            in("a1") a1,
-            in("a2") a2,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall4(id: SyscallId, a0: usize, a1: usize, a2: usize, a3: usize) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            inlateout("a0") a0 => ret,
-            in("a1") a1,
-            in("a2") a2,
-            in("a3") a3,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall5(
-        id: SyscallId,
-        a0: usize,
-        a1: usize,
-        a2: usize,
-        a3: usize,
-        a4: usize,
-    ) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            inlateout("a0") a0 => ret,
-            in("a1") a1,
-            in("a2") a2,
-            in("a3") a3,
-            in("a4") a4,
-        );
-        ret
-    }
-
-    #[inline(always)]
-    pub unsafe fn syscall6(
-        id: SyscallId,
-        a0: usize,
-        a1: usize,
-        a2: usize,
-        a3: usize,
-        a4: usize,
-        a5: usize,
-    ) -> isize {
-        let ret: isize;
-        asm!("ecall",
-            in("a7") id.0,
-            inlateout("a0") a0 => ret,
-            in("a1") a1,
-            in("a2") a2,
-            in("a3") a3,
-            in("a4") a4,
-            in("a5") a5,
-        );
-        ret
-    }
-}
diff --git a/task-manage/Cargo.toml b/task-manage/Cargo.toml
deleted file mode 100644
index 5ff15c8..0000000
--- a/task-manage/Cargo.toml
+++ /dev/null
@@ -1,12 +0,0 @@
-[package]
-name = "task-manage"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[features]
-proc = []
-thread = []
-
-[dependencies]
diff --git a/task-manage/src/id.rs b/task-manage/src/id.rs
deleted file mode 100644
index 4c9bbda..0000000
--- a/task-manage/src/id.rs
+++ /dev/null
@@ -1,67 +0,0 @@
-use core::sync::atomic::{AtomicUsize, Ordering};
-
-/// 进程 Id
-#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash, Ord, PartialOrd)]
-pub struct ProcId(usize);
-
-impl ProcId {
-    ///
-    pub fn new() -> Self {
-        // 任务编号计数器，任务编号自增
-        static PID_COUNTER: AtomicUsize = AtomicUsize::new(0);
-        let id = PID_COUNTER.fetch_add(1, Ordering::Relaxed);
-        Self(id)
-    }
-    ///
-    pub fn from_usize(v: usize) -> Self {
-        Self(v)
-    }
-    ///
-    pub fn get_usize(&self) -> usize {
-        self.0
-    }
-}
-
-/// 线程 Id
-#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash, Ord, PartialOrd)]
-pub struct ThreadId(usize);
-
-impl ThreadId {
-    ///
-    pub fn new() -> Self {
-        // 任务编号计数器，任务编号自增
-        static TID_COUNTER: AtomicUsize = AtomicUsize::new(0);
-        let id = TID_COUNTER.fetch_add(1, Ordering::Relaxed);
-        Self(id)
-    }
-    ///
-    pub fn from_usize(v: usize) -> Self {
-        Self(v)
-    }
-    ///
-    pub fn get_usize(&self) -> usize {
-        self.0
-    }
-}
-
-/// 协程 Id
-#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash, Ord, PartialOrd)]
-pub struct CoroId(usize);
-
-impl CoroId {
-    ///
-    pub fn new() -> Self {
-        // 任务编号计数器，任务编号自增
-        static CID_COUNTER: AtomicUsize = AtomicUsize::new(0);
-        let id = CID_COUNTER.fetch_add(1, Ordering::Relaxed);
-        Self(id)
-    }
-    ///
-    pub fn from_usize(v: usize) -> Self {
-        Self(v)
-    }
-    ///
-    pub fn get_usize(&self) -> usize {
-        self.0
-    }
-}
diff --git a/task-manage/src/lib.rs b/task-manage/src/lib.rs
deleted file mode 100644
index 5fbd9a2..0000000
--- a/task-manage/src/lib.rs
+++ /dev/null
@@ -1,33 +0,0 @@
-//! 任务管理 lib
-
-#![no_std]
-#![feature(doc_cfg)]
-#![deny(warnings, missing_docs)]
-
-extern crate alloc;
-
-mod id;
-mod manager;
-mod scheduler;
-
-pub use id::*;
-pub use manager::Manage;
-pub use scheduler::Schedule;
-
-#[cfg(feature = "proc")]
-mod proc_manage;
-#[cfg(feature = "proc")]
-mod proc_rel;
-#[cfg(feature = "proc")]
-pub use proc_manage::PManager;
-#[cfg(feature = "proc")]
-pub use proc_rel::ProcRel;
-
-#[cfg(feature = "thread")]
-mod proc_thread_rel;
-#[cfg(feature = "thread")]
-mod thread_manager;
-#[cfg(feature = "thread")]
-pub use proc_thread_rel::ProcThreadRel;
-#[cfg(feature = "thread")]
-pub use thread_manager::PThreadManager;
diff --git a/task-manage/src/manager.rs b/task-manage/src/manager.rs
deleted file mode 100644
index b93e02e..0000000
--- a/task-manage/src/manager.rs
+++ /dev/null
@@ -1,9 +0,0 @@
-/// Manager trait
-pub trait Manage<T, I: Copy + Ord> {
-    /// 插入 item
-    fn insert(&mut self, id: I, item: T);
-    /// 删除 item
-    fn delete(&mut self, id: I);
-    /// 获取 mut item
-    fn get_mut(&mut self, id: I) -> Option<&mut T>;
-}
diff --git a/task-manage/src/proc_manage.rs b/task-manage/src/proc_manage.rs
deleted file mode 100644
index cd4615e..0000000
--- a/task-manage/src/proc_manage.rs
+++ /dev/null
@@ -1,106 +0,0 @@
-use alloc::collections::BTreeMap;
-
-use super::id::ProcId;
-use super::manager::Manage;
-use super::scheduler::Schedule;
-use super::ProcRel;
-use core::marker::PhantomData;
-
-/// ProcManager 数据结构，只管理进程以及进程之间的父子关系
-/// P 表示进程
-#[cfg(feature = "proc")]
-#[doc(cfg(feature = "proc"))]
-pub struct PManager<P, MP: Manage<P, ProcId> + Schedule<ProcId>> {
-    // 进程之间父子关系
-    rel_map: BTreeMap<ProcId, ProcRel>,
-    // 进程对象管理和调度
-    manager: Option<MP>,
-    // 当前正在运行的进程 ID
-    current: Option<ProcId>,
-    phantom_data: PhantomData<P>,
-}
-
-impl<P, MP: Manage<P, ProcId> + Schedule<ProcId>> PManager<P, MP> {
-    /// 新建 PManager
-    pub const fn new() -> Self {
-        Self {
-            rel_map: BTreeMap::new(),
-            manager: None,
-            current: None,
-            phantom_data: PhantomData::<P>,
-        }
-    }
-    /// 找到下一个进程
-    pub fn find_next(&mut self) -> Option<&mut P> {
-        if let Some(id) = self.manager.as_mut().unwrap().fetch() {
-            if let Some(task) = self.manager.as_mut().unwrap().get_mut(id) {
-                self.current = Some(id);
-                Some(task)
-            } else {
-                None
-            }
-        } else {
-            None
-        }
-    }
-    /// 设置 manager
-    pub fn set_manager(&mut self, manager: MP) {
-        self.manager = Some(manager);
-    }
-    /// 阻塞当前进程
-    pub fn make_current_suspend(&mut self) {
-        let id = self.current.unwrap();
-        self.manager.as_mut().unwrap().add(id);
-        self.current = None;
-    }
-    /// 结束当前进程，只会删除进程的内容，以及与当前进程相关的关系
-    pub fn make_current_exited(&mut self, exit_code: isize) {
-        let id = self.current.unwrap();
-        self.manager.as_mut().unwrap().delete(id);
-        let current_rel = self.rel_map.remove(&id).unwrap();
-        let parent_pid = current_rel.parent;
-        let children = current_rel.children;
-        // 从父进程中删除当前进程
-        if let Some(parent_rel) = self.rel_map.get_mut(&parent_pid) {
-            parent_rel.del_child(id, exit_code);
-        }
-        // 把当前进程的所有子进程转移到 0 号进程
-        for i in children {
-            self.rel_map.get_mut(&i).unwrap().parent = ProcId::from_usize(0);
-            self.rel_map
-                .get_mut(&ProcId::from_usize(0))
-                .unwrap()
-                .add_child(i);
-        }
-        self.current = None;
-    }
-    /// 添加进程，需要指明创建的进程的父进程 Id
-    pub fn add(&mut self, id: ProcId, task: P, parent: ProcId) {
-        self.manager.as_mut().unwrap().insert(id, task);
-        self.manager.as_mut().unwrap().add(id);
-        if let Some(parent_relation) = self.rel_map.get_mut(&parent) {
-            parent_relation.add_child(id);
-        }
-        self.rel_map.insert(id, ProcRel::new(parent));
-    }
-    /// 当前进程
-    pub fn current(&mut self) -> Option<&mut P> {
-        let id = self.current.unwrap();
-        self.manager.as_mut().unwrap().get_mut(id)
-    }
-    /// 获取某个进程
-    #[inline]
-    pub fn get_task(&mut self, id: ProcId) -> Option<&mut P> {
-        self.manager.as_mut().unwrap().get_mut(id)
-    }
-    /// wait 系统调用，返回结束的子进程 id 和 exit_code，正在运行的子进程不返回 None，返回 (-2, -1)
-    pub fn wait(&mut self, child_pid: ProcId) -> Option<(ProcId, isize)> {
-        let id = self.current.unwrap();
-        let current_rel = self.rel_map.get_mut(&id).unwrap();
-        if child_pid.get_usize() == usize::MAX {
-            current_rel.wait_any_child()
-        } else {
-            current_rel.wait_child(child_pid)
-        }
-    }
-}
diff --git a/task-manage/src/proc_rel.rs b/task-manage/src/proc_rel.rs
deleted file mode 100644
index 05d5d7e..0000000
--- a/task-manage/src/proc_rel.rs
+++ /dev/null
@@ -1,78 +0,0 @@
-use super::id::ProcId;
-use alloc::vec::Vec;
-
-/// 进程之间的关系，通过进程的 Id 来查询这个关系
-#[cfg(feature = "proc")]
-#[doc(cfg(feature = "proc"))]
-pub struct ProcRel {
-    /// 父进程 Id
-    pub parent: ProcId,
-    /// 子进程列表
-    pub children: Vec<ProcId>,
-    /// 已经结束的进程
-    pub dead_children: Vec<(ProcId, isize)>,
-}
-
-impl ProcRel {
-    /// new/fork 创建进程时使用
-    pub fn new(parent_pid: ProcId) -> Self {
-        Self {
-            parent: parent_pid,
-            children: Vec::new(),
-            dead_children: Vec::new(),
-        }
-    }
-    /// 添加子进程 Id
-    pub fn add_child(&mut self, child_pid: ProcId) {
-        self.children.push(child_pid);
-    }
-    /// 子进程结束，子进程 Id 被移入到 dead_children 队列中，等待 wait 系统调用来处理
-    pub fn del_child(&mut self, child_pid: ProcId, exit_code: isize) {
-        let pair = self
-            .children
-            .iter()
-            .enumerate()
-            .find(|(_, &id)| id == child_pid);
-        if let Some((idx, _)) = pair {
-            let dead_child = self.children.remove(idx);
-            self.dead_children.push((dead_child, exit_code));
-        }
-    }
-    /// 等待任意一个结束的子进程，直接弹出 dead_children 队首，如果队列为空，则返回 -2
-    pub fn wait_any_child(&mut self) -> Option<(ProcId, isize)> {
-        if self.dead_children.is_empty() {
-            if self.children.is_empty() {
-                None
-            } else {
-                Some((ProcId::from_usize(-2 as _), -1))
-            }
-        } else {
-            self.dead_children.pop()
-        }
-    }
-    /// 等待特定的子进程
-    pub fn wait_child(&mut self, child_pid: ProcId) -> Option<(ProcId, isize)> {
-        let pair = self
-            .dead_children
-            .iter()
-            .enumerate()
-            .find(|(_, &(id, _))| id == child_pid);
-        if let Some((idx, _)) = pair {
-            // 等待的子进程确已结束
-            Some(self.dead_children.remove(idx))
-        } else {
-            let pair = self
-                .children
-                .iter()
-                .enumerate()
-                .find(|(_, &id)| id == child_pid);
-            if let Some(_) = pair {
-                // 等待的子进程正在运行
-                Some((ProcId::from_usize(-2 as _), -1))
-            } else {
-                // 等待的子进程不存在
-                None
-            }
-        }
-    }
-}
diff --git a/task-manage/src/proc_thread_rel.rs b/task-manage/src/proc_thread_rel.rs
deleted file mode 100644
index 2f61652..0000000
--- a/task-manage/src/proc_thread_rel.rs
+++ /dev/null
@@ -1,122 +0,0 @@
-use alloc::vec::Vec;
-
-use super::id::{ProcId, ThreadId};
-
-/// 线程、进程之间的关系，通过进程的 Id 来查询这个关系
-#[cfg(feature = "thread")]
-#[doc(cfg(feature = "thread"))]
-pub struct ProcThreadRel {
-    /// 父进程 Id
-    pub parent: ProcId,
-    /// 子进程列表
-    pub children: Vec<ProcId>,
-    /// 已经结束的子进程
-    pub dead_children: Vec<(ProcId, isize)>,
-    /// 线程
-    pub threads: Vec<ThreadId>,
-    /// 已经结束的线程
-    pub dead_threads: Vec<(ThreadId, isize)>,
-}
-
-impl ProcThreadRel {
-    /// new/fork 创建进程时使用
-    pub fn new(parent_pid: ProcId) -> Self {
-        Self {
-            parent: parent_pid,
-            children: Vec::new(),
-            dead_children: Vec::new(),
-            threads: Vec::new(),
-            dead_threads: Vec::new(),
-        }
-    }
-    /// 添加子进程 Id
-    pub fn add_child(&mut self, child_pid: ProcId) {
-        self.children.push(child_pid);
-    }
-    /// 子进程结束，子进程 Id 被移入到 dead_children 队列中，等待 wait 系统调用来处理
-    pub fn del_child(&mut self, child_pid: ProcId, exit_code: isize) {
-        let pair = self
-            .children
-            .iter()
-            .enumerate()
-            .find(|(_, &id)| id == child_pid);
-        if let Some((idx, _)) = pair {
-            let dead_child = self.children.remove(idx);
-            self.dead_children.push((dead_child, exit_code));
-        }
-    }
-    /// 等待任意一个结束的子进程，直接弹出 dead_children 队首，如果队列为空，则返回 -2
-    pub fn wait_any_child(&mut self) -> Option<(ProcId, isize)> {
-        if self.dead_children.is_empty() {
-            if self.children.is_empty() {
-                None
-            } else {
-                Some((ProcId::from_usize(-2 as _), -1))
-            }
-        } else {
-            self.dead_children.pop()
-        }
-    }
-    /// 等待特定的子进程
-    pub fn wait_child(&mut self, child_pid: ProcId) -> Option<(ProcId, isize)> {
-        let pair = self
-            .dead_children
-            .iter()
-            .enumerate()
-            .find(|(_, &(id, _))| id == child_pid);
-        if let Some((idx, _)) = pair {
-            // 等待的子进程确已结束
-            Some(self.dead_children.remove(idx))
-        } else {
-            let pair = self
-                .children
-                .iter()
-                .enumerate()
-                .find(|(_, &id)| id == child_pid);
-            if let Some(_) = pair {
-                // 等待的子进程正在运行
-                Some((ProcId::from_usize(-2 as _), -1))
-            } else {
-                // 等待的子进程不存在
-                None
-            }
-        }
-    }
-    /// 添加线程
-    pub fn add_thread(&mut self, tid: ThreadId) {
-        self.threads.push(tid);
-    }
-    /// 删除线程
-    pub fn del_thread(&mut self, tid: ThreadId, exit_code: isize) {
-        let pair = self.threads.iter().enumerate().find(|(_, &id)| id == tid);
-        if let Some((idx, _)) = pair {
-            let dead_thread = self.threads.remove(idx);
-            self.dead_threads.push((dead_thread, exit_code));
-        }
-    }
-    /// 等待特定的线程结束
-    pub fn wait_thread(&mut self, thread_tid: ThreadId) -> Option<isize> {
-        let pair = self
-            .dead_threads
-            .iter()
-            .enumerate()
-            .find(|(_, &(id, _))| id == thread_tid);
-        if let Some((idx, _)) = pair {
-            // 等待的子进程确已结束
-            Some(self.dead_threads.remove(idx).1)
-        } else {
-            let pair = self
-                .threads
-                .iter()
-                .enumerate()
-                .find(|(_, &id)| id == thread_tid);
-            if let Some(_) = pair {
-                // 等待的子进程正在运行
-                Some(-2)
-            } else {
-                // 等待的子进程不存在
-                None
-            }
-        }
-    }
-}
diff --git a/task-manage/src/scheduler.rs b/task-manage/src/scheduler.rs
deleted file mode 100644
index 7ae91ea..0000000
--- a/task-manage/src/scheduler.rs
+++ /dev/null
@@ -1,7 +0,0 @@
-/// Scheduler
-pub trait Schedule<I: Copy + Ord> {
-    /// 入队
-    fn add(&mut self, id: I);
-    /// 出队
-    fn fetch(&mut self) -> Option<I>;
-}
diff --git a/task-manage/src/thread_manager.rs b/task-manage/src/thread_manager.rs
deleted file mode 100644
index f49d237..0000000
--- a/task-manage/src/thread_manager.rs
+++ /dev/null
@@ -1,193 +0,0 @@
-use alloc::collections::BTreeMap;
-use alloc::vec::Vec;
-
-use crate::ThreadId;
-
-use super::id::ProcId;
-use super::manager::Manage;
-use super::scheduler::Schedule;
-use super::ProcThreadRel;
-use core::marker::PhantomData;
-
-#[cfg(feature = "thread")]
-#[doc(cfg(feature = "thread"))]
-/// PThreadManager 数据结构，只管理进程以及进程之间的父子关系
-/// P 表示进程, T 表示线程
-pub struct PThreadManager<P, T, MT: Manage<T, ThreadId> + Schedule<ThreadId>, MP: Manage<P, ProcId>>
-{
-    // 进程之间父子关系
-    rel_map: BTreeMap<ProcId, ProcThreadRel>,
-    // 进程管理
-    proc_manager: Option<MP>,
-    // 线程所属的进程之间的映射关系
-    tid2pid: BTreeMap<ThreadId, ProcId>,
-    // 进程对象管理和调度
-    manager: Option<MT>,
-    // 当前正在运行的线程 ID
-    current: Option<ThreadId>,
-    phantom_t: PhantomData<T>,
-    phantom_p: PhantomData<P>,
-}
-
-impl<P, T, MT: Manage<T, ThreadId> + Schedule<ThreadId>, MP: Manage<P, ProcId>>
-    PThreadManager<P, T, MT, MP>
-{
-    /// 新建 PThreadManager
-    pub const fn new() -> Self {
-        Self {
-            rel_map: BTreeMap::new(),
-            proc_manager: None,
-            tid2pid: BTreeMap::new(),
-            manager: None,
-            current: None,
-            phantom_t: PhantomData::<T>,
-            phantom_p: PhantomData::<P>,
-        }
-    }
-    /// 找到下一个进程
-    pub fn find_next(&mut self) -> Option<&mut T> {
-        if let Some(id) = self.manager.as_mut().unwrap().fetch() {
-            if let Some(task) = self.manager.as_mut().unwrap().get_mut(id) {
-                self.current = Some(id);
-                Some(task)
-            } else {
-                None
-            }
-        } else {
-            None
-        }
-    }
-    /// 设置 manager
-    pub fn set_manager(&mut self, manager: MT) {
-        self.manager = Some(manager);
-    }
-    /// 设置 proc_manager
-    pub fn set_proc_manager(&mut self, proc_manager: MP) {
-        self.proc_manager = Some(proc_manager);
-    }
-    /// 当前线程重新入队
-    pub fn make_current_suspend(&mut self) {
-        if let Some(id) = self.current {
-            self.manager.as_mut().unwrap().add(id);
-            self.current = None;
-        }
-    }
-    /// 结束当前线程
-    pub fn make_current_exited(&mut self, exit_code: isize) {
-        if let Some(id) = self.current {
-            self.manager.as_mut().unwrap().delete(id);
-            // 线程结束时维护与父进程之间的关系
-            let pid = self.tid2pid.remove(&id).unwrap();
-            let mut flag = false;
-            if let Some(current_rel) = self.rel_map.get_mut(&pid) {
-                current_rel.del_thread(id, exit_code);
-                // 如果线程数量为 0，则需要把当前线程所属的进程给删除掉（所有等待的线程都已经结束）
-                if current_rel.threads.is_empty() {
-                    flag = true;
-                }
-            }
-            if flag {
-                self.del_proc(pid, exit_code);
-            }
-            self.current = None;
-        }
-    }
-    /// 让当前线程阻塞
-    pub fn make_current_blocked(&mut self) {
-        if let Some(_) = self.current {
-            self.current = None;
-        }
-    }
-    /// 某个线程重新入队
-    pub fn re_enque(&mut self, id: ThreadId) {
-        self.manager.as_mut().unwrap().add(id);
-    }
-    /// 添加线程
-    pub fn add(&mut self, id: ThreadId, task: T, pid: ProcId) {
-        self.manager.as_mut().unwrap().insert(id, task);
-        self.manager.as_mut().unwrap().add(id);
-        // 增加线程与进程之间的从属关系
-        if let Some(parent_rel) = self.rel_map.get_mut(&pid) {
-            parent_rel.add_thread(id);
-            self.tid2pid.insert(id, pid);
-        }
-    }
-    /// 当前线程
-    pub fn current(&mut self) -> Option<&mut T> {
-        let id = self.current.unwrap();
-        self.manager.as_mut().unwrap().get_mut(id)
-    }
-    /// 获取某个线程
-    #[inline]
-    pub fn get_task(&mut self, id: ThreadId) -> Option<&mut T> {
-        self.manager.as_mut().unwrap().get_mut(id)
-    }
-    /// 添加进程
-    pub fn add_proc(&mut self, id: ProcId, proc: P, parent: ProcId) {
-        self.proc_manager.as_mut().unwrap().insert(id, proc);
-        if let Some(parent_rel) = self.rel_map.get_mut(&parent) {
-            parent_rel.add_child(id);
-        }
-        self.rel_map.insert(id, ProcThreadRel::new(parent));
-    }
-    /// 查询进程
-    pub fn get_proc(&mut self, id: ProcId) -> Option<&mut P> {
-        self.proc_manager.as_mut().unwrap().get_mut(id)
-    }
-    /// 结束当前进程
-    pub fn del_proc(&mut self, id: ProcId, exit_code: isize) {
-        // 删除进程实体
-        self.proc_manager.as_mut().unwrap().delete(id);
-        // 进程结束时维护父子关系，进程删除后，所有的子进程交给 0 号进程来维护
-        let current_rel = self.rel_map.remove(&id).unwrap();
-        let parent_pid = current_rel.parent;
-        let children = current_rel.children;
-        // 从父进程中删除当前进程
-        if let Some(parent_rel) = self.rel_map.get_mut(&parent_pid) {
-            parent_rel.del_child(id, exit_code);
-        }
-        // 把当前进程的所有子进程转移到 0 号进程
-        for i in children {
-            self.rel_map.get_mut(&i).unwrap().parent = ProcId::from_usize(0);
-            self.rel_map
-                .get_mut(&ProcId::from_usize(0))
-                .unwrap()
-                .add_child(i);
-        }
-    }
-    /// wait 系统调用，返回结束的子进程 id 和 exit_code，正在运行的子进程不返回 None，返回 (-2, -1)
-    pub fn wait(&mut self, child_pid: ProcId) -> Option<(ProcId, isize)> {
-        let id = self.current.unwrap();
-        let pid = self.tid2pid.get(&id).unwrap();
-        let current_rel = self.rel_map.get_mut(pid).unwrap();
-        if child_pid.get_usize() == usize::MAX {
-            current_rel.wait_any_child()
-        } else {
-            current_rel.wait_child(child_pid)
-        }
-    }
-    /// wait_tid 系统调用
-    pub fn waittid(&mut self, thread_tid: ThreadId) -> Option<isize> {
-        let id = self.current.unwrap();
-        let pid = self.tid2pid.get(&id).unwrap();
-        let current_rel = self.rel_map.get_mut(pid).unwrap();
-        current_rel.wait_thread(thread_tid)
-    }
-    /// 某个进程的线程数量
-    pub fn thread_count(&self, id: ProcId) -> usize {
-        self.rel_map.get(&id).unwrap().threads.len()
-    }
-    /// 查询进程的线程
-    pub fn get_thread(&mut self, id: ProcId) -> Option<&Vec<ThreadId>> {
-        self.rel_map.get_mut(&id).map(|p| &p.threads)
-    }
-    /// 获取当前线程所属的进程
-    pub fn get_current_proc(&mut self) -> Option<&mut P> {
-        if let Some(id) = self.current {
-            let pid = self.tid2pid.get(&id).unwrap();
-            self.proc_manager.as_mut().unwrap().get_mut(*pid)
-        } else {
-            None
-        }
-    }
-}
diff --git a/user/.cargo/config.toml b/user/.cargo/config.toml
deleted file mode 100644
index 4e98a9b..0000000
--- a/user/.cargo/config.toml
+++ /dev/null
@@ -1,7 +0,0 @@
-[build]
-target = "riscv64gc-unknown-none-elf"
-
-[target.riscv64gc-unknown-none-elf]
-rustflags = [
-    "-Clink-args=-Tuser/src/linker.ld", "-Cforce-frame-pointers=yes"
-]
diff --git a/user/.gitignore b/user/.gitignore
deleted file mode 100644
index d472d78..0000000
--- a/user/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-target/*
diff --git a/user/Cargo.toml b/user/Cargo.toml
deleted file mode 100644
index 12378b3..0000000
--- a/user/Cargo.toml
+++ /dev/null
@@ -1,19 +0,0 @@
-[package]
-name = "user_lib"
-version = "0.1.0"
-authors = ["Yifan Wu <shinbokuow@163.com>"]
-edition = "2018"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-buddy_system_allocator = "0.6"
-bitflags = "1.2.1"
-riscv = { git = "https://github.com/rcore-os/riscv", features = ["inline-asm"] }
-lazy_static = { version = "1.4.0", features = ["spin_no_std"] }
-embedded-graphics = "0.7.1"
-oorandom ="11"
-virtio-input-decoder = "0.1.4"
-
-[profile.release]
-debug = true
\ No newline at end of file
diff --git a/user/Makefile b/user/Makefile
deleted file mode 100644
index 96d1371..0000000
--- a/user/Makefile
+++ /dev/null
@@ -1,29 +0,0 @@
-TARGET := riscv64gc-unknown-none-elf
-MODE := release
-APP_DIR := src/bin
-TARGET_DIR := ../target/$(TARGET)/$(MODE)
-APPS := $(wildcard $(APP_DIR)/*.rs)
-ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))
-BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))
-
-OBJDUMP := rust-objdump --arch-name=riscv64
-OBJCOPY := rust-objcopy --binary-architecture=riscv64
-CP := cp 
-
-TEST ?= 1
-
-elf: $(APPS)
-	@cargo build -p user_lib --release
-ifeq ($(TEST), 1)
-	@$(CP) $(TARGET_DIR)/usertests $(TARGET_DIR)/initproc
-endif
-
-binary: elf
-	@$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)
-
-build: binary
-
-clean:
-	@cargo clean
-
-.PHONY: elf binary build clean
diff --git a/user/src/bin/adder.rs b/user/src/bin/adder.rs
deleted file mode 100644
index d1addf1..0000000
--- a/user/src/bin/adder.rs
+++ /dev/null
@@ -1,57 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid};
-
-static mut A: usize = 0;
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        critical_section(&mut t);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-    let start = get_time();
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_atomic.rs b/user/src/bin/adder_atomic.rs
deleted file mode 100644
index 8fb5639..0000000
--- a/user/src/bin/adder_atomic.rs
+++ /dev/null
@@ -1,74 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use core::sync::atomic::{AtomicBool, Ordering};
-use user_lib::{exit, get_time, thread_create, waittid, yield_};
-
-static mut A: usize = 0;
-static OCCUPIED: AtomicBool = AtomicBool::new(false);
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-fn lock() {
-    while OCCUPIED
-        .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
-        .is_err()
-    {
-        yield_();
-    }
-}
-
-fn unlock() {
-    OCCUPIED.store(false, Ordering::Relaxed);
-}
-
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        lock();
-        critical_section(&mut t);
-        unlock();
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-    let start = get_time();
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_mutex_blocking.rs b/user/src/bin/adder_mutex_blocking.rs
deleted file mode 100644
index 79bb3c3..0000000
--- a/user/src/bin/adder_mutex_blocking.rs
+++ /dev/null
@@ -1,61 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid};
-use user_lib::{mutex_blocking_create, mutex_lock, mutex_unlock};
-
-static mut A: usize = 0;
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        mutex_lock(0);
-        critical_section(&mut t);
-        mutex_unlock(0);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-
-    let start = get_time();
-    assert_eq!(mutex_blocking_create(), 0);
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_mutex_spin.rs b/user/src/bin/adder_mutex_spin.rs
deleted file mode 100644
index 315a338..0000000
--- a/user/src/bin/adder_mutex_spin.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid};
-use user_lib::{mutex_create, mutex_lock, mutex_unlock};
-
-static mut A: usize = 0;
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        mutex_lock(0);
-        critical_section(&mut t);
-        mutex_unlock(0);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-
-    let start = get_time();
-    assert_eq!(mutex_create(), 0);
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_peterson_spin.rs b/user/src/bin/adder_peterson_spin.rs
deleted file mode 100644
index 35fd0d3..0000000
--- a/user/src/bin/adder_peterson_spin.rs
+++ /dev/null
@@ -1,95 +0,0 @@
-//! It only works on a single CPU!
-
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use core::sync::atomic::{compiler_fence, Ordering};
-use user_lib::{exit, get_time, thread_create, waittid};
-
-static mut A: usize = 0;
-static mut FLAG: [bool; 2] = [false; 2];
-static mut TURN: usize = 0;
-const PER_THREAD_DEFAULT: usize = 2000;
-const THREAD_COUNT_DEFAULT: usize = 2;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn lock(id: usize) {
-    FLAG[id] = true;
-    let j = 1 - id;
-    TURN = j;
-    // Tell the compiler not to reorder memory operations
-    // across this fence.
-    compiler_fence(Ordering::SeqCst);
-    // Why do we need to use volatile_read here?
-    // Otherwise the compiler will assume that they will never
-    // be changed on this thread. Thus, they will be accessed
-    // only once!
-    while vload!(&FLAG[j]) && vload!(&TURN) == j {}
-}
-
-unsafe fn unlock(id: usize) {
-    FLAG[id] = false;
-}
-
-unsafe fn f(id: usize) -> ! {
-    let mut t = 2usize;
-    for _iter in 0..PER_THREAD {
-        lock(id);
-        critical_section(&mut t);
-        unlock(id);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-
-    // uncomment this if you want to check the assembly
-    // println!(
-    //     "addr: lock={:#x}, unlock={:#x}",
-    //     lock as usize,
-    //     unlock as usize
-    // );
-    let start = get_time();
-    let mut v = Vec::new();
-    assert_eq!(
-        thread_count, 2,
-        "Peterson works when there are only 2 threads."
-    );
-    for id in 0..thread_count {
-        v.push(thread_create(f as usize, id) as usize);
-    }
-    let mut time_cost = Vec::new();
-    for tid in v.iter() {
-        time_cost.push(waittid(*tid));
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_peterson_yield.rs b/user/src/bin/adder_peterson_yield.rs
deleted file mode 100644
index 7b905e3..0000000
--- a/user/src/bin/adder_peterson_yield.rs
+++ /dev/null
@@ -1,94 +0,0 @@
-//! It only works on a single CPU!
-
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use core::sync::atomic::{compiler_fence, Ordering};
-use user_lib::{exit, get_time, thread_create, waittid, yield_};
-
-static mut A: usize = 0;
-static mut FLAG: [bool; 2] = [false; 2];
-static mut TURN: usize = 0;
-const PER_THREAD_DEFAULT: usize = 2000;
-const THREAD_COUNT_DEFAULT: usize = 2;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn lock(id: usize) {
-    FLAG[id] = true;
-    let j = 1 - id;
-    TURN = j;
-    // Tell the compiler not to reorder memory operations
-    // across this fence.
-    compiler_fence(Ordering::SeqCst);
-    while FLAG[j] && TURN == j {
-        yield_();
-    }
-}
-
-unsafe fn unlock(id: usize) {
-    FLAG[id] = false;
-}
-
-unsafe fn f(id: usize) -> ! {
-    let mut t = 2usize;
-    for _iter in 0..PER_THREAD {
-        lock(id);
-        critical_section(&mut t);
-        unlock(id);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-
-    // uncomment this if you want to check the assembly
-    // println!(
-    //     "addr: lock={:#x}, unlock={:#x}",
-    //     lock as usize,
-    //     unlock as usize
-    // );
-
-    let start = get_time();
-    let mut v = Vec::new();
-    assert_eq!(
-        thread_count, 2,
-        "Peterson works when there are only 2 threads."
-    );
-    for id in 0..thread_count {
-        v.push(thread_create(f as usize, id) as usize);
-    }
-    let mut time_cost = Vec::new();
-    for tid in v.iter() {
-        time_cost.push(waittid(*tid));
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_simple_spin.rs b/user/src/bin/adder_simple_spin.rs
deleted file mode 100644
index ad5b328..0000000
--- a/user/src/bin/adder_simple_spin.rs
+++ /dev/null
@@ -1,70 +0,0 @@
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid};
-
-static mut A: usize = 0;
-static mut OCCUPIED: bool = false;
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn lock() {
-    while vload!(&OCCUPIED) {}
-    OCCUPIED = true;
-}
-
-unsafe fn unlock() {
-    OCCUPIED = false;
-}
-
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        lock();
-        critical_section(&mut t);
-        unlock();
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-    let start = get_time();
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/adder_simple_yield.rs b/user/src/bin/adder_simple_yield.rs
deleted file mode 100644
index 355b401..0000000
--- a/user/src/bin/adder_simple_yield.rs
+++ /dev/null
@@ -1,72 +0,0 @@
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid, yield_};
-
-static mut A: usize = 0;
-static mut OCCUPIED: bool = false;
-const PER_THREAD_DEFAULT: usize = 10000;
-const THREAD_COUNT_DEFAULT: usize = 16;
-static mut PER_THREAD: usize = 0;
-
-unsafe fn critical_section(t: &mut usize) {
-    let a = &mut A as *mut usize;
-    let cur = a.read_volatile();
-    for _ in 0..500 {
-        *t = (*t) * (*t) % 10007;
-    }
-    a.write_volatile(cur + 1);
-}
-
-unsafe fn lock() {
-    while OCCUPIED {
-        yield_();
-    }
-    OCCUPIED = true;
-}
-
-unsafe fn unlock() {
-    OCCUPIED = false;
-}
-
-unsafe fn f() -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        lock();
-        critical_section(&mut t);
-        unlock();
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let mut thread_count = THREAD_COUNT_DEFAULT;
-    let mut per_thread = PER_THREAD_DEFAULT;
-    if argc >= 2 {
-        thread_count = argv[1].parse().unwrap();
-        if argc >= 3 {
-            per_thread = argv[2].parse().unwrap();
-        }
-    }
-    unsafe {
-        PER_THREAD = per_thread;
-    }
-    let start = get_time();
-    let mut v = Vec::new();
-    for _ in 0..thread_count {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    for tid in v.into_iter() {
-        waittid(tid);
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, unsafe { PER_THREAD } * thread_count);
-    0
-}
diff --git a/user/src/bin/barrier_condvar.rs b/user/src/bin/barrier_condvar.rs
deleted file mode 100644
index 7157772..0000000
--- a/user/src/bin/barrier_condvar.rs
+++ /dev/null
@@ -1,83 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use core::cell::UnsafeCell;
-use lazy_static::*;
-use user_lib::{
-    condvar_create, condvar_signal, condvar_wait, exit, mutex_create, mutex_lock, mutex_unlock,
-    thread_create, waittid,
-};
-
-const THREAD_NUM: usize = 3;
-
-struct Barrier {
-    mutex_id: usize,
-    condvar_id: usize,
-    count: UnsafeCell<usize>,
-}
-
-impl Barrier {
-    pub fn new() -> Self {
-        Self {
-            mutex_id: mutex_create() as usize,
-            condvar_id: condvar_create() as usize,
-            count: UnsafeCell::new(0),
-        }
-    }
-    pub fn block(&self) {
-        mutex_lock(self.mutex_id);
-        let count = self.count.get();
-        // SAFETY: Here, the accesses of the count is in the
-        // critical section protected by the mutex.
-        unsafe {
-            *count = *count + 1;
-        }
-        if unsafe { *count } == THREAD_NUM {
-            condvar_signal(self.condvar_id);
-        } else {
-            condvar_wait(self.condvar_id, self.mutex_id);
-            condvar_signal(self.condvar_id);
-        }
-        mutex_unlock(self.mutex_id);
-    }
-}
-
-unsafe impl Sync for Barrier {}
-
-lazy_static! {
-    static ref BARRIER_AB: Barrier = Barrier::new();
-    static ref BARRIER_BC: Barrier = Barrier::new();
-}
-
-fn thread_fn() {
-    for _ in 0..300 {
-        print!("a");
-    }
-    BARRIER_AB.block();
-    for _ in 0..300 {
-        print!("b");
-    }
-    BARRIER_BC.block();
-    for _ in 0..300 {
-        print!("c");
-    }
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v: Vec<isize> = Vec::new();
-    for _ in 0..THREAD_NUM {
-        v.push(thread_create(thread_fn as usize, 0));
-    }
-    for tid in v.into_iter() {
-        waittid(tid as usize);
-    }
-    println!("\nOK!");
-    0
-}
diff --git a/user/src/bin/barrier_fail.rs b/user/src/bin/barrier_fail.rs
deleted file mode 100644
index 11604ca..0000000
--- a/user/src/bin/barrier_fail.rs
+++ /dev/null
@@ -1,33 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, thread_create, waittid};
-
-const THREAD_NUM: usize = 3;
-
-fn thread_fn() {
-    for ch in 'a'..='c' {
-        for _ in 0..300 {
-            print!("{}", ch);
-        }
-    }
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v: Vec<isize> = Vec::new();
-    for _ in 0..THREAD_NUM {
-        v.push(thread_create(thread_fn as usize, 0));
-    }
-    for tid in v.into_iter() {
-        waittid(tid as usize);
-    }
-    println!("\nOK!");
-    0
-}
diff --git a/user/src/bin/cat.rs b/user/src/bin/cat.rs
deleted file mode 100644
index b6a653b..0000000
--- a/user/src/bin/cat.rs
+++ /dev/null
@@ -1,32 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use user_lib::{close, open, read, OpenFlags};
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    println!("argc = {}", argc);
-    for (i, arg) in argv.iter().enumerate() {
-        println!("argv[{}] = {}", i, arg);
-    }
-    assert!(argc == 2);
-    let fd = open(argv[1], OpenFlags::RDONLY);
-    if fd == -1 {
-        panic!("Error occurred when opening file");
-    }
-    let fd = fd as usize;
-    let mut buf = [0u8; 256];
-    loop {
-        let size = read(fd, &mut buf) as usize;
-        if size == 0 {
-            break;
-        }
-        print!("{}", core::str::from_utf8(&buf[..size]).unwrap());
-    }
-    close(fd);
-    0
-}
diff --git a/user/src/bin/cmdline_args.rs b/user/src/bin/cmdline_args.rs
deleted file mode 100644
index 83857d4..0000000
--- a/user/src/bin/cmdline_args.rs
+++ /dev/null
@@ -1,16 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate alloc;
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    println!("argc = {}", argc);
-    for (i, arg) in argv.iter().enumerate() {
-        println!("argv[{}] = {}", i, arg);
-    }
-    0
-}
diff --git a/user/src/bin/condsync_condvar.rs b/user/src/bin/condsync_condvar.rs
deleted file mode 100644
index 78605ad..0000000
--- a/user/src/bin/condsync_condvar.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::exit;
-use user_lib::{
-    condvar_create, condvar_signal, condvar_wait, mutex_blocking_create, mutex_lock, mutex_unlock,
-};
-use user_lib::{sleep, thread_create, waittid};
-
-static mut A: usize = 0;
-
-const CONDVAR_ID: usize = 0;
-const MUTEX_ID: usize = 0;
-
-unsafe fn first() -> ! {
-    sleep(10);
-    println!("First work, Change A --> 1 and wakeup Second");
-    mutex_lock(MUTEX_ID);
-    A = 1;
-    condvar_signal(CONDVAR_ID);
-    mutex_unlock(MUTEX_ID);
-    exit(0)
-}
-
-unsafe fn second() -> ! {
-    println!("Second want to continue,but need to wait A=1");
-    mutex_lock(MUTEX_ID);
-    while A == 0 {
-        println!("Second: A is {}", A);
-        condvar_wait(CONDVAR_ID, MUTEX_ID);
-    }
-    println!("A is {}, Second can work now", A);
-    mutex_unlock(MUTEX_ID);
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create condvar & mutex
-    assert_eq!(condvar_create() as usize, CONDVAR_ID);
-    assert_eq!(mutex_blocking_create() as usize, MUTEX_ID);
-    // create threads
-    let threads = vec![
-        thread_create(first as usize, 0),
-        thread_create(second as usize, 0),
-    ];
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("test_condvar passed!");
-    0
-}
diff --git a/user/src/bin/condsync_sem.rs b/user/src/bin/condsync_sem.rs
deleted file mode 100644
index ee08fac..0000000
--- a/user/src/bin/condsync_sem.rs
+++ /dev/null
@@ -1,64 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::exit;
-use user_lib::{
-    mutex_blocking_create, mutex_lock, mutex_unlock, semaphore_create, semaphore_down, semaphore_up,
-};
-use user_lib::{sleep, thread_create, waittid};
-
-static mut A: usize = 0;
-
-const SEM_ID: usize = 0;
-const MUTEX_ID: usize = 0;
-
-unsafe fn first() -> ! {
-    sleep(10);
-    println!("First work, Change A --> 1 and wakeup Second");
-    mutex_lock(MUTEX_ID);
-    A = 1;
-    semaphore_up(SEM_ID);
-    mutex_unlock(MUTEX_ID);
-    exit(0)
-}
-
-unsafe fn second() -> ! {
-    println!("Second want to continue,but need to wait A=1");
-    loop {
-        mutex_lock(MUTEX_ID);
-        if A == 0 {
-            println!("Second: A is {}", A);
-            mutex_unlock(MUTEX_ID);
-            semaphore_down(SEM_ID);
-        } else {
-            mutex_unlock(MUTEX_ID);
-            break;
-        }
-    }
-    println!("A is {}, Second can work now", A);
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create semaphore & mutex
-    assert_eq!(semaphore_create(0) as usize, SEM_ID);
-    assert_eq!(mutex_blocking_create() as usize, MUTEX_ID);
-    // create threads
-    let threads = vec![
-        thread_create(first as usize, 0),
-        thread_create(second as usize, 0),
-    ];
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("test_condvar passed!");
-    0
-}
diff --git a/user/src/bin/count_lines.rs b/user/src/bin/count_lines.rs
deleted file mode 100644
index f4d9c9a..0000000
--- a/user/src/bin/count_lines.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::read;
-
-#[no_mangle]
-pub fn main(_argc: usize, _argv: &[&str]) -> i32 {
-    let mut buf = [0u8; 256];
-    let mut lines = 0usize;
-    let mut total_size = 0usize;
-    loop {
-        let len = read(0, &mut buf) as usize;
-        if len == 0 {
-            break;
-        }
-        total_size += len;
-        let string = core::str::from_utf8(&buf[..len]).unwrap();
-        lines += string
-            .chars()
-            .fold(0, |acc, c| acc + if c == '\n' { 1 } else { 0 });
-    }
-    if total_size > 0 {
-        lines += 1;
-    }
-    println!("{}", lines);
-    0
-}
diff --git a/user/src/bin/eisenberg.rs b/user/src/bin/eisenberg.rs
deleted file mode 100644
index d39edd1..0000000
--- a/user/src/bin/eisenberg.rs
+++ /dev/null
@@ -1,138 +0,0 @@
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-extern crate core;
-
-use alloc::vec::Vec;
-use core::sync::atomic::{AtomicUsize, Ordering};
-use user_lib::{exit, sleep, thread_create, waittid};
-
-const N: usize = 2;
-const THREAD_NUM: usize = 10;
-
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-enum FlagState {
-    Out,
-    Want,
-    In,
-}
-
-static mut TURN: usize = 0;
-static mut FLAG: [FlagState; THREAD_NUM] = [FlagState::Out; THREAD_NUM];
-
-static GUARD: AtomicUsize = AtomicUsize::new(0);
-
-fn critical_test_enter() {
-    assert_eq!(GUARD.fetch_add(1, Ordering::SeqCst), 0);
-}
-
-fn critical_test_claim() {
-    assert_eq!(GUARD.load(Ordering::SeqCst), 1);
-}
-
-fn critical_test_exit() {
-    assert_eq!(GUARD.fetch_sub(1, Ordering::SeqCst), 1);
-}
-
-fn eisenberg_enter_critical(id: usize) {
-    /* announce that we want to enter */
-    loop {
-        println!("Thread[{}] try enter", id);
-        vstore!(&FLAG[id], FlagState::Want);
-        loop {
-            /* check if any with higher priority is `Want` or `In` */
-            let mut prior_thread: Option<usize> = None;
-            let turn = vload!(&TURN);
-            let ring_id = if id < turn { id + THREAD_NUM } else { id };
-            // FLAG.iter() may lead to some errors, use for-loop instead
-            for i in turn..ring_id {
-                if vload!(&FLAG[i % THREAD_NUM]) != FlagState::Out {
-                    prior_thread = Some(i % THREAD_NUM);
-                    break;
-                }
-            }
-            if prior_thread.is_none() {
-                break;
-            }
-            println!(
-                "Thread[{}]: prior thread {} exist, sleep and retry",
-                id,
-                prior_thread.unwrap()
-            );
-            sleep(1);
-        }
-        /* now tentatively claim the resource */
-        vstore!(&FLAG[id], FlagState::In);
-        /* enforce the order of `claim` and `conflict check`*/
-        memory_fence!();
-        /* check if anthor thread is also `In`, which imply a conflict*/
-        let mut conflict = false;
-        for i in 0..THREAD_NUM {
-            if i != id && vload!(&FLAG[i]) == FlagState::In {
-                conflict = true;
-            }
-        }
-        if !conflict {
-            break;
-        }
-        println!("Thread[{}]: CONFLECT!", id);
-        /* no need to sleep */
-    }
-    /* clain the trun */
-    vstore!(&TURN, id);
-    println!("Thread[{}] enter", id);
-}
-
-fn eisenberg_exit_critical(id: usize) {
-    /* find next one who wants to enter and give the turn to it*/
-    let mut next = id;
-    let ring_id = id + THREAD_NUM;
-    for i in (id + 1)..ring_id {
-        let idx = i % THREAD_NUM;
-        if vload!(&FLAG[idx]) == FlagState::Want {
-            next = idx;
-            break;
-        }
-    }
-    vstore!(&TURN, next);
-    /* All done */
-    vstore!(&FLAG[id], FlagState::Out);
-    println!("Thread[{}] exit, give turn to {}", id, next);
-}
-
-pub fn thread_fn(id: usize) -> ! {
-    println!("Thread[{}] init.", id);
-    for _ in 0..N {
-        eisenberg_enter_critical(id);
-        critical_test_enter();
-        for _ in 0..3 {
-            critical_test_claim();
-            sleep(2);
-        }
-        critical_test_exit();
-        eisenberg_exit_critical(id);
-    }
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v = Vec::new();
-    // TODO: really shuffle
-    assert_eq!(THREAD_NUM, 10);
-    let shuffle: [usize; 10] = [0, 7, 4, 6, 2, 9, 8, 1, 3, 5];
-    for i in 0..THREAD_NUM {
-        v.push(thread_create(thread_fn as usize, shuffle[i]));
-    }
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        assert_eq!(exit_code, 0, "thread conflict happened!");
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    0
-}
diff --git a/user/src/bin/exit.rs b/user/src/bin/exit.rs
deleted file mode 100644
index f9b4ec4..0000000
--- a/user/src/bin/exit.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-use user_lib::{exit, fork, wait, waitpid, yield_};
-
-const MAGIC: i32 = -0x10384;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("I am the parent. Forking the child...");
-    let pid = fork();
-    if pid == 0 {
-        println!("I am the child.");
-        for _ in 0..7 {
-            yield_();
-        }
-        exit(MAGIC);
-    } else {
-        println!("I am parent, fork a child pid {}", pid);
-    }
-    println!("I am the parent, waiting now..");
-    let mut xstate: i32 = 0;
-    assert!(waitpid(pid as usize, &mut xstate) == pid && xstate == MAGIC);
-    assert!(waitpid(pid as usize, &mut xstate) < 0 && wait(&mut xstate) <= 0);
-    println!("waitpid {} ok.", pid);
-    println!("exit pass.");
-    0
-}
diff --git a/user/src/bin/fantastic_text.rs b/user/src/bin/fantastic_text.rs
deleted file mode 100644
index 5c19d05..0000000
--- a/user/src/bin/fantastic_text.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-macro_rules! color_text {
-    ($text:expr, $color:expr) => {{
-        format_args!("\x1b[{}m{}\x1b[0m", $color, $text)
-    }};
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!(
-        "{}{}{}{}{} {}{}{}{} {}{}{}{}{}{}",
-        color_text!("H", 31),
-        color_text!("e", 32),
-        color_text!("l", 33),
-        color_text!("l", 34),
-        color_text!("o", 35),
-        color_text!("R", 36),
-        color_text!("u", 37),
-        color_text!("s", 90),
-        color_text!("t", 91),
-        color_text!("u", 92),
-        color_text!("C", 93),
-        color_text!("o", 94),
-        color_text!("r", 95),
-        color_text!("e", 96),
-        color_text!("!", 97),
-    );
-
-    let text =
-        "reguler \x1b[4munderline\x1b[24m \x1b[7mreverse\x1b[27m \x1b[9mstrikethrough\x1b[29m";
-    println!("\x1b[47m{}\x1b[0m", color_text!(text, 30));
-    for i in 31..38 {
-        println!("{}", color_text!(text, i));
-    }
-    for i in 90..98 {
-        println!("{}", color_text!(text, i));
-    }
-    0
-}
diff --git a/user/src/bin/filetest_simple.rs b/user/src/bin/filetest_simple.rs
deleted file mode 100644
index d3a1af1..0000000
--- a/user/src/bin/filetest_simple.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{close, open, read, write, OpenFlags};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let test_str = "Hello, world!";
-    let filea = "filea\0";
-    let fd = open(filea, OpenFlags::CREATE | OpenFlags::WRONLY);
-    assert!(fd > 0);
-    let fd = fd as usize;
-    write(fd, test_str.as_bytes());
-    close(fd);
-
-    let fd = open(filea, OpenFlags::RDONLY);
-    assert!(fd > 0);
-    let fd = fd as usize;
-    let mut buffer = [0u8; 100];
-    let read_len = read(fd, &mut buffer) as usize;
-    close(fd);
-
-    assert_eq!(test_str, core::str::from_utf8(&buffer[..read_len]).unwrap(),);
-    println!("file_test passed!");
-    0
-}
diff --git a/user/src/bin/forktest.rs b/user/src/bin/forktest.rs
deleted file mode 100644
index f4e387d..0000000
--- a/user/src/bin/forktest.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, wait};
-
-const MAX_CHILD: usize = 30;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for i in 0..MAX_CHILD {
-        let pid = fork();
-        if pid == 0 {
-            println!("I am child {}", i);
-            exit(0);
-        } else {
-            println!("forked child pid = {}", pid);
-        }
-        assert!(pid > 0);
-    }
-    let mut exit_code: i32 = 0;
-    for _ in 0..MAX_CHILD {
-        if wait(&mut exit_code) <= 0 {
-            panic!("wait stopped early");
-        }
-    }
-    if wait(&mut exit_code) > 0 {
-        panic!("wait got too many");
-    }
-    println!("forktest pass.");
-    0
-}
diff --git a/user/src/bin/forktest2.rs b/user/src/bin/forktest2.rs
deleted file mode 100644
index 1c211cd..0000000
--- a/user/src/bin/forktest2.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, get_time, getpid, sleep, wait};
-
-static NUM: usize = 30;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for _ in 0..NUM {
-        let pid = fork();
-        if pid == 0 {
-            let current_time = get_time();
-            let sleep_length =
-                (current_time as i32 as isize) * (current_time as i32 as isize) % 1000 + 1000;
-            println!("pid {} sleep for {} ms", getpid(), sleep_length);
-            sleep(sleep_length as usize);
-            println!("pid {} OK!", getpid());
-            exit(0);
-        }
-    }
-
-    let mut exit_code: i32 = 0;
-    for _ in 0..NUM {
-        assert!(wait(&mut exit_code) > 0);
-        assert_eq!(exit_code, 0);
-    }
-    assert!(wait(&mut exit_code) < 0);
-    println!("forktest2 test passed!");
-    0
-}
diff --git a/user/src/bin/forktest_simple.rs b/user/src/bin/forktest_simple.rs
deleted file mode 100644
index 63d95ac..0000000
--- a/user/src/bin/forktest_simple.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{fork, getpid, wait};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    assert_eq!(wait(&mut 0i32), -1);
-    println!("sys_wait without child process test passed!");
-    println!("parent start, pid = {}!", getpid());
-    let pid = fork();
-    if pid == 0 {
-        // child process
-        println!("hello child process!");
-        100
-    } else {
-        // parent process
-        let mut exit_code: i32 = 0;
-        println!("ready waiting on parent process!");
-        assert_eq!(pid, wait(&mut exit_code));
-        assert_eq!(exit_code, 100);
-        println!("child process pid = {}, exit code = {}", pid, exit_code);
-        0
-    }
-}
diff --git a/user/src/bin/forktree.rs b/user/src/bin/forktree.rs
deleted file mode 100644
index ccf92a2..0000000
--- a/user/src/bin/forktree.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, getpid, sleep, wait, yield_};
-
-const DEPTH: usize = 4;
-
-fn fork_child(cur: &str, branch: char) {
-    let mut next = [0u8; DEPTH + 1];
-    let l = cur.len();
-    if l >= DEPTH {
-        return;
-    }
-    next[..l].copy_from_slice(cur.as_bytes());
-    next[l] = branch as u8;
-    if fork() == 0 {
-        fork_tree(core::str::from_utf8(&next[..l + 1]).unwrap());
-        yield_();
-        exit(0);
-    }
-}
-
-fn fork_tree(cur: &str) {
-    println!("pid{}: {}", getpid(), cur);
-    fork_child(cur, '0');
-    fork_child(cur, '1');
-    let mut exit_code: i32 = 0;
-    for _ in 0..2 {
-        wait(&mut exit_code);
-    }
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    fork_tree("");
-    let mut exit_code: i32 = 0;
-    for _ in 0..2 {
-        wait(&mut exit_code);
-    }
-    sleep(3000);
-    0
-}
diff --git a/user/src/bin/gui_rect.rs b/user/src/bin/gui_rect.rs
deleted file mode 100644
index b73162b..0000000
--- a/user/src/bin/gui_rect.rs
+++ /dev/null
@@ -1,71 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate alloc;
-extern crate user_lib;
-
-use user_lib::{Display, VIRTGPU_XRES, VIRTGPU_YRES};
-
-use embedded_graphics::pixelcolor::Rgb888;
-use embedded_graphics::prelude::{DrawTarget, Drawable, Point, RgbColor, Size};
-use embedded_graphics::primitives::{Circle, Primitive, PrimitiveStyle, Rectangle, Triangle};
-
-const INIT_X: i32 = 80;
-const INIT_Y: i32 = 400;
-const RECT_SIZE: u32 = 150;
-
-pub struct DrawingBoard {
-    disp: Display,
-    latest_pos: Point,
-}
-
-impl DrawingBoard {
-    pub fn new() -> Self {
-        Self {
-            disp: Display::new(Size::new(VIRTGPU_XRES, VIRTGPU_YRES)),
-            latest_pos: Point::new(INIT_X, INIT_Y),
-        }
-    }
-    fn paint(&mut self) {
-        Rectangle::with_center(self.latest_pos, Size::new(RECT_SIZE, RECT_SIZE))
-            .into_styled(PrimitiveStyle::with_stroke(Rgb888::RED, 10))
-            .draw(&mut self.disp)
-            .ok();
-        Circle::new(self.latest_pos + Point::new(-70, -300), 150)
-            .into_styled(PrimitiveStyle::with_fill(Rgb888::BLUE))
-            .draw(&mut self.disp)
-            .ok();
-        Triangle::new(
-            self.latest_pos + Point::new(0, 150),
-            self.latest_pos + Point::new(80, 200),
-            self.latest_pos + Point::new(-120, 300),
-        )
-        .into_styled(PrimitiveStyle::with_stroke(Rgb888::GREEN, 10))
-        .draw(&mut self.disp)
-        .ok();
-    }
-    fn unpaint(&mut self) {
-        Rectangle::with_center(self.latest_pos, Size::new(RECT_SIZE, RECT_SIZE))
-            .into_styled(PrimitiveStyle::with_stroke(Rgb888::BLACK, 10))
-            .draw(&mut self.disp)
-            .ok();
-    }
-    pub fn move_rect(&mut self, dx: i32, dy: i32) {
-        self.unpaint();
-        self.latest_pos.x += dx;
-        self.latest_pos.y += dy;
-        self.paint();
-    }
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut board = DrawingBoard::new();
-    let _ = board.disp.clear(Rgb888::BLACK).unwrap();
-    for _i in 0..5 {
-        board.latest_pos.x += RECT_SIZE as i32 + 20;
-        //board.latest_pos.y += i;
-        board.paint();
-    }
-    0
-}
diff --git a/user/src/bin/gui_simple.rs b/user/src/bin/gui_simple.rs
deleted file mode 100644
index f30b1fc..0000000
--- a/user/src/bin/gui_simple.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use embedded_graphics::prelude::Size;
-use user_lib::{Display, VIRTGPU_XRES, VIRTGPU_YRES};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut disp = Display::new(Size::new(VIRTGPU_XRES, VIRTGPU_YRES));
-    disp.paint_on_framebuffer(|fb| {
-        for y in 0..VIRTGPU_YRES as usize {
-            for x in 0..VIRTGPU_XRES as usize {
-                let idx = (y * VIRTGPU_XRES as usize + x) * 4;
-                fb[idx] = x as u8;
-                fb[idx + 1] = y as u8;
-                fb[idx + 2] = (x + y) as u8;
-            }
-        }
-    });
-    0
-}
diff --git a/user/src/bin/gui_snake.rs b/user/src/bin/gui_snake.rs
deleted file mode 100644
index 0411824..0000000
--- a/user/src/bin/gui_snake.rs
+++ /dev/null
@@ -1,351 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate alloc;
-extern crate user_lib;
-
-use user_lib::console::getchar;
-use user_lib::{key_pressed, sleep, Display, VIRTGPU_XRES, VIRTGPU_YRES};
-
-use embedded_graphics::pixelcolor::*;
-use embedded_graphics::prelude::{Drawable, Point, RgbColor, Size};
-use embedded_graphics::primitives::Primitive;
-use embedded_graphics::primitives::{PrimitiveStyle, Rectangle};
-use embedded_graphics::Pixel;
-use embedded_graphics::{draw_target::DrawTarget, prelude::OriginDimensions};
-use oorandom; //random generator
-
-struct Snake<T: PixelColor, const MAX_SIZE: usize> {
-    parts: [Pixel<T>; MAX_SIZE],
-    len: usize,
-    direction: Direction,
-    size_x: u32,
-    size_y: u32,
-}
-
-struct SnakeIntoIterator<'a, T: PixelColor, const MAX_SIZE: usize> {
-    snake: &'a Snake<T, MAX_SIZE>,
-    index: usize,
-}
-
-impl<'a, T: PixelColor, const MAX_SIZE: usize> IntoIterator for &'a Snake<T, MAX_SIZE> {
-    type Item = Pixel<T>;
-    type IntoIter = SnakeIntoIterator<'a, T, MAX_SIZE>;
-
-    fn into_iter(self) -> Self::IntoIter {
-        SnakeIntoIterator {
-            snake: self,
-            index: 0,
-        }
-    }
-}
-
-impl<'a, T: PixelColor, const MAX_SIZE: usize> Iterator for SnakeIntoIterator<'a, T, MAX_SIZE> {
-    type Item = Pixel<T>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        let cur = self.snake.parts[self.index];
-        if self.index < self.snake.len {
-            self.index += 1;
-            return Some(cur);
-        }
-        None
-    }
-}
-
-impl<T: PixelColor, const MAX_SIZE: usize> Snake<T, MAX_SIZE> {
-    fn new(color: T, size_x: u32, size_y: u32) -> Snake<T, MAX_SIZE> {
-        Snake {
-            parts: [Pixel::<T>(Point { x: 0, y: 0 }, color); MAX_SIZE],
-            len: 1,
-            direction: Direction::None,
-            size_x,
-            size_y,
-        }
-    }
-    fn set_direction(&mut self, direction: Direction) {
-        self.direction = direction;
-    }
-    fn contains(&self, this: Point) -> bool {
-        for part in self.into_iter() {
-            if part.0 == this {
-                return true;
-            };
-        }
-        false
-    }
-    fn grow(&mut self) {
-        if self.len < MAX_SIZE - 1 {
-            self.len += 1;
-        }
-    }
-    fn make_step(&mut self) {
-        let mut i = self.len;
-        while i > 0 {
-            self.parts[i] = self.parts[i - 1];
-            i -= 1;
-        }
-        match self.direction {
-            Direction::Left => {
-                if self.parts[0].0.x == 0 {
-                    self.parts[0].0.x = (self.size_x - 1) as i32;
-                } else {
-                    self.parts[0].0.x -= 1;
-                }
-            }
-            Direction::Right => {
-                if self.parts[0].0.x == (self.size_x - 1) as i32 {
-                    self.parts[0].0.x = 0;
-                } else {
-                    self.parts[0].0.x += 1;
-                }
-            }
-            Direction::Up => {
-                if self.parts[0].0.y == 0 {
-                    self.parts[0].0.y = (self.size_y - 1) as i32;
-                } else {
-                    self.parts[0].0.y -= 1;
-                }
-            }
-            Direction::Down => {
-                if self.parts[0].0.y == (self.size_y - 1) as i32 {
-                    self.parts[0].0.y = 0;
-                } else {
-                    self.parts[0].0.y += 1;
-                }
-            }
-            Direction::None => {}
-        }
-    }
-}
-
-struct Food<T: PixelColor> {
-    size_x: u32,
-    size_y: u32,
-    place: Pixel<T>,
-    rng: oorandom::Rand32,
-}
-
-impl<T: PixelColor> Food<T> {
-    pub fn new(color: T, size_x: u32, size_y: u32) -> Self {
-        let seed = 4;
-        let rng = oorandom::Rand32::new(seed);
-        Food {
-            size_x,
-            size_y,
-            place: Pixel(Point { x: 0, y: 0 }, color),
-            rng,
-        }
-    }
-    fn replace<'a, const MAX_SIZE: usize>(&mut self, iter_source: &Snake<T, MAX_SIZE>) {
-        let mut p: Point;
-        'outer: loop {
-            let random_number = self.rng.rand_u32();
-            let blocked_positions = iter_source.into_iter();
-            p = Point {
-                x: ((random_number >> 24) as u16 % self.size_x as u16).into(),
-                y: ((random_number >> 16) as u16 % self.size_y as u16).into(),
-            };
-            for blocked_position in blocked_positions {
-                if p == blocked_position.0 {
-                    continue 'outer;
-                }
-            }
-            break;
-        }
-        self.place = Pixel::<T> {
-            0: p,
-            1: self.place.1,
-        }
-    }
-    fn get_pixel(&self) -> Pixel<T> {
-        self.place
-    }
-}
-
-#[derive(PartialEq, Debug, Clone, Copy)]
-pub enum Direction {
-    Left,
-    Right,
-    Up,
-    Down,
-    None,
-}
-
-pub struct SnakeGame<const MAX_SNAKE_SIZE: usize, T: PixelColor> {
-    snake: Snake<T, MAX_SNAKE_SIZE>,
-    food: Food<T>,
-    food_age: u32,
-    food_lifetime: u32,
-    size_x: u32,
-    size_y: u32,
-    scale_x: u32,
-    scale_y: u32,
-}
-
-impl<const MAX_SIZE: usize, T: PixelColor> SnakeGame<MAX_SIZE, T> {
-    pub fn new(
-        size_x: u32,
-        size_y: u32,
-        scale_x: u32,
-        scale_y: u32,
-        snake_color: T,
-        food_color: T,
-        food_lifetime: u32,
-    ) -> Self {
-        let snake = Snake::<T, MAX_SIZE>::new(snake_color, size_x / scale_x, size_y / scale_y);
-        let mut food = Food::<T>::new(food_color, size_x / scale_x, size_y / scale_y);
-        food.replace(&snake);
-        SnakeGame {
-            snake,
-            food,
-            food_age: 0,
-            food_lifetime,
-            size_x,
-            size_y,
-            scale_x,
-            scale_y,
-        }
-    }
-    pub fn set_direction(&mut self, direction: Direction) {
-        self.snake.set_direction(direction);
-    }
-    pub fn draw<D>(&mut self, target: &mut D) -> ()
-    where
-        D: DrawTarget<Color = T>,
-    {
-        self.snake.make_step();
-        let hit = self.snake.contains(self.food.get_pixel().0);
-        if hit {
-            self.snake.grow();
-        }
-        self.food_age += 1;
-        if self.food_age >= self.food_lifetime || hit {
-            self.food.replace(&self.snake);
-            self.food_age = 0;
-        }
-
-        let mut scaled_display = ScaledDisplay::<D> {
-            real_display: target,
-            size_x: self.size_x / self.scale_x,
-            size_y: self.size_y / self.scale_y,
-            scale_x: self.scale_x,
-            scale_y: self.scale_y,
-        };
-
-        for part in self.snake.into_iter() {
-            _ = part.draw(&mut scaled_display);
-        }
-        _ = self.food.get_pixel().draw(&mut scaled_display);
-    }
-}
-
-/// A dummy DrawTarget implementation that can magnify each pixel so the user code does not need to adapt for scaling things
-struct ScaledDisplay<'a, T: DrawTarget> {
-    real_display: &'a mut T,
-    size_x: u32,
-    size_y: u32,
-    scale_x: u32,
-    scale_y: u32,
-}
-
-impl<'a, T: DrawTarget> DrawTarget for ScaledDisplay<'a, T> {
-    type Color = T::Color;
-    type Error = T::Error;
-
-    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
-    where
-        I: IntoIterator<Item = Pixel<Self::Color>>,
-    {
-        for pixel in pixels {
-            let style = PrimitiveStyle::with_fill(pixel.1);
-            Rectangle::new(
-                Point::new(
-                    pixel.0.x * self.scale_x as i32,
-                    pixel.0.y * self.scale_y as i32,
-                ),
-                Size::new(self.scale_x as u32, self.scale_y as u32),
-            )
-            .into_styled(style)
-            .draw(self.real_display)?;
-        }
-        Ok(())
-    }
-}
-
-impl<'a, T: DrawTarget> OriginDimensions for ScaledDisplay<'a, T> {
-    fn size(&self) -> Size {
-        Size::new(self.size_x as u32, self.size_y as u32)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-
-    use crate::Snake;
-    use embedded_graphics::pixelcolor::*;
-    use embedded_graphics::prelude::*;
-
-    #[test]
-    fn snake_basic() {
-        let mut snake = Snake::<Rgb888, 20>::new(Rgb888::RED, 8, 8);
-        snake.set_direction(crate::Direction::Right);
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 0, y: 0 }, Rgb888::RED),
-            snake.into_iter().next().unwrap()
-        );
-        snake.make_step();
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 1, y: 0 }, Rgb888::RED),
-            snake.into_iter().nth(0).unwrap()
-        );
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 0, y: 0 }, Rgb888::RED),
-            snake.into_iter().nth(1).unwrap()
-        );
-        snake.set_direction(crate::Direction::Down);
-        snake.make_step();
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 1, y: 1 }, Rgb888::RED),
-            snake.into_iter().nth(0).unwrap()
-        );
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 1, y: 0 }, Rgb888::RED),
-            snake.into_iter().nth(1).unwrap()
-        );
-        assert_eq!(
-            Pixel::<Rgb888>(Point { x: 0, y: 0 }, Rgb888::RED),
-            snake.into_iter().nth(2).unwrap()
-        );
-        assert_eq!(true, snake.contains(Point { x: 0, y: 0 }));
-        assert_eq!(true, snake.contains(Point { x: 1, y: 0 }));
-        assert_eq!(true, snake.contains(Point { x: 1, y: 1 }));
-    }
-}
-
-const LF: u8 = 0x0au8;
-const CR: u8 = 0x0du8;
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut disp = Display::new(Size::new(VIRTGPU_XRES, VIRTGPU_YRES));
-    let mut game = SnakeGame::<20, Rgb888>::new(1280, 800, 20, 20, Rgb888::RED, Rgb888::YELLOW, 50);
-    let _ = disp.clear(Rgb888::BLACK).unwrap();
-    loop {
-        if key_pressed() {
-            let c = getchar();
-            match c {
-                LF => break,
-                CR => break,
-                b'w' => game.set_direction(Direction::Up),
-                b's' => game.set_direction(Direction::Down),
-                b'a' => game.set_direction(Direction::Left),
-                b'd' => game.set_direction(Direction::Right),
-                _ => (),
-            }
-        }
-        let _ = disp.clear(Rgb888::BLACK).unwrap();
-        game.draw(&mut disp);
-        sleep(10);
-    }
-    0
-}
diff --git a/user/src/bin/gui_uart.rs b/user/src/bin/gui_uart.rs
deleted file mode 100644
index 8e9c9b8..0000000
--- a/user/src/bin/gui_uart.rs
+++ /dev/null
@@ -1,125 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use user_lib::console::getchar;
-use user_lib::{framebuffer, framebuffer_flush};
-
-use embedded_graphics::pixelcolor::Rgb888;
-use embedded_graphics::prelude::{Drawable, Point, RgbColor, Size};
-use embedded_graphics::primitives::Primitive;
-use embedded_graphics::primitives::{PrimitiveStyle, Rectangle};
-use embedded_graphics::{draw_target::DrawTarget, prelude::OriginDimensions};
-
-pub const VIRTGPU_XRES: usize = 1280;
-pub const VIRTGPU_YRES: usize = 800;
-pub const VIRTGPU_LEN: usize = VIRTGPU_XRES * VIRTGPU_YRES * 4;
-
-const INIT_X: i32 = 640;
-const INIT_Y: i32 = 400;
-const RECT_SIZE: u32 = 40;
-
-pub struct Display {
-    pub size: Size,
-    pub point: Point,
-    //pub fb: Arc<&'static mut [u8]>,
-    pub fb: &'static mut [u8],
-}
-
-impl Display {
-    pub fn new(size: Size, point: Point) -> Self {
-        let fb_ptr = framebuffer() as *mut u8;
-        println!(
-            "Hello world from user mode program! 0x{:X} , len {}",
-            fb_ptr as usize, VIRTGPU_LEN
-        );
-        let fb =
-            unsafe { core::slice::from_raw_parts_mut(fb_ptr as *mut u8, VIRTGPU_LEN as usize) };
-        Self { size, point, fb }
-    }
-}
-
-impl OriginDimensions for Display {
-    fn size(&self) -> Size {
-        self.size
-    }
-}
-
-impl DrawTarget for Display {
-    type Color = Rgb888;
-
-    type Error = core::convert::Infallible;
-
-    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
-    where
-        I: IntoIterator<Item = embedded_graphics::Pixel<Self::Color>>,
-    {
-        pixels.into_iter().for_each(|px| {
-            let idx = ((self.point.y + px.0.y) * VIRTGPU_XRES as i32 + self.point.x + px.0.x)
-                as usize
-                * 4;
-            if idx + 2 >= self.fb.len() {
-                return;
-            }
-            self.fb[idx] = px.1.b();
-            self.fb[idx + 1] = px.1.g();
-            self.fb[idx + 2] = px.1.r();
-        });
-        framebuffer_flush();
-        Ok(())
-    }
-}
-
-pub struct DrawingBoard {
-    disp: Display,
-    latest_pos: Point,
-}
-
-impl DrawingBoard {
-    pub fn new() -> Self {
-        Self {
-            disp: Display::new(Size::new(1280, 800), Point::new(0, 0)),
-            latest_pos: Point::new(INIT_X, INIT_Y),
-        }
-    }
-    fn paint(&mut self) {
-        Rectangle::with_center(self.latest_pos, Size::new(RECT_SIZE, RECT_SIZE))
-            .into_styled(PrimitiveStyle::with_stroke(Rgb888::WHITE, 1))
-            .draw(&mut self.disp)
-            .ok();
-    }
-    fn unpaint(&mut self) {
-        Rectangle::with_center(self.latest_pos, Size::new(RECT_SIZE, RECT_SIZE))
-            .into_styled(PrimitiveStyle::with_stroke(Rgb888::BLACK, 1))
-            .draw(&mut self.disp)
-            .ok();
-    }
-    pub fn move_rect(&mut self, dx: i32, dy: i32) {
-        self.unpaint();
-        self.latest_pos.x += dx;
-        self.latest_pos.y += dy;
-        self.paint();
-    }
-}
-
-const LF: u8 = 0x0au8;
-const CR: u8 = 0x0du8;
-#[no_mangle]
-pub fn main() -> i32 {
-    // let fb_ptr = framebuffer() as *mut u8;
-    let mut board = DrawingBoard::new();
-    let _ = board.disp.clear(Rgb888::BLACK).unwrap();
-    for i in 0..20 {
-        let c = getchar();
-        if c == LF || c == CR {
-            break;
-        }
-        board.latest_pos.x += i;
-        board.latest_pos.y += i;
-        board.paint();
-    }
-    0
-}
diff --git a/user/src/bin/hello_world.rs b/user/src/bin/hello_world.rs
deleted file mode 100644
index 2ba7f91..0000000
--- a/user/src/bin/hello_world.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("Hello world from user mode program!");
-    0
-}
diff --git a/user/src/bin/huge_write.rs b/user/src/bin/huge_write.rs
deleted file mode 100644
index dd9814a..0000000
--- a/user/src/bin/huge_write.rs
+++ /dev/null
@@ -1,33 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{close, get_time, open, write, OpenFlags};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut buffer = [0u8; 1024]; // 1KiB
-    for (i, ch) in buffer.iter_mut().enumerate() {
-        *ch = i as u8;
-    }
-    let f = open("testf\0", OpenFlags::CREATE | OpenFlags::WRONLY);
-    if f < 0 {
-        panic!("Open test file failed!");
-    }
-    let f = f as usize;
-    let start = get_time();
-    let size_mb = 1usize;
-    for _ in 0..1024 * size_mb {
-        write(f, &buffer);
-    }
-    close(f);
-    let time_ms = (get_time() - start) as usize;
-    let speed_kbs = (size_mb << 20) / time_ms;
-    println!(
-        "{}MiB written, time cost = {}ms, write speed = {}KiB/s",
-        size_mb, time_ms, speed_kbs
-    );
-    0
-}
diff --git a/user/src/bin/huge_write_mt.rs b/user/src/bin/huge_write_mt.rs
deleted file mode 100644
index c2e1e65..0000000
--- a/user/src/bin/huge_write_mt.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::{fmt::format, vec::Vec};
-use user_lib::{close, get_time, gettid, open, write, OpenFlags};
-use user_lib::{exit, thread_create, waittid};
-
-fn worker(size_kib: usize) {
-    let mut buffer = [0u8; 1024]; // 1KiB
-    for (i, ch) in buffer.iter_mut().enumerate() {
-        *ch = i as u8;
-    }
-    let filename = format(format_args!("testf{}\0", gettid()));
-    let f = open(filename.as_str(), OpenFlags::CREATE | OpenFlags::WRONLY);
-    if f < 0 {
-        panic!("Open test file failed!");
-    }
-    let f = f as usize;
-    for _ in 0..size_kib {
-        write(f, &buffer);
-    }
-    close(f);
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    assert_eq!(argc, 2, "wrong argument");
-    let size_mb = 1usize;
-    let size_kb = size_mb << 10;
-    let workers = argv[1].parse::<usize>().expect("wrong argument");
-    assert!(workers >= 1 && size_kb % workers == 0, "wrong argument");
-
-    let start = get_time();
-
-    let mut v = Vec::new();
-    let size_mb = 1usize;
-    for _ in 0..workers {
-        v.push(thread_create(worker as usize, size_kb / workers));
-    }
-    for tid in v.iter() {
-        assert_eq!(0, waittid(*tid as usize));
-    }
-
-    let time_ms = (get_time() - start) as usize;
-    let speed_kbs = size_kb * 1000 / time_ms;
-    println!(
-        "{}MiB written by {} threads, time cost = {}ms, write speed = {}KiB/s",
-        size_mb, workers, time_ms, speed_kbs
-    );
-    0
-}
diff --git a/user/src/bin/infloop.rs b/user/src/bin/infloop.rs
deleted file mode 100644
index 9a38a09..0000000
--- a/user/src/bin/infloop.rs
+++ /dev/null
@@ -1,10 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::empty_loop)]
-
-extern crate user_lib;
-
-#[no_mangle]
-pub fn main(_argc: usize, _argv: &[&str]) -> ! {
-    loop {}
-}
diff --git a/user/src/bin/initproc.rs b/user/src/bin/initproc.rs
deleted file mode 100644
index 6989f29..0000000
--- a/user/src/bin/initproc.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use user_lib::{exec, fork, wait, yield_};
-
-#[no_mangle]
-fn main() -> i32 {
-    if fork() == 0 {
-        exec("user_shell\0", &[core::ptr::null::<u8>()]);
-    } else {
-        loop {
-            let mut exit_code: i32 = 0;
-            let pid = wait(&mut exit_code);
-            if pid == -1 {
-                yield_();
-                continue;
-            }
-            /*
-            println!(
-                "[initproc] Released a zombie process, pid={}, exit_code={}",
-                pid,
-                exit_code,
-            );
-            */
-        }
-    }
-    0
-}
diff --git a/user/src/bin/inputdev_event.rs b/user/src/bin/inputdev_event.rs
deleted file mode 100644
index ea56f3a..0000000
--- a/user/src/bin/inputdev_event.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-#![no_std]
-#![no_main]
-
-use user_lib::{event_get, DecodeType, Key, KeyType};
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("Input device event test");
-    loop {
-        if let Some(event) = event_get() {
-            if let Some(decoder_type) = event.decode() {
-                println!("{:?}", decoder_type);
-                if let DecodeType::Key(key, keytype) = decoder_type {
-                    if key == Key::Enter && keytype == KeyType::Press {
-                        break;
-                    }
-                }
-            }
-        }
-    }
-    0
-}
diff --git a/user/src/bin/matrix.rs b/user/src/bin/matrix.rs
deleted file mode 100644
index 1909124..0000000
--- a/user/src/bin/matrix.rs
+++ /dev/null
@@ -1,69 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::needless_range_loop)]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, get_time, getpid, wait, yield_};
-
-static NUM: usize = 30;
-const N: usize = 10;
-static P: i32 = 10007;
-type Arr = [[i32; N]; N];
-
-fn work(times: isize) {
-    let mut a: Arr = Default::default();
-    let mut b: Arr = Default::default();
-    let mut c: Arr = Default::default();
-    for i in 0..N {
-        for j in 0..N {
-            a[i][j] = 1;
-            b[i][j] = 1;
-        }
-    }
-    yield_();
-    println!("pid {} is running ({} times)!.", getpid(), times);
-    for _ in 0..times {
-        for i in 0..N {
-            for j in 0..N {
-                c[i][j] = 0;
-                for k in 0..N {
-                    c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % P;
-                }
-            }
-        }
-        for i in 0..N {
-            for j in 0..N {
-                a[i][j] = c[i][j];
-                b[i][j] = c[i][j];
-            }
-        }
-    }
-    println!("pid {} done!.", getpid());
-    exit(0);
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for _ in 0..NUM {
-        let pid = fork();
-        if pid == 0 {
-            let current_time = get_time();
-            let times = (current_time as i32 as isize) * (current_time as i32 as isize) % 1000;
-            work(times * 10);
-        }
-    }
-
-    println!("fork ok.");
-
-    let mut exit_code: i32 = 0;
-    for _ in 0..NUM {
-        if wait(&mut exit_code) < 0 {
-            panic!("wait failed.");
-        }
-    }
-    assert!(wait(&mut exit_code) < 0);
-    println!("matrix passed.");
-    0
-}
diff --git a/user/src/bin/mpsc_sem.rs b/user/src/bin/mpsc_sem.rs
deleted file mode 100644
index 861f3db..0000000
--- a/user/src/bin/mpsc_sem.rs
+++ /dev/null
@@ -1,73 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::println_empty_string)]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::exit;
-use user_lib::{semaphore_create, semaphore_down, semaphore_up};
-use user_lib::{thread_create, waittid};
-
-const SEM_MUTEX: usize = 0;
-const SEM_EMPTY: usize = 1;
-const SEM_AVAIL: usize = 2;
-const BUFFER_SIZE: usize = 8;
-static mut BUFFER: [usize; BUFFER_SIZE] = [0; BUFFER_SIZE];
-static mut FRONT: usize = 0;
-static mut TAIL: usize = 0;
-const PRODUCER_COUNT: usize = 4;
-const NUMBER_PER_PRODUCER: usize = 100;
-
-unsafe fn producer(id: *const usize) -> ! {
-    let id = *id;
-    for _ in 0..NUMBER_PER_PRODUCER {
-        semaphore_down(SEM_EMPTY);
-        semaphore_down(SEM_MUTEX);
-        BUFFER[TAIL] = id;
-        TAIL = (TAIL + 1) % BUFFER_SIZE;
-        semaphore_up(SEM_MUTEX);
-        semaphore_up(SEM_AVAIL);
-    }
-    exit(0)
-}
-
-unsafe fn consumer() -> ! {
-    for _ in 0..PRODUCER_COUNT * NUMBER_PER_PRODUCER {
-        semaphore_down(SEM_AVAIL);
-        semaphore_down(SEM_MUTEX);
-        print!("{} ", BUFFER[FRONT]);
-        FRONT = (FRONT + 1) % BUFFER_SIZE;
-        semaphore_up(SEM_MUTEX);
-        semaphore_up(SEM_EMPTY);
-    }
-    println!("");
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create semaphores
-    assert_eq!(semaphore_create(1) as usize, SEM_MUTEX);
-    assert_eq!(semaphore_create(BUFFER_SIZE) as usize, SEM_EMPTY);
-    assert_eq!(semaphore_create(0) as usize, SEM_AVAIL);
-    // create threads
-    let ids: Vec<_> = (0..PRODUCER_COUNT).collect();
-    let mut threads = Vec::new();
-    for i in 0..PRODUCER_COUNT {
-        threads.push(thread_create(
-            producer as usize,
-            &ids.as_slice()[i] as *const _ as usize,
-        ));
-    }
-    threads.push(thread_create(consumer as usize, 0));
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("mpsc_sem passed!");
-    0
-}
diff --git a/user/src/bin/peterson.rs b/user/src/bin/peterson.rs
deleted file mode 100644
index ee8ff93..0000000
--- a/user/src/bin/peterson.rs
+++ /dev/null
@@ -1,80 +0,0 @@
-#![no_std]
-#![no_main]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-extern crate core;
-
-use alloc::vec::Vec;
-use core::sync::atomic::{AtomicUsize, Ordering};
-use user_lib::{exit, sleep, thread_create, waittid};
-const N: usize = 1000;
-
-static mut TURN: usize = 0;
-static mut FLAG: [bool; 2] = [false; 2];
-static GUARD: AtomicUsize = AtomicUsize::new(0);
-
-fn critical_test_enter() {
-    assert_eq!(GUARD.fetch_add(1, Ordering::SeqCst), 0);
-}
-
-fn critical_test_claim() {
-    assert_eq!(GUARD.load(Ordering::SeqCst), 1);
-}
-
-fn critical_test_exit() {
-    assert_eq!(GUARD.fetch_sub(1, Ordering::SeqCst), 1);
-}
-
-fn peterson_enter_critical(id: usize, peer_id: usize) {
-    // println!("Thread[{}] try enter", id);
-    vstore!(&FLAG[id], true);
-    vstore!(&TURN, peer_id);
-    memory_fence!();
-    while vload!(&FLAG[peer_id]) && vload!(&TURN) == peer_id {
-        // println!("Thread[{}] enter fail", id);
-        sleep(1);
-        // println!("Thread[{}] retry enter", id);
-    }
-    // println!("Thread[{}] enter", id);
-}
-
-fn peterson_exit_critical(id: usize) {
-    vstore!(&FLAG[id], false);
-    // println!("Thread[{}] exit", id);
-}
-
-pub fn thread_fn(id: usize) -> ! {
-    // println!("Thread[{}] init.", id);
-    let peer_id: usize = id ^ 1;
-    for iter in 0..N {
-        if iter % 10 == 0 {
-            println!("[{}] it={}", id, iter);
-        }
-        peterson_enter_critical(id, peer_id);
-        critical_test_enter();
-        for _ in 0..3 {
-            critical_test_claim();
-            sleep(2);
-        }
-        critical_test_exit();
-        peterson_exit_critical(id);
-    }
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v = Vec::new();
-    v.push(thread_create(thread_fn as usize, 0));
-    // v.push(thread_create(thread_fn as usize, 1));
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        assert_eq!(exit_code, 0, "thread conflict happened!");
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    0
-}
diff --git a/user/src/bin/phil_din_mutex.rs b/user/src/bin/phil_din_mutex.rs
deleted file mode 100644
index c2815de..0000000
--- a/user/src/bin/phil_din_mutex.rs
+++ /dev/null
@@ -1,107 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::println_empty_string)]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, sleep};
-use user_lib::{mutex_blocking_create, mutex_lock, mutex_unlock};
-use user_lib::{thread_create, waittid};
-
-const N: usize = 5;
-const ROUND: usize = 4;
-// A round: think -> wait for forks -> eat
-const GRAPH_SCALE: usize = 100;
-
-fn get_time_u() -> usize {
-    get_time() as usize
-}
-
-// Time unit: ms
-const ARR: [[usize; ROUND * 2]; N] = [
-    [700, 800, 1000, 400, 500, 600, 200, 400],
-    [300, 600, 200, 700, 1000, 100, 300, 600],
-    [500, 200, 900, 200, 400, 600, 1200, 400],
-    [500, 1000, 600, 500, 800, 600, 200, 900],
-    [600, 100, 600, 600, 200, 500, 600, 200],
-];
-static mut THINK: [[usize; ROUND * 2]; N] = [[0; ROUND * 2]; N];
-static mut EAT: [[usize; ROUND * 2]; N] = [[0; ROUND * 2]; N];
-
-fn philosopher_dining_problem(id: *const usize) {
-    let id = unsafe { *id };
-    let left = id;
-    let right = if id == N - 1 { 0 } else { id + 1 };
-    let min = if left < right { left } else { right };
-    let max = left + right - min;
-    for round in 0..ROUND {
-        // thinking
-        unsafe {
-            THINK[id][2 * round] = get_time_u();
-        }
-        sleep(ARR[id][2 * round]);
-        unsafe {
-            THINK[id][2 * round + 1] = get_time_u();
-        }
-        // wait for forks
-        mutex_lock(min);
-        mutex_lock(max);
-        // eating
-        unsafe {
-            EAT[id][2 * round] = get_time_u();
-        }
-        sleep(ARR[id][2 * round + 1]);
-        unsafe {
-            EAT[id][2 * round + 1] = get_time_u();
-        }
-        mutex_unlock(max);
-        mutex_unlock(min);
-    }
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v = Vec::new();
-    let ids: Vec<_> = (0..N).collect();
-    let start = get_time_u();
-    for i in 0..N {
-        assert_eq!(mutex_blocking_create(), i as isize);
-        v.push(thread_create(
-            philosopher_dining_problem as usize,
-            &ids.as_slice()[i] as *const _ as usize,
-        ));
-    }
-    for tid in v.iter() {
-        waittid(*tid as usize);
-    }
-    let time_cost = get_time_u() - start;
-    println!("time cost = {}", time_cost);
-    println!("'-' -> THINKING; 'x' -> EATING; ' ' -> WAITING ");
-    for id in (0..N).into_iter().chain(0..=0) {
-        print!("#{}:", id);
-        for j in 0..time_cost / GRAPH_SCALE {
-            let current_time = j * GRAPH_SCALE + start;
-            if (0..ROUND).any(|round| unsafe {
-                let start_thinking = THINK[id][2 * round];
-                let end_thinking = THINK[id][2 * round + 1];
-                start_thinking <= current_time && current_time <= end_thinking
-            }) {
-                print!("-");
-            } else if (0..ROUND).any(|round| unsafe {
-                let start_eating = EAT[id][2 * round];
-                let end_eating = EAT[id][2 * round + 1];
-                start_eating <= current_time && current_time <= end_eating
-            }) {
-                print!("x");
-            } else {
-                print!(" ");
-            };
-        }
-        println!("");
-    }
-    0
-}
diff --git a/user/src/bin/pipe_large_test.rs b/user/src/bin/pipe_large_test.rs
deleted file mode 100644
index eeddbf1..0000000
--- a/user/src/bin/pipe_large_test.rs
+++ /dev/null
@@ -1,71 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::format;
-use user_lib::{close, fork, get_time, pipe, read, wait, write};
-
-const LENGTH: usize = 3000;
-#[no_mangle]
-pub fn main() -> i32 {
-    // create pipes
-    // parent write to child
-    let mut down_pipe_fd = [0usize; 2];
-    // child write to parent
-    let mut up_pipe_fd = [0usize; 2];
-    pipe(&mut down_pipe_fd);
-    pipe(&mut up_pipe_fd);
-    let mut random_str = [0u8; LENGTH];
-    if fork() == 0 {
-        // close write end of down pipe
-        close(down_pipe_fd[1]);
-        // close read end of up pipe
-        close(up_pipe_fd[0]);
-        assert_eq!(read(down_pipe_fd[0], &mut random_str) as usize, LENGTH);
-        close(down_pipe_fd[0]);
-        let sum: usize = random_str.iter().map(|v| *v as usize).sum::<usize>();
-        println!("sum = {}(child)", sum);
-        let sum_str = format!("{}", sum);
-        write(up_pipe_fd[1], sum_str.as_bytes());
-        close(up_pipe_fd[1]);
-        println!("Child process exited!");
-        0
-    } else {
-        // close read end of down pipe
-        close(down_pipe_fd[0]);
-        // close write end of up pipe
-        close(up_pipe_fd[1]);
-        // generate a long random string
-        for ch in random_str.iter_mut() {
-            *ch = get_time() as u8;
-        }
-        // send it
-        assert_eq!(
-            write(down_pipe_fd[1], &random_str) as usize,
-            random_str.len()
-        );
-        // close write end of down pipe
-        close(down_pipe_fd[1]);
-        // calculate sum(parent)
-        let sum: usize = random_str.iter().map(|v| *v as usize).sum::<usize>();
-        println!("sum = {}(parent)", sum);
-        // recv sum(child)
-        let mut child_result = [0u8; 32];
-        let result_len = read(up_pipe_fd[0], &mut child_result) as usize;
-        close(up_pipe_fd[0]);
-        // check
-        assert_eq!(
-            sum,
-            str::parse::<usize>(core::str::from_utf8(&child_result[..result_len]).unwrap())
-                .unwrap()
-        );
-        let mut _unused: i32 = 0;
-        wait(&mut _unused);
-        println!("pipe_large_test passed!");
-        0
-    }
-}
diff --git a/user/src/bin/pipetest.rs b/user/src/bin/pipetest.rs
deleted file mode 100644
index 4a840d6..0000000
--- a/user/src/bin/pipetest.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{close, fork, pipe, read, wait, write};
-
-static STR: &str = "Hello, world!";
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create pipe
-    let mut pipe_fd = [0usize; 2];
-    pipe(&mut pipe_fd);
-    // read end
-    assert_eq!(pipe_fd[0], 3);
-    // write end
-    assert_eq!(pipe_fd[1], 4);
-    if fork() == 0 {
-        // child process, read from parent
-        // close write_end
-        close(pipe_fd[1]);
-        let mut buffer = [0u8; 32];
-        let len_read = read(pipe_fd[0], &mut buffer) as usize;
-        // close read_end
-        close(pipe_fd[0]);
-        assert_eq!(core::str::from_utf8(&buffer[..len_read]).unwrap(), STR);
-        println!("Read OK, child process exited!");
-        0
-    } else {
-        // parent process, write to child
-        // close read end
-        close(pipe_fd[0]);
-        assert_eq!(write(pipe_fd[1], STR.as_bytes()), STR.len() as isize);
-        // close write end
-        close(pipe_fd[1]);
-        let mut child_exit_code: i32 = 0;
-        wait(&mut child_exit_code);
-        assert_eq!(child_exit_code, 0);
-        println!("pipetest passed!");
-        0
-    }
-}
diff --git a/user/src/bin/priv_csr.rs b/user/src/bin/priv_csr.rs
deleted file mode 100644
index 397e339..0000000
--- a/user/src/bin/priv_csr.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use riscv::register::sstatus::{self, SPP};
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Try to access privileged CSR in U Mode");
-    println!("Kernel should kill this application!");
-    unsafe {
-        sstatus::set_spp(SPP::User);
-    }
-    0
-}
diff --git a/user/src/bin/priv_inst.rs b/user/src/bin/priv_inst.rs
deleted file mode 100644
index f37595b..0000000
--- a/user/src/bin/priv_inst.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use core::arch::asm;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Try to execute privileged instruction in U Mode");
-    println!("Kernel should kill this application!");
-    unsafe {
-        asm!("sret");
-    }
-    0
-}
diff --git a/user/src/bin/race_adder_arg.rs b/user/src/bin/race_adder_arg.rs
deleted file mode 100644
index 988de77..0000000
--- a/user/src/bin/race_adder_arg.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use crate::alloc::string::ToString;
-use alloc::vec::Vec;
-use user_lib::{exit, get_time, thread_create, waittid};
-
-static mut A: usize = 0;
-const PER_THREAD: usize = 1000;
-const THREAD_COUNT: usize = 16;
-
-unsafe fn f(count: usize) -> ! {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        let a = &mut A as *mut usize;
-        let cur = a.read_volatile();
-        for _ in 0..count {
-            t = t * t % 10007;
-        }
-        a.write_volatile(cur + 1);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    let count: usize;
-    if argc == 1 {
-        count = THREAD_COUNT;
-    } else if argc == 2 {
-        count = argv[1].to_string().parse::<usize>().unwrap();
-    } else {
-        println!(
-            "ERROR in argv, argc is {}, argv[0] {} , argv[1] {} , argv[2] {}",
-            argc, argv[0], argv[1], argv[2]
-        );
-        exit(-1);
-    }
-
-    let start = get_time();
-    let mut v = Vec::new();
-    for _ in 0..THREAD_COUNT {
-        v.push(thread_create(f as usize, count) as usize);
-    }
-    let mut time_cost = Vec::new();
-    for tid in v.iter() {
-        time_cost.push(waittid(*tid));
-    }
-    println!("time cost is {}ms", get_time() - start);
-    assert_eq!(unsafe { A }, PER_THREAD * THREAD_COUNT);
-    0
-}
diff --git a/user/src/bin/random_num.rs b/user/src/bin/random_num.rs
deleted file mode 100644
index d68bb13..0000000
--- a/user/src/bin/random_num.rs
+++ /dev/null
@@ -1,16 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-use oorandom;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("random num  program!");
-    let seed = 4;
-    let mut rng = oorandom::Rand32::new(seed);
-    println!("OORandom: Random number 32bit: {}", rng.rand_i32());
-    println!("OORandom: Random number range: {}", rng.rand_range(1..100));
-    0
-}
diff --git a/user/src/bin/run_pipe_test.rs b/user/src/bin/run_pipe_test.rs
deleted file mode 100644
index 97f3bb9..0000000
--- a/user/src/bin/run_pipe_test.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exec, fork, wait};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for i in 0..5 {
-        if fork() == 0 {
-            exec("pipe_large_test\0", &[core::ptr::null::<u8>()]);
-        } else {
-            let mut _unused: i32 = 0;
-            wait(&mut _unused);
-            println!("Iter {} OK.", i);
-        }
-    }
-    0
-}
diff --git a/user/src/bin/sleep.rs b/user/src/bin/sleep.rs
deleted file mode 100644
index 7fea2fa..0000000
--- a/user/src/bin/sleep.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, get_time, sleep, waitpid};
-
-fn sleepy() {
-    let time: usize = 100;
-    for i in 0..5 {
-        sleep(time);
-        println!("sleep {} x {} msecs.", i + 1, time);
-    }
-    exit(0);
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let current_time = get_time();
-    let pid = fork();
-    let mut exit_code: i32 = 0;
-    if pid == 0 {
-        sleepy();
-    }
-    assert!(waitpid(pid as usize, &mut exit_code) == pid && exit_code == 0);
-    println!("use {} msecs.", get_time() - current_time);
-    println!("sleep pass.");
-    0
-}
diff --git a/user/src/bin/sleep_simple.rs b/user/src/bin/sleep_simple.rs
deleted file mode 100644
index 624efbe..0000000
--- a/user/src/bin/sleep_simple.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{get_time, sleep};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("into sleep test!");
-    let start = get_time();
-    println!("current time_msec = {}", start);
-    sleep(100);
-    let end = get_time();
-    println!(
-        "time_msec = {} after sleeping 100 ticks, delta = {}ms!",
-        end,
-        end - start
-    );
-    println!("r_sleep passed!");
-    0
-}
diff --git a/user/src/bin/stack_overflow.rs b/user/src/bin/stack_overflow.rs
deleted file mode 100644
index cd6cdff..0000000
--- a/user/src/bin/stack_overflow.rs
+++ /dev/null
@@ -1,20 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[allow(unconditional_recursion)]
-fn f(depth: usize) {
-    if depth % 10 == 0 {
-        println!("depth = {}", depth);
-    }
-    f(depth + 1);
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("It should trigger segmentation fault!");
-    f(0);
-    0
-}
diff --git a/user/src/bin/stackful_coroutine.rs b/user/src/bin/stackful_coroutine.rs
deleted file mode 100644
index 3f61979..0000000
--- a/user/src/bin/stackful_coroutine.rs
+++ /dev/null
@@ -1,350 +0,0 @@
-// we porting below codes to Rcore Tutorial v3
-// https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/
-// https://github.com/cfsamson/example-greenthreads
-#![no_std]
-#![no_main]
-#![feature(naked_functions)]
-//#![feature(asm)]
-
-extern crate alloc;
-#[macro_use]
-extern crate user_lib;
-
-use core::arch::asm;
-
-//#[macro_use]
-use alloc::vec;
-use alloc::vec::Vec;
-
-use user_lib::exit;
-
-// In our simple example we set most constraints here.
-const DEFAULT_STACK_SIZE: usize = 4096; //128 got  SEGFAULT, 256(1024, 4096) got right results.
-const MAX_TASKS: usize = 5;
-static mut RUNTIME: usize = 0;
-
-pub struct Runtime {
-    tasks: Vec<Task>,
-    current: usize,
-}
-
-#[derive(PartialEq, Eq, Debug)]
-enum State {
-    Available,
-    Running,
-    Ready,
-}
-
-struct Task {
-    id: usize,
-    stack: Vec<u8>,
-    ctx: TaskContext,
-    state: State,
-}
-
-#[derive(Debug, Default)]
-#[repr(C)] // not strictly needed but Rust ABI is not guaranteed to be stable
-pub struct TaskContext {
-    // 15 u64
-    x1: u64,  //ra: return addres
-    x2: u64,  //sp
-    x8: u64,  //s0,fp
-    x9: u64,  //s1
-    x18: u64, //x18-27: s2-11
-    x19: u64,
-    x20: u64,
-    x21: u64,
-    x22: u64,
-    x23: u64,
-    x24: u64,
-    x25: u64,
-    x26: u64,
-    x27: u64,
-    nx1: u64, //new return addres
-}
-
-impl Task {
-    fn new(id: usize) -> Self {
-        // We initialize each task here and allocate the stack. This is not neccesary,
-        // we can allocate memory for it later, but it keeps complexity down and lets us focus on more interesting parts
-        // to do it here. The important part is that once allocated it MUST NOT move in memory.
-        Task {
-            id: id,
-            stack: vec![0_u8; DEFAULT_STACK_SIZE],
-            ctx: TaskContext::default(),
-            state: State::Available,
-        }
-    }
-}
-
-impl Runtime {
-    pub fn new() -> Self {
-        // This will be our base task, which will be initialized in the `running` state
-        let base_task = Task {
-            id: 0,
-            stack: vec![0_u8; DEFAULT_STACK_SIZE],
-            ctx: TaskContext::default(),
-            state: State::Running,
-        };
-
-        // We initialize the rest of our tasks.
-        let mut tasks = vec![base_task];
-        let mut available_tasks: Vec<Task> = (1..MAX_TASKS).map(|i| Task::new(i)).collect();
-        tasks.append(&mut available_tasks);
-
-        Runtime { tasks, current: 0 }
-    }
-
-    /// This is cheating a bit, but we need a pointer to our Runtime stored so we can call yield on it even if
-    /// we don't have a reference to it.
-    pub fn init(&self) {
-        unsafe {
-            let r_ptr: *const Runtime = self;
-            RUNTIME = r_ptr as usize;
-        }
-    }
-
-    /// This is where we start running our runtime. If it is our base task, we call yield until
-    /// it returns false (which means that there are no tasks scheduled) and we are done.
-    pub fn run(&mut self) {
-        while self.t_yield() {}
-        println!("All tasks finished!");
-    }
-
-    /// This is our return function. The only place we use this is in our `guard` function.
-    /// If the current task is not our base task we set its state to Available. It means
-    /// we're finished with it. Then we yield which will schedule a new task to be run.
-    fn t_return(&mut self) {
-        if self.current != 0 {
-            self.tasks[self.current].state = State::Available;
-            self.t_yield();
-        }
-    }
-
-    /// This is the heart of our runtime. Here we go through all tasks and see if anyone is in the `Ready` state.
-    /// If no task is `Ready` we're all done. This is an extremely simple scheduler using only a round-robin algorithm.
-    ///
-    /// If we find a task that's ready to be run we change the state of the current task from `Running` to `Ready`.
-    /// Then we call switch which will save the current context (the old context) and load the new context
-    /// into the CPU which then resumes based on the context it was just passed.
-    ///
-    /// NOITCE: if we comment below `#[inline(never)]`, we can not get the corrent running result
-    #[inline(never)]
-    fn t_yield(&mut self) -> bool {
-        let mut pos = self.current;
-        while self.tasks[pos].state != State::Ready {
-            pos += 1;
-            if pos == self.tasks.len() {
-                pos = 0;
-            }
-            if pos == self.current {
-                return false;
-            }
-        }
-
-        if self.tasks[self.current].state != State::Available {
-            self.tasks[self.current].state = State::Ready;
-        }
-
-        self.tasks[pos].state = State::Running;
-        let old_pos = self.current;
-        self.current = pos;
-
-        unsafe {
-            switch(&mut self.tasks[old_pos].ctx, &self.tasks[pos].ctx);
-        }
-
-        // NOTE: this might look strange and it is. Normally we would just mark this as `unreachable!()` but our compiler
-        // is too smart for it's own good so it optimized our code away on release builds. Curiously this happens on windows
-        // and not on linux. This is a common problem in tests so Rust has a `black_box` function in the `test` crate that
-        // will "pretend" to use a value we give it to prevent the compiler from eliminating code. I'll just do this instead,
-        // this code will never be run anyways and if it did it would always be `true`.
-        self.tasks.len() > 0
-    }
-
-    /// While `yield` is the logically interesting function I think this the technically most interesting.
-    ///
-    /// When we spawn a new task we first check if there are any available tasks (tasks in `Parked` state).
-    /// If we run out of tasks we panic in this scenario but there are several (better) ways to handle that.
-    /// We keep things simple for now.
-    ///
-    /// When we find an available task we get the stack length and a pointer to our u8 bytearray.
-    ///
-    /// The next part we have to use some unsafe functions. First we write an address to our `guard` function
-    /// that will be called if the function we provide returns. Then we set the address to the function we
-    /// pass inn.
-    ///
-    /// Third, we set the value of `sp` which is the stack pointer to the address of our provided function so we start
-    /// executing that first when we are scheuled to run.
-    ///
-    /// Lastly we set the state as `Ready` which means we have work to do and is ready to do it.
-    pub fn spawn(&mut self, f: fn()) {
-        let available = self
-            .tasks
-            .iter_mut()
-            .find(|t| t.state == State::Available)
-            .expect("no available task.");
-
-        println!("RUNTIME: spawning task {}\n", available.id);
-        let size = available.stack.len();
-        unsafe {
-            let s_ptr = available.stack.as_mut_ptr().offset(size as isize);
-
-            // make sure our stack itself is 8 byte aligned - it will always
-            // offset to a lower memory address. Since we know we're at the "high"
-            // memory address of our allocated space, we know that offsetting to
-            // a lower one will be a valid address (given that we actually allocated)
-            // enough space to actually get an aligned pointer in the first place).
-            let s_ptr = (s_ptr as usize & !7) as *mut u8;
-
-            available.ctx.x1 = guard as u64; //ctx.x1  is old return address
-            available.ctx.nx1 = f as u64; //ctx.nx2 is new return address
-            available.ctx.x2 = s_ptr.offset(-32) as u64; //cxt.x2 is sp
-        }
-        available.state = State::Ready;
-    }
-}
-
-/// This is our guard function that we place on top of the stack. All this function does is set the
-/// state of our current task and then `yield` which will then schedule a new task to be run.
-fn guard() {
-    unsafe {
-        let rt_ptr = RUNTIME as *mut Runtime;
-        (*rt_ptr).t_return();
-    };
-}
-
-/// We know that Runtime is alive the length of the program and that we only access from one core
-/// (so no datarace). We yield execution of the current task  by dereferencing a pointer to our
-/// Runtime and then calling `t_yield`
-pub fn yield_task() {
-    unsafe {
-        let rt_ptr = RUNTIME as *mut Runtime;
-        (*rt_ptr).t_yield();
-    };
-}
-
-/// So here is our inline Assembly. As you remember from our first example this is just a bit more elaborate where we first
-/// read out the values of all the registers we need and then sets all the register values to the register values we
-/// saved when we suspended exceution on the "new" task.
-///
-/// This is essentially all we need to do to save and resume execution.
-///
-/// Some details about inline assembly.
-///
-/// The assembly commands in the string literal is called the assemblt template. It is preceeded by
-/// zero or up to four segments indicated by ":":
-///
-/// - First ":" we have our output parameters, this parameters that this function will return.
-/// - Second ":" we have the input parameters which is our contexts. We only read from the "new" context
-/// but we modify the "old" context saving our registers there (see volatile option below)
-/// - Third ":" This our clobber list, this is information to the compiler that these registers can't be used freely
-/// - Fourth ":" This is options we can pass inn, Rust has 3: "alignstack", "volatile" and "intel"
-///
-/// For this to work on windows we need to use "alignstack" where the compiler adds the neccesary padding to
-/// make sure our stack is aligned. Since we modify one of our inputs, our assembly has "side effects"
-/// therefore we should use the `volatile` option. I **think** this is actually set for us by default
-/// when there are no output parameters given (my own assumption after going through the source code)
-/// for the `asm` macro, but we should make it explicit anyway.
-///
-/// One last important part (it will not work without this) is the #[naked] attribute. Basically this lets us have full
-/// control over the stack layout since normal functions has a prologue-and epilogue added by the
-/// compiler that will cause trouble for us. We avoid this by marking the funtion as "Naked".
-/// For this to work on `release` builds we also need to use the `#[inline(never)] attribute or else
-/// the compiler decides to inline this function (curiously this currently only happens on Windows).
-/// If the function is inlined we get a curious runtime error where it fails when switching back
-/// to as saved context and in general our assembly will not work as expected.
-///
-/// see: https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md
-/// see: https://doc.rust-lang.org/nightly/reference/inline-assembly.html
-/// see: https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html
-#[naked]
-#[no_mangle]
-unsafe extern "C" fn switch(old: *mut TaskContext, new: *const TaskContext) {
-    // a0: _old, a1: _new
-    asm!(
-        "
-        sd x1, 0x00(a0)
-        sd x2, 0x08(a0)
-        sd x8, 0x10(a0)
-        sd x9, 0x18(a0)
-        sd x18, 0x20(a0)
-        sd x19, 0x28(a0)
-        sd x20, 0x30(a0)
-        sd x21, 0x38(a0)
-        sd x22, 0x40(a0)
-        sd x23, 0x48(a0)
-        sd x24, 0x50(a0)
-        sd x25, 0x58(a0)
-        sd x26, 0x60(a0)
-        sd x27, 0x68(a0)
-        sd x1, 0x70(a0)
-
-        ld x1, 0x00(a1)
-        ld x2, 0x08(a1)
-        ld x8, 0x10(a1)
-        ld x9, 0x18(a1)
-        ld x18, 0x20(a1)
-        ld x19, 0x28(a1)
-        ld x20, 0x30(a1)
-        ld x21, 0x38(a1)
-        ld x22, 0x40(a1)
-        ld x23, 0x48(a1)
-        ld x24, 0x50(a1)
-        ld x25, 0x58(a1)
-        ld x26, 0x60(a1)
-        ld x27, 0x68(a1)
-        ld t0, 0x70(a1)
-
-        jr t0
-    ",
-        options(noreturn)
-    );
-}
-
-#[no_mangle]
-pub fn main() {
-    println!("stackful_coroutine begin...");
-    println!("TASK  0(Runtime) STARTING");
-    let mut runtime = Runtime::new();
-    runtime.init();
-    runtime.spawn(|| {
-        println!("TASK  1 STARTING");
-        let id = 1;
-        for i in 0..4 {
-            println!("task: {} counter: {}", id, i);
-            yield_task();
-        }
-        println!("TASK 1 FINISHED");
-    });
-    runtime.spawn(|| {
-        println!("TASK 2 STARTING");
-        let id = 2;
-        for i in 0..8 {
-            println!("task: {} counter: {}", id, i);
-            yield_task();
-        }
-        println!("TASK 2 FINISHED");
-    });
-    runtime.spawn(|| {
-        println!("TASK 3 STARTING");
-        let id = 3;
-        for i in 0..12 {
-            println!("task: {} counter: {}", id, i);
-            yield_task();
-        }
-        println!("TASK 3 FINISHED");
-    });
-    runtime.spawn(|| {
-        println!("TASK 4 STARTING");
-        let id = 4;
-        for i in 0..16 {
-            println!("task: {} counter: {}", id, i);
-            yield_task();
-        }
-        println!("TASK 4 FINISHED");
-    });
-    runtime.run();
-    println!("stackful_coroutine PASSED");
-    exit(0);
-}
diff --git a/user/src/bin/stackless_coroutine.rs b/user/src/bin/stackless_coroutine.rs
deleted file mode 100644
index e67cab2..0000000
--- a/user/src/bin/stackless_coroutine.rs
+++ /dev/null
@@ -1,129 +0,0 @@
-// https://blog.aloni.org/posts/a-stack-less-rust-coroutine-100-loc/
-// https://github.com/chyyuu/example-coroutine-and-thread/tree/stackless-coroutine-x86
-#![no_std]
-#![no_main]
-
-use core::future::Future;
-use core::pin::Pin;
-use core::task::{Context, Poll};
-use core::task::{RawWaker, RawWakerVTable, Waker};
-
-extern crate alloc;
-use alloc::collections::VecDeque;
-
-use alloc::boxed::Box;
-
-#[macro_use]
-extern crate user_lib;
-
-enum State {
-    Halted,
-    Running,
-}
-
-struct Task {
-    state: State,
-}
-
-impl Task {
-    fn waiter<'a>(&'a mut self) -> Waiter<'a> {
-        Waiter { task: self }
-    }
-}
-
-struct Waiter<'a> {
-    task: &'a mut Task,
-}
-
-impl<'a> Future for Waiter<'a> {
-    type Output = ();
-
-    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context) -> Poll<Self::Output> {
-        match self.task.state {
-            State::Halted => {
-                self.task.state = State::Running;
-                Poll::Ready(())
-            }
-            State::Running => {
-                self.task.state = State::Halted;
-                Poll::Pending
-            }
-        }
-    }
-}
-
-struct Executor {
-    tasks: VecDeque<Pin<Box<dyn Future<Output = ()>>>>,
-}
-
-impl Executor {
-    fn new() -> Self {
-        Executor {
-            tasks: VecDeque::new(),
-        }
-    }
-
-    fn push<C, F>(&mut self, closure: C)
-    where
-        F: Future<Output = ()> + 'static,
-        C: FnOnce(Task) -> F,
-    {
-        let task = Task {
-            state: State::Running,
-        };
-        self.tasks.push_back(Box::pin(closure(task)));
-    }
-
-    fn run(&mut self) {
-        let waker = create_waker();
-        let mut context = Context::from_waker(&waker);
-
-        while let Some(mut task) = self.tasks.pop_front() {
-            match task.as_mut().poll(&mut context) {
-                Poll::Pending => {
-                    self.tasks.push_back(task);
-                }
-                Poll::Ready(()) => {}
-            }
-        }
-    }
-}
-
-pub fn create_waker() -> Waker {
-    // Safety: The waker points to a vtable with functions that do nothing. Doing
-    // nothing is memory-safe.
-    unsafe { Waker::from_raw(RAW_WAKER) }
-}
-
-const RAW_WAKER: RawWaker = RawWaker::new(core::ptr::null(), &VTABLE);
-const VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake_by_ref, drop);
-
-unsafe fn clone(_: *const ()) -> RawWaker {
-    RAW_WAKER
-}
-unsafe fn wake(_: *const ()) {}
-unsafe fn wake_by_ref(_: *const ()) {}
-unsafe fn drop(_: *const ()) {}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("stackless coroutine Begin..");
-    let mut exec = Executor::new();
-    println!(" Create futures");
-    for instance in 1..=3 {
-        exec.push(move |mut task| async move {
-            println!("   Task {}: begin state", instance);
-            task.waiter().await;
-            println!("   Task {}: next state", instance);
-            task.waiter().await;
-            println!("   Task {}: end state", instance);
-        });
-    }
-
-    println!(" Running");
-    exec.run();
-    println!(" Done");
-    println!("stackless coroutine PASSED");
-
-    0
-}
diff --git a/user/src/bin/store_fault.rs b/user/src/bin/store_fault.rs
deleted file mode 100644
index a54c376..0000000
--- a/user/src/bin/store_fault.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Into Test store_fault, we will insert an invalid store operation...");
-    println!("Kernel should kill this application!");
-    unsafe {
-        core::ptr::null_mut::<u8>().write_volatile(0);
-    }
-    0
-}
diff --git a/user/src/bin/sync_sem.rs b/user/src/bin/sync_sem.rs
deleted file mode 100644
index ef69f35..0000000
--- a/user/src/bin/sync_sem.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::exit;
-use user_lib::{semaphore_create, semaphore_down, semaphore_up};
-use user_lib::{sleep, thread_create, waittid};
-
-const SEM_SYNC: usize = 0;
-
-unsafe fn first() -> ! {
-    sleep(10);
-    println!("First work and wakeup Second");
-    semaphore_up(SEM_SYNC);
-    exit(0)
-}
-
-unsafe fn second() -> ! {
-    println!("Second want to continue,but need to wait first");
-    semaphore_down(SEM_SYNC);
-    println!("Second can work now");
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create semaphores
-    assert_eq!(semaphore_create(0) as usize, SEM_SYNC);
-    // create threads
-    let threads = vec![
-        thread_create(first as usize, 0),
-        thread_create(second as usize, 0),
-    ];
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("sync_sem passed!");
-    0
-}
diff --git a/user/src/bin/threads.rs b/user/src/bin/threads.rs
deleted file mode 100644
index b3a18c3..0000000
--- a/user/src/bin/threads.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::{exit, thread_create, waittid};
-
-pub fn thread_a() -> ! {
-    for _ in 0..1000 {
-        print!("a");
-    }
-    exit(1)
-}
-
-pub fn thread_b() -> ! {
-    for _ in 0..1000 {
-        print!("b");
-    }
-    exit(2)
-}
-
-pub fn thread_c() -> ! {
-    for _ in 0..1000 {
-        print!("c");
-    }
-    exit(3)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let v = vec![
-        thread_create(thread_a as usize, 0),
-        thread_create(thread_b as usize, 0),
-        thread_create(thread_c as usize, 0),
-    ];
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    0
-}
diff --git a/user/src/bin/threads_arg.rs b/user/src/bin/threads_arg.rs
deleted file mode 100644
index f884619..0000000
--- a/user/src/bin/threads_arg.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, thread_create, waittid};
-
-struct Argument {
-    pub ch: char,
-    pub rc: i32,
-}
-
-fn thread_print(arg: *const Argument) -> ! {
-    let arg = unsafe { &*arg };
-    for _ in 0..1000 {
-        print!("{}", arg.ch);
-    }
-    exit(arg.rc)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v = Vec::new();
-    let args = [
-        Argument { ch: 'a', rc: 1 },
-        Argument { ch: 'b', rc: 2 },
-        Argument { ch: 'c', rc: 3 },
-    ];
-    for arg in args.iter() {
-        v.push(thread_create(
-            thread_print as usize,
-            arg as *const _ as usize,
-        ));
-    }
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    0
-}
diff --git a/user/src/bin/until_timeout.rs b/user/src/bin/until_timeout.rs
deleted file mode 100644
index 32e5dbe..0000000
--- a/user/src/bin/until_timeout.rs
+++ /dev/null
@@ -1,46 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exec, fork, get_time, kill, waitpid, waitpid_nb, SignalFlags};
-
-#[no_mangle]
-pub fn main(argc: usize, argv: &[&str]) -> i32 {
-    assert_eq!(argc, 3, "argc must be 3!");
-    let timeout_ms = argv[2]
-        .parse::<isize>()
-        .expect("Error when parsing timeout!");
-    let pid = fork() as usize;
-    if pid == 0 {
-        if exec(argv[1], &[core::ptr::null::<u8>()]) != 0 {
-            println!("Error when executing '{}'", argv[1]);
-            return -4;
-        }
-    } else {
-        let start_time = get_time();
-        let mut child_exited = false;
-        let mut exit_code: i32 = 0;
-        loop {
-            if get_time() - start_time > timeout_ms {
-                break;
-            }
-            if waitpid_nb(pid, &mut exit_code) as usize == pid {
-                child_exited = true;
-                println!(
-                    "child exited in {}ms, exit_code = {}",
-                    get_time() - start_time,
-                    exit_code,
-                );
-            }
-        }
-        if !child_exited {
-            println!("child has run for {}ms, kill it!", timeout_ms);
-            kill(pid, SignalFlags::SIGINT.bits());
-            assert_eq!(waitpid(pid, &mut exit_code) as usize, pid);
-            println!("exit code of the child is {}", exit_code);
-        }
-    }
-    0
-}
diff --git a/user/src/bin/user_shell.rs b/user/src/bin/user_shell.rs
deleted file mode 100644
index 22c03c1..0000000
--- a/user/src/bin/user_shell.rs
+++ /dev/null
@@ -1,214 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::println_empty_string)]
-
-extern crate alloc;
-
-#[macro_use]
-extern crate user_lib;
-
-const LF: u8 = 0x0au8;
-const CR: u8 = 0x0du8;
-const DL: u8 = 0x7fu8;
-const BS: u8 = 0x08u8;
-const LINE_START: &str = ">> ";
-
-use alloc::string::String;
-use alloc::vec::Vec;
-use user_lib::console::getchar;
-use user_lib::{close, dup, exec, fork, open, pipe, waitpid, OpenFlags};
-
-#[derive(Debug)]
-struct ProcessArguments {
-    input: String,
-    output: String,
-    args_copy: Vec<String>,
-    args_addr: Vec<*const u8>,
-}
-
-impl ProcessArguments {
-    pub fn new(command: &str) -> Self {
-        let args: Vec<_> = command.split(' ').collect();
-        let mut args_copy: Vec<String> = args
-            .iter()
-            .filter(|&arg| !arg.is_empty())
-            .map(|&arg| {
-                let mut string = String::new();
-                string.push_str(arg);
-                string.push('\0');
-                string
-            })
-            .collect();
-
-        // redirect input
-        let mut input = String::new();
-        if let Some((idx, _)) = args_copy
-            .iter()
-            .enumerate()
-            .find(|(_, arg)| arg.as_str() == "<\0")
-        {
-            input = args_copy[idx + 1].clone();
-            args_copy.drain(idx..=idx + 1);
-        }
-
-        // redirect output
-        let mut output = String::new();
-        if let Some((idx, _)) = args_copy
-            .iter()
-            .enumerate()
-            .find(|(_, arg)| arg.as_str() == ">\0")
-        {
-            output = args_copy[idx + 1].clone();
-            args_copy.drain(idx..=idx + 1);
-        }
-
-        let mut args_addr: Vec<*const u8> = args_copy.iter().map(|arg| arg.as_ptr()).collect();
-        args_addr.push(core::ptr::null::<u8>());
-
-        Self {
-            input,
-            output,
-            args_copy,
-            args_addr,
-        }
-    }
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("Rust user shell");
-    let mut line: String = String::new();
-    print!("{}", LINE_START);
-    loop {
-        let c = getchar();
-        match c {
-            LF | CR => {
-                println!("");
-                if !line.is_empty() {
-                    let splited: Vec<_> = line.as_str().split('|').collect();
-                    let process_arguments_list: Vec<_> = splited
-                        .iter()
-                        .map(|&cmd| ProcessArguments::new(cmd))
-                        .collect();
-                    let mut valid = true;
-                    for (i, process_args) in process_arguments_list.iter().enumerate() {
-                        if i == 0 {
-                            if !process_args.output.is_empty() {
-                                valid = false;
-                            }
-                        } else if i == process_arguments_list.len() - 1 {
-                            if !process_args.input.is_empty() {
-                                valid = false;
-                            }
-                        } else if !process_args.output.is_empty() || !process_args.input.is_empty()
-                        {
-                            valid = false;
-                        }
-                    }
-                    if process_arguments_list.len() == 1 {
-                        valid = true;
-                    }
-                    if !valid {
-                        println!("Invalid command: Inputs/Outputs cannot be correctly binded!");
-                    } else {
-                        // create pipes
-                        let mut pipes_fd: Vec<[usize; 2]> = Vec::new();
-                        if !process_arguments_list.is_empty() {
-                            for _ in 0..process_arguments_list.len() - 1 {
-                                let mut pipe_fd = [0usize; 2];
-                                pipe(&mut pipe_fd);
-                                pipes_fd.push(pipe_fd);
-                            }
-                        }
-                        let mut children: Vec<_> = Vec::new();
-                        for (i, process_argument) in process_arguments_list.iter().enumerate() {
-                            let pid = fork();
-                            if pid == 0 {
-                                let input = &process_argument.input;
-                                let output = &process_argument.output;
-                                let args_copy = &process_argument.args_copy;
-                                let args_addr = &process_argument.args_addr;
-                                // redirect input
-                                if !input.is_empty() {
-                                    let input_fd = open(input.as_str(), OpenFlags::RDONLY);
-                                    if input_fd == -1 {
-                                        println!("Error when opening file {}", input);
-                                        return -4;
-                                    }
-                                    let input_fd = input_fd as usize;
-                                    close(0);
-                                    assert_eq!(dup(input_fd), 0);
-                                    close(input_fd);
-                                }
-                                // redirect output
-                                if !output.is_empty() {
-                                    let output_fd = open(
-                                        output.as_str(),
-                                        OpenFlags::CREATE | OpenFlags::WRONLY,
-                                    );
-                                    if output_fd == -1 {
-                                        println!("Error when opening file {}", output);
-                                        return -4;
-                                    }
-                                    let output_fd = output_fd as usize;
-                                    close(1);
-                                    assert_eq!(dup(output_fd), 1);
-                                    close(output_fd);
-                                }
-                                // receive input from the previous process
-                                if i > 0 {
-                                    close(0);
-                                    let read_end = pipes_fd.get(i - 1).unwrap()[0];
-                                    assert_eq!(dup(read_end), 0);
-                                }
-                                // send output to the next process
-                                if i < process_arguments_list.len() - 1 {
-                                    close(1);
-                                    let write_end = pipes_fd.get(i).unwrap()[1];
-                                    assert_eq!(dup(write_end), 1);
-                                }
-                                // close all pipe ends inherited from the parent process
-                                for pipe_fd in pipes_fd.iter() {
-                                    close(pipe_fd[0]);
-                                    close(pipe_fd[1]);
-                                }
-                                // execute new application
-                                if exec(args_copy[0].as_str(), args_addr.as_slice()) == -1 {
-                                    println!("Error when executing!");
-                                    return -4;
-                                }
-                                unreachable!();
-                            } else {
-                                children.push(pid);
-                            }
-                        }
-                        for pipe_fd in pipes_fd.iter() {
-                            close(pipe_fd[0]);
-                            close(pipe_fd[1]);
-                        }
-                        let mut exit_code: i32 = 0;
-                        for pid in children.into_iter() {
-                            let exit_pid = waitpid(pid as usize, &mut exit_code);
-                            assert_eq!(pid, exit_pid);
-                            //println!("Shell: Process {} exited with code {}", pid, exit_code);
-                        }
-                    }
-                    line.clear();
-                }
-                print!("{}", LINE_START);
-            }
-            BS | DL => {
-                if !line.is_empty() {
-                    print!("{}", BS as char);
-                    print!(" ");
-                    print!("{}", BS as char);
-                    line.pop();
-                }
-            }
-            _ => {
-                print!("{}", c as char);
-                line.push(c as char);
-            }
-        }
-    }
-}
diff --git a/user/src/bin/usertests.rs b/user/src/bin/usertests.rs
deleted file mode 100644
index 4f99c83..0000000
--- a/user/src/bin/usertests.rs
+++ /dev/null
@@ -1,145 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-// not in SUCC_TESTS & FAIL_TESTS
-// count_lines, infloop, user_shell, usertests
-
-// item of TESTS : app_name(argv_0), argv_1, argv_2, argv_3, exit_code
-static SUCC_TESTS: &[(&str, &str, &str, &str, i32)] = &[
-    ("filetest_simple\0", "\0", "\0", "\0", 0),
-    ("cat\0", "filea\0", "\0", "\0", 0),
-    ("cmdline_args\0", "1\0", "2\0", "3\0", 0),
-    ("eisenberg\0", "\0", "\0", "\0", 0),
-    ("exit\0", "\0", "\0", "\0", 0),
-    ("fantastic_text\0", "\0", "\0", "\0", 0),
-    ("forktest_simple\0", "\0", "\0", "\0", 0),
-    ("forktest\0", "\0", "\0", "\0", 0),
-    ("forktest2\0", "\0", "\0", "\0", 0),
-    ("forktree\0", "\0", "\0", "\0", 0),
-    ("hello_world\0", "\0", "\0", "\0", 0),
-    ("huge_write\0", "\0", "\0", "\0", 0),
-    ("matrix\0", "\0", "\0", "\0", 0),
-    ("mpsc_sem\0", "\0", "\0", "\0", 0),
-    ("peterson\0", "\0", "\0", "\0", 0),
-    ("phil_din_mutex\0", "\0", "\0", "\0", 0),
-    ("pipe_large_test\0", "\0", "\0", "\0", 0),
-    ("pipetest\0", "\0", "\0", "\0", 0),
-    ("adder_peterson_spin\0", "\0", "\0", "\0", 0),
-    ("adder_peterson_yield\0", "\0", "\0", "\0", 0),
-    ("adder_mutex_blocking\0", "\0", "\0", "\0", 0),
-    ("adder_mutex_spin\0", "\0", "\0", "\0", 0),
-    ("run_pipe_test\0", "\0", "\0", "\0", 0),
-    ("sleep_simple\0", "\0", "\0", "\0", 0),
-    ("sleep\0", "\0", "\0", "\0", 0),
-    ("sleep_simple\0", "\0", "\0", "\0", 0),
-    ("sync_sem\0", "\0", "\0", "\0", 0),
-    ("condsync_sem\0", "\0", "\0", "\0", 0),
-    ("condsync_condvar\0", "\0", "\0", "\0", 0),
-    ("threads_arg\0", "\0", "\0", "\0", 0),
-    ("threads\0", "\0", "\0", "\0", 0),
-    ("yield\0", "\0", "\0", "\0", 0),
-    ("barrier_fail\0", "\0", "\0", "\0", 0),
-    ("barrier_condvar\0", "\0", "\0", "\0", 0),
-];
-
-static FAIL_TESTS: &[(&str, &str, &str, &str, i32)] = &[
-    ("stack_overflow\0", "\0", "\0", "\0", -11),
-    ("race_adder_loop\0", "\0", "\0", "\0", -6),
-    ("priv_csr\0", "\0", "\0", "\0", -4),
-    ("priv_inst\0", "\0", "\0", "\0", -4),
-    ("store_fault\0", "\0", "\0", "\0", -11),
-    ("until_timeout\0", "\0", "\0", "\0", -6),
-    ("adder\0", "\0", "\0", "\0", -6),
-    ("adder_simple_spin\0", "\0", "\0", "\0", -6),
-    ("adder_simple_yield\0", "\0", "\0", "\0", -6),
-];
-
-use user_lib::{exec, fork, waitpid};
-
-fn run_tests(tests: &[(&str, &str, &str, &str, i32)]) -> i32 {
-    let mut pass_num = 0;
-    let mut arr: [*const u8; 4] = [
-        core::ptr::null::<u8>(),
-        core::ptr::null::<u8>(),
-        core::ptr::null::<u8>(),
-        core::ptr::null::<u8>(),
-    ];
-
-    for test in tests {
-        println!("Usertests: Running {}", test.0);
-        arr[0] = test.0.as_ptr();
-        if test.1 != "\0" {
-            arr[1] = test.1.as_ptr();
-            arr[2] = core::ptr::null::<u8>();
-            arr[3] = core::ptr::null::<u8>();
-            if test.2 != "\0" {
-                arr[2] = test.2.as_ptr();
-                arr[3] = core::ptr::null::<u8>();
-                if test.3 != "\0" {
-                    arr[3] = test.3.as_ptr();
-                } else {
-                    arr[3] = core::ptr::null::<u8>();
-                }
-            } else {
-                arr[2] = core::ptr::null::<u8>();
-                arr[3] = core::ptr::null::<u8>();
-            }
-        } else {
-            arr[1] = core::ptr::null::<u8>();
-            arr[2] = core::ptr::null::<u8>();
-            arr[3] = core::ptr::null::<u8>();
-        }
-
-        let pid = fork();
-        if pid == 0 {
-            exec(test.0, &arr[..]);
-            panic!("unreachable!");
-        } else {
-            let mut exit_code: i32 = Default::default();
-            let wait_pid = waitpid(pid as usize, &mut exit_code);
-            assert_eq!(pid, wait_pid);
-            if exit_code == test.4 {
-                // summary apps with  exit_code
-                pass_num = pass_num + 1;
-            }
-            println!(
-                "\x1b[32mUsertests: Test {} in Process {} exited with code {}\x1b[0m",
-                test.0, pid, exit_code
-            );
-        }
-    }
-    pass_num
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let succ_num = run_tests(SUCC_TESTS);
-    let err_num = run_tests(FAIL_TESTS);
-    if succ_num == SUCC_TESTS.len() as i32 && err_num == FAIL_TESTS.len() as i32 {
-        println!(
-            "{} of sueecssed apps, {} of failed apps run correctly. \nUsertests passed!",
-            SUCC_TESTS.len(),
-            FAIL_TESTS.len()
-        );
-        return 0;
-    }
-    if succ_num != SUCC_TESTS.len() as i32 {
-        println!(
-            "all successed app_num is  {} , but only  passed {}",
-            SUCC_TESTS.len(),
-            succ_num
-        );
-    }
-    if err_num != FAIL_TESTS.len() as i32 {
-        println!(
-            "all failed app_num is  {} , but only  passed {}",
-            FAIL_TESTS.len(),
-            err_num
-        );
-    }
-    println!(" Usertests failed!");
-    return -1;
-}
diff --git a/user/src/bin/yield.rs b/user/src/bin/yield.rs
deleted file mode 100644
index 7e5733b..0000000
--- a/user/src/bin/yield.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-use user_lib::{getpid, yield_};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("Hello, I am process {}.", getpid());
-    for i in 0..5 {
-        yield_();
-        println!("Back in process {}, iteration {}.", getpid(), i);
-    }
-    println!("yield pass.");
-    0
-}
diff --git a/user/src/console.rs b/user/src/console.rs
deleted file mode 100644
index 35605e2..0000000
--- a/user/src/console.rs
+++ /dev/null
@@ -1,39 +0,0 @@
-use core::fmt::{self, Write};
-
-const STDIN: usize = 0;
-const STDOUT: usize = 1;
-
-use super::{read, write};
-
-struct Stdout;
-
-impl Write for Stdout {
-    fn write_str(&mut self, s: &str) -> fmt::Result {
-        write(STDOUT, s.as_bytes());
-        Ok(())
-    }
-}
-
-pub fn print(args: fmt::Arguments) {
-    Stdout.write_fmt(args).unwrap();
-}
-
-#[macro_export]
-macro_rules! print {
-    ($fmt: literal $(, $($arg: tt)+)?) => {
-        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
-    }
-}
-
-#[macro_export]
-macro_rules! println {
-    ($fmt: literal $(, $($arg: tt)+)?) => {
-        $crate::console::print(format_args!(concat!($fmt, "\n") $(, $($arg)+)?));
-    }
-}
-
-pub fn getchar() -> u8 {
-    let mut c = [0u8; 1];
-    read(STDIN, &mut c);
-    c[0]
-}
diff --git a/user/src/file.rs b/user/src/file.rs
deleted file mode 100644
index 19e2564..0000000
--- a/user/src/file.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-use super::*;
-
-bitflags! {
-    pub struct OpenFlags: u32 {
-        const RDONLY = 0;
-        const WRONLY = 1 << 0;
-        const RDWR = 1 << 1;
-        const CREATE = 1 << 9;
-        const TRUNC = 1 << 10;
-    }
-}
-
-pub fn dup(fd: usize) -> isize {
-    sys_dup(fd)
-}
-pub fn open(path: &str, flags: OpenFlags) -> isize {
-    sys_open(path, flags.bits)
-}
-pub fn close(fd: usize) -> isize {
-    sys_close(fd)
-}
-pub fn pipe(pipe_fd: &mut [usize]) -> isize {
-    sys_pipe(pipe_fd)
-}
-pub fn read(fd: usize, buf: &mut [u8]) -> isize {
-    sys_read(fd, buf)
-}
-pub fn write(fd: usize, buf: &[u8]) -> isize {
-    sys_write(fd, buf)
-}
diff --git a/user/src/io.rs b/user/src/io.rs
deleted file mode 100644
index 30e7a1c..0000000
--- a/user/src/io.rs
+++ /dev/null
@@ -1,116 +0,0 @@
-use super::*;
-use embedded_graphics::pixelcolor::Rgb888;
-use embedded_graphics::prelude::{RgbColor, Size};
-use embedded_graphics::{draw_target::DrawTarget, prelude::OriginDimensions};
-use virtio_input_decoder::Decoder;
-pub use virtio_input_decoder::{DecodeType, Key, KeyType, Mouse};
-
-pub const VIRTGPU_XRES: u32 = 1280;
-pub const VIRTGPU_YRES: u32 = 800;
-pub const VIRTGPU_LEN: usize = (VIRTGPU_XRES * VIRTGPU_YRES * 4) as usize;
-
-pub fn framebuffer() -> isize {
-    sys_framebuffer()
-}
-pub fn framebuffer_flush() -> isize {
-    sys_framebuffer_flush()
-}
-
-pub struct Display {
-    pub size: Size,
-    pub fb: &'static mut [u8],
-}
-
-impl Display {
-    pub fn new(size: Size) -> Self {
-        let fb_ptr = framebuffer() as *mut u8;
-        let fb = unsafe { core::slice::from_raw_parts_mut(fb_ptr, VIRTGPU_LEN as usize) };
-        Self { size, fb }
-    }
-    pub fn framebuffer(&mut self) -> &mut [u8] {
-        self.fb
-    }
-    pub fn paint_on_framebuffer(&mut self, p: impl FnOnce(&mut [u8]) -> ()) {
-        p(self.framebuffer());
-        framebuffer_flush();
-    }
-}
-
-impl OriginDimensions for Display {
-    fn size(&self) -> Size {
-        self.size
-    }
-}
-
-impl DrawTarget for Display {
-    type Color = Rgb888;
-
-    type Error = core::convert::Infallible;
-
-    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
-    where
-        I: IntoIterator<Item = embedded_graphics::Pixel<Self::Color>>,
-    {
-        pixels.into_iter().for_each(|px| {
-            let idx = (px.0.y * VIRTGPU_XRES as i32 + px.0.x) as usize * 4;
-            if idx + 2 >= self.fb.len() {
-                return;
-            }
-            self.fb[idx] = px.1.b();
-            self.fb[idx + 1] = px.1.g();
-            self.fb[idx + 2] = px.1.r();
-        });
-        framebuffer_flush();
-        Ok(())
-    }
-}
-
-pub fn event_get() -> Option<InputEvent> {
-    let raw_value = sys_event_get();
-    if raw_value == 0 {
-        None
-    } else {
-        Some((raw_value as u64).into())
-    }
-}
-
-pub fn key_pressed() -> bool {
-    if sys_key_pressed() == 1 {
-        true
-    } else {
-        false
-    }
-}
-
-#[repr(C)]
-pub struct InputEvent {
-    pub event_type: u16,
-    pub code: u16,
-    pub value: u32,
-}
-
-impl From<u64> for InputEvent {
-    fn from(mut v: u64) -> Self {
-        let value = v as u32;
-        v >>= 32;
-        let code = v as u16;
-        v >>= 16;
-        let event_type = v as u16;
-        Self {
-            event_type,
-            code,
-            value,
-        }
-    }
-}
-
-impl InputEvent {
-    pub fn decode(&self) -> Option<DecodeType> {
-        Decoder::decode(
-            self.event_type as usize,
-            self.code as usize,
-            self.value as usize,
-        )
-        .ok()
-    }
-}
diff --git a/user/src/lang_items.rs b/user/src/lang_items.rs
deleted file mode 100644
index c3e9a0b..0000000
--- a/user/src/lang_items.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-use super::{getpid, kill, SignalFlags};
-
-#[panic_handler]
-fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! {
-    let err = panic_info.message().unwrap();
-    if let Some(location) = panic_info.location() {
-        println!(
-            "Panicked at {}:{}, {}",
-            location.file(),
-            location.line(),
-            err
-        );
-    } else {
-        println!("Panicked: {}", err);
-    }
-    kill(getpid() as usize, SignalFlags::SIGABRT.bits());
-    unreachable!()
-}
diff --git a/user/src/lib.rs b/user/src/lib.rs
deleted file mode 100644
index 31a8db8..0000000
--- a/user/src/lib.rs
+++ /dev/null
@@ -1,89 +0,0 @@
-#![no_std]
-#![feature(linkage)]
-#![feature(panic_info_message)]
-#![feature(alloc_error_handler)]
-#![feature(core_intrinsics)]
-
-#[macro_use]
-pub mod console;
-mod file;
-mod io;
-mod lang_items;
-mod sync;
-mod syscall;
-mod task;
-
-extern crate alloc;
-#[macro_use]
-extern crate bitflags;
-
-use alloc::vec::Vec;
-use buddy_system_allocator::LockedHeap;
-pub use file::*;
-pub use io::*;
-pub use sync::*;
-use syscall::*;
-pub use task::*;
-
-const USER_HEAP_SIZE: usize = 32768;
-
-static mut HEAP_SPACE: [u8; USER_HEAP_SIZE] = [0; USER_HEAP_SIZE];
-
-#[global_allocator]
-static HEAP: LockedHeap = LockedHeap::empty();
-
-#[alloc_error_handler]
-pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
-    panic!("Heap allocation error, layout = {:?}", layout);
-}
-
-#[no_mangle]
-#[link_section = ".text.entry"]
-pub extern "C" fn _start(argc: usize, argv: usize) -> ! {
-    unsafe {
-        HEAP.lock()
-            .init(HEAP_SPACE.as_ptr() as usize, USER_HEAP_SIZE);
-    }
-    let mut v: Vec<&'static str> = Vec::new();
-    for i in 0..argc {
-        let str_start =
-            unsafe { ((argv + i * core::mem::size_of::<usize>()) as *const usize).read_volatile() };
-        let len = (0usize..)
-            .find(|i| unsafe { ((str_start + *i) as *const u8).read_volatile() == 0 })
-            .unwrap();
-        v.push(
-            core::str::from_utf8(unsafe {
-                core::slice::from_raw_parts(str_start as *const u8, len)
-            })
-            .unwrap(),
-        );
-    }
-    exit(main(argc, v.as_slice()));
-}
-
-#[linkage = "weak"]
-#[no_mangle]
-fn main(_argc: usize, _argv: &[&str]) -> i32 {
-    panic!("Cannot find main!");
-}
-
-#[macro_export]
-macro_rules! vstore {
-    ($var_ref: expr, $value: expr) => {
-        unsafe { core::intrinsics::volatile_store($var_ref as *const _ as _, $value) }
-    };
-}
-
-#[macro_export]
-macro_rules! vload {
-    ($var_ref: expr) => {
-        unsafe { core::intrinsics::volatile_load($var_ref as *const _ as _) }
-    };
-}
-
-#[macro_export]
-macro_rules! memory_fence {
-    () => {
-        core::sync::atomic::fence(core::sync::atomic::Ordering::SeqCst)
-    };
-}
diff --git a/user/src/linker.ld b/user/src/linker.ld
deleted file mode 100644
index 0c42290..0000000
--- a/user/src/linker.ld
+++ /dev/null
@@ -1,32 +0,0 @@
-
-OUTPUT_ARCH(riscv)
-ENTRY(_start)
-
-BASE_ADDRESS = 0x10000;
-
-SECTIONS
-{
-    . = BASE_ADDRESS;
-    .text : {
-        *(.text.entry)
-        *(.text .text.*)
-    }
-    . = ALIGN(4K);
-    .rodata : {
-        *(.rodata .rodata.*)
-        *(.srodata .srodata.*)
-    }
-    . = ALIGN(4K);
-    .data : {
-        *(.data .data.*)
-        *(.sdata .sdata.*)
-    }
-    .bss : {
-        *(.bss .bss.*)
-        *(.sbss .sbss.*)
-    }
-    /DISCARD/ : {
-        *(.eh_frame)
-        *(.debug*)
-    }
-}
diff --git a/user/src/sync.rs b/user/src/sync.rs
deleted file mode 100644
index 82cd2a0..0000000
--- a/user/src/sync.rs
+++ /dev/null
@@ -1,32 +0,0 @@
-use super::*;
-
-pub fn mutex_create() -> isize {
-    sys_mutex_create(false)
-}
-pub fn mutex_blocking_create() -> isize {
-    sys_mutex_create(true)
-}
-pub fn mutex_lock(mutex_id: usize) {
-    sys_mutex_lock(mutex_id);
-}
-pub fn mutex_unlock(mutex_id: usize) {
-    sys_mutex_unlock(mutex_id);
-}
-pub fn semaphore_create(res_count: usize) -> isize {
-    sys_semaphore_create(res_count)
-}
-pub fn semaphore_up(sem_id: usize) {
-    sys_semaphore_up(sem_id);
-}
-pub fn semaphore_down(sem_id: usize) {
-    sys_semaphore_down(sem_id);
-}
-pub fn condvar_create() -> isize {
-    sys_condvar_create()
-}
-pub fn condvar_signal(condvar_id: usize) {
-    sys_condvar_signal(condvar_id);
-}
-pub fn condvar_wait(condvar_id: usize, mutex_id: usize) {
-    sys_condvar_wait(condvar_id, mutex_id);
-}
diff --git a/user/src/syscall.rs b/user/src/syscall.rs
deleted file mode 100644
index 1d0e5a5..0000000
--- a/user/src/syscall.rs
+++ /dev/null
@@ -1,176 +0,0 @@
-const SYSCALL_DUP: usize = 24;
-const SYSCALL_OPEN: usize = 56;
-const SYSCALL_CLOSE: usize = 57;
-const SYSCALL_PIPE: usize = 59;
-const SYSCALL_READ: usize = 63;
-const SYSCALL_WRITE: usize = 64;
-const SYSCALL_EXIT: usize = 93;
-const SYSCALL_SLEEP: usize = 101;
-const SYSCALL_YIELD: usize = 124;
-const SYSCALL_KILL: usize = 129;
-const SYSCALL_GET_TIME: usize = 169;
-const SYSCALL_GETPID: usize = 172;
-const SYSCALL_FORK: usize = 220;
-const SYSCALL_EXEC: usize = 221;
-const SYSCALL_WAITPID: usize = 260;
-const SYSCALL_THREAD_CREATE: usize = 1000;
-const SYSCALL_GETTID: usize = 1001;
-const SYSCALL_WAITTID: usize = 1002;
-const SYSCALL_MUTEX_CREATE: usize = 1010;
-const SYSCALL_MUTEX_LOCK: usize = 1011;
-const SYSCALL_MUTEX_UNLOCK: usize = 1012;
-const SYSCALL_SEMAPHORE_CREATE: usize = 1020;
-const SYSCALL_SEMAPHORE_UP: usize = 1021;
-const SYSCALL_SEMAPHORE_DOWN: usize = 1022;
-const SYSCALL_CONDVAR_CREATE: usize = 1030;
-const SYSCALL_CONDVAR_SIGNAL: usize = 1031;
-const SYSCALL_CONDVAR_WAIT: usize = 1032;
-const SYSCALL_FRAMEBUFFER: usize = 2000;
-const SYSCALL_FRAMEBUFFER_FLUSH: usize = 2001;
-const SYSCALL_EVENT_GET: usize = 3000;
-const SYSCALL_KEY_PRESSED: usize = 3001;
-
-fn syscall(id: usize, args: [usize; 3]) -> isize {
-    let mut ret: isize;
-    unsafe {
-        core::arch::asm!(
-            "ecall",
-            inlateout("x10") args[0] => ret,
-            in("x11") args[1],
-            in("x12") args[2],
-            in("x17") id
-        );
-    }
-    ret
-}
-
-pub fn sys_dup(fd: usize) -> isize {
-    syscall(SYSCALL_DUP, [fd, 0, 0])
-}
-
-pub fn sys_open(path: &str, flags: u32) -> isize {
-    syscall(SYSCALL_OPEN, [path.as_ptr() as usize, flags as usize, 0])
-}
-
-pub fn sys_close(fd: usize) -> isize {
-    syscall(SYSCALL_CLOSE, [fd, 0, 0])
-}
-
-pub fn sys_pipe(pipe: &mut [usize]) -> isize {
-    syscall(SYSCALL_PIPE, [pipe.as_mut_ptr() as usize, 0, 0])
-}
-
-pub fn sys_read(fd: usize, buffer: &mut [u8]) -> isize {
-    syscall(
-        SYSCALL_READ,
-        [fd, buffer.as_mut_ptr() as usize, buffer.len()],
-    )
-}
-
-pub fn sys_write(fd: usize, buffer: &[u8]) -> isize {
-    syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()])
-}
-
-pub fn sys_exit(exit_code: i32) -> ! {
-    syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]);
-    panic!("sys_exit never returns!");
-}
-
-pub fn sys_sleep(sleep_ms: usize) -> isize {
-    syscall(SYSCALL_SLEEP, [sleep_ms, 0, 0])
-}
-
-pub fn sys_yield() -> isize {
-    syscall(SYSCALL_YIELD, [0, 0, 0])
-}
-
-pub fn sys_kill(pid: usize, signal: i32) -> isize {
-    syscall(SYSCALL_KILL, [pid, signal as usize, 0])
-}
-
-pub fn sys_get_time() -> isize {
-    syscall(SYSCALL_GET_TIME, [0, 0, 0])
-}
-
-pub fn sys_getpid() -> isize {
-    syscall(SYSCALL_GETPID, [0, 0, 0])
-}
-
-pub fn sys_fork() -> isize {
-    syscall(SYSCALL_FORK, [0, 0, 0])
-}
-
-pub fn sys_exec(path: &str, args: &[*const u8]) -> isize {
-    syscall(
-        SYSCALL_EXEC,
-        [path.as_ptr() as usize, args.as_ptr() as usize, 0],
-    )
-}
-
-pub fn sys_waitpid(pid: isize, exit_code: *mut i32) -> isize {
-    syscall(SYSCALL_WAITPID, [pid as usize, exit_code as usize, 0])
-}
-
-pub fn sys_thread_create(entry: usize, arg: usize) -> isize {
-    syscall(SYSCALL_THREAD_CREATE, [entry, arg, 0])
-}
-
-pub fn sys_gettid() -> isize {
-    syscall(SYSCALL_GETTID, [0; 3])
-}
-
-pub fn sys_waittid(tid: usize) -> isize {
-    syscall(SYSCALL_WAITTID, [tid, 0, 0])
-}
-
-pub fn sys_mutex_create(blocking: bool) -> isize {
-    syscall(SYSCALL_MUTEX_CREATE, [blocking as usize, 0, 0])
-}
-
-pub fn sys_mutex_lock(id: usize) -> isize {
-    syscall(SYSCALL_MUTEX_LOCK, [id, 0, 0])
-}
-
-pub fn sys_mutex_unlock(id: usize) -> isize {
-    syscall(SYSCALL_MUTEX_UNLOCK, [id, 0, 0])
-}
-
-pub fn sys_semaphore_create(res_count: usize) -> isize {
-    syscall(SYSCALL_SEMAPHORE_CREATE, [res_count, 0, 0])
-}
-
-pub fn sys_semaphore_up(sem_id: usize) -> isize {
-    syscall(SYSCALL_SEMAPHORE_UP, [sem_id, 0, 0])
-}
-
-pub fn sys_semaphore_down(sem_id: usize) -> isize {
-    syscall(SYSCALL_SEMAPHORE_DOWN, [sem_id, 0, 0])
-}
-
-pub fn sys_condvar_create() -> isize {
-    syscall(SYSCALL_CONDVAR_CREATE, [0, 0, 0])
-}
-
-pub fn sys_condvar_signal(condvar_id: usize) -> isize {
-    syscall(SYSCALL_CONDVAR_SIGNAL, [condvar_id, 0, 0])
-}
-
-pub fn sys_condvar_wait(condvar_id: usize, mutex_id: usize) -> isize {
-    syscall(SYSCALL_CONDVAR_WAIT, [condvar_id, mutex_id, 0])
-}
-
-pub fn sys_framebuffer() -> isize {
-    syscall(SYSCALL_FRAMEBUFFER, [0, 0, 0])
-}
-
-pub fn sys_framebuffer_flush() -> isize {
-    syscall(SYSCALL_FRAMEBUFFER_FLUSH, [0, 0, 0])
-}
-
-pub fn sys_event_get() -> isize {
-    syscall(SYSCALL_EVENT_GET, [0, 0, 0])
-}
-
-pub fn sys_key_pressed() -> isize {
-    syscall(SYSCALL_KEY_PRESSED, [0, 0, 0])
-}
diff --git a/user/src/task.rs b/user/src/task.rs
deleted file mode 100644
index 040ef54..0000000
--- a/user/src/task.rs
+++ /dev/null
@@ -1,82 +0,0 @@
-use super::*;
-
-pub fn exit(exit_code: i32) -> ! {
-    sys_exit(exit_code);
-}
-pub fn yield_() -> isize {
-    sys_yield()
-}
-pub fn get_time() -> isize {
-    sys_get_time()
-}
-pub fn getpid() -> isize {
-    sys_getpid()
-}
-pub fn fork() -> isize {
-    sys_fork()
-}
-pub fn exec(path: &str, args: &[*const u8]) -> isize {
-    sys_exec(path, args)
-}
-pub fn wait(exit_code: &mut i32) -> isize {
-    loop {
-        match sys_waitpid(-1, exit_code as *mut _) {
-            -2 => {
-                yield_();
-            }
-            // -1 or a real pid
-            exit_pid => return exit_pid,
-        }
-    }
-}
-
-pub fn waitpid(pid: usize, exit_code: &mut i32) -> isize {
-    loop {
-        match sys_waitpid(pid as isize, exit_code as *mut _) {
-            -2 => {
-                yield_();
-            }
-            // -1 or a real pid
-            exit_pid => return exit_pid,
-        }
-    }
-}
-
-pub fn waitpid_nb(pid: usize, exit_code: &mut i32) -> isize {
-    sys_waitpid(pid as isize, exit_code as *mut _)
-}
-
-bitflags! {
-    pub struct SignalFlags: i32 {
-        const SIGINT    = 1 << 2;
-        const SIGILL    = 1 << 4;
-        const SIGABRT   = 1 << 6;
-        const SIGFPE    = 1 << 8;
-        const SIGSEGV   = 1 << 11;
-    }
-}
-
-pub fn kill(pid: usize, signal: i32) -> isize {
-    sys_kill(pid, signal)
-}
-
-pub fn sleep(sleep_ms: usize) {
-    sys_sleep(sleep_ms);
-}
-
-pub fn thread_create(entry: usize, arg: usize) -> isize {
-    sys_thread_create(entry, arg)
-}
-pub fn gettid() -> isize {
-    sys_gettid()
-}
-pub fn waittid(tid: usize) -> isize {
-    loop {
-        match sys_waittid(tid) {
-            -2 => {
-                yield_();
-            }
-            exit_code => return exit_code,
-        }
-    }
-}
diff --git a/user_libs/Cargo.toml b/user_libs/Cargo.toml
deleted file mode 100644
index c7eda72..0000000
--- a/user_libs/Cargo.toml
+++ /dev/null
@@ -1,10 +0,0 @@
-[package]
-name = "user_libs"
-version = "0.0.1"
-edition = "2021"
-authors = ["YdrMaster <ydrml@hotmail.com>"]
-
-[dependencies]
-rcore-console = { path = "../console", package="console"}
-syscall = { path = "../syscall", features = ["user"] }
-customizable-buddy = "0.0.2"
diff --git a/user_libs/README.md b/user_libs/README.md
deleted file mode 100644
index 1c654ee..0000000
--- a/user_libs/README.md
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿# 用户程序
-
-编译出可在操作系统中加载和运行的应用程序。
-
-- ch1：不支持应用程序
-- ch2-ch3：应用程序二进制静态链接到内核二进制，且需要定制链接脚本以指定应用程序位置
-- ch4-ch5：应用程序二进制静态链接到内核二进制，但不需要定制链接脚本
-- ch6-ch7：通过文件系统加载应用程序
diff --git a/user_libs/build.rs b/user_libs/build.rs
deleted file mode 100644
index bb228c7..0000000
--- a/user_libs/build.rs
+++ /dev/null
@@ -1,40 +0,0 @@
-fn main() {
-    use std::{env, fs, path::PathBuf};
-
-    println!("cargo:rerun-if-changed=build.rs");
-    println!("cargo:rerun-if-env-changed=LOG");
-    println!("cargo:rerun-if-env-changed=BASE_ADDRESS");
-
-    if let Some(base) = env::var("BASE_ADDRESS")
-        .ok()
-        .and_then(|s| s.parse::<u64>().ok())
-    {
-        let text = format!(
-            "\
-OUTPUT_ARCH(riscv)
-ENTRY(_start)
-SECTIONS {{
-    . = {base};
-    .text : {{
-        *(.text.entry)
-        *(.text .text.*)
-    }}
-    .rodata : {{
-        *(.rodata .rodata.*)
-        *(.srodata .srodata.*)
-    }}
-    .data : {{
-        *(.data .data.*)
-        *(.sdata .sdata.*)
-    }}
-    .bss : {{
-        *(.bss .bss.*)
-        *(.sbss .sbss.*)
-    }}
-}}"
-        );
-        let ld = PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("linker.ld");
-        fs::write(&ld, text).unwrap();
-        println!("cargo:rustc-link-arg=-T{}", ld.display());
-    }
-}
diff --git a/user_libs/cases.toml b/user_libs/cases.toml
deleted file mode 100644
index dbf3c27..0000000
--- a/user_libs/cases.toml
+++ /dev/null
@@ -1,124 +0,0 @@
-﻿[ch2]
-base = 0x8040_0000
-step = 0
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-]
-
-[ch3]
-base = 0x8040_0000
-step = 0x0020_0000
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "05write_a",
-    "06write_b",
-    "07write_c",
-    "08power_3",
-    "09power_5",
-    "10power_7",
-    "11sleep",
-]
-
-[ch4]
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "05write_a",
-    "06write_b",
-    "07write_c",
-    "08power_3",
-    "09power_5",
-    "10power_7",
-    "11sleep",
-]
-
-[ch5]
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "12forktest",
-    "13forktree",
-    "14forktest2",
-    "15matrix",
-    "user_shell",
-    "initproc",
-]
-
-[ch6]
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "12forktest",
-    "13forktree",
-    "14forktest2",
-    "15matrix",
-    "user_shell",
-    "initproc",
-    "filetest_simple",
-    "cat_filea",
-]
-
-[ch7]
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "12forktest",
-    "13forktree",
-    "14forktest2",
-    "15matrix",
-    "user_shell",
-    "initproc",
-    "filetest_simple",
-    "cat_filea",
-    "sig_simple",
-    "sig_simple2",
-    "sig_ctrlc",
-    "sig_tests",
-]
-
-[ch8]
-cases = [
-    "00hello_world",
-    "01store_fault",
-    "02power",
-    "03priv_inst",
-    "04priv_csr",
-    "12forktest",
-    "13forktree",
-    "14forktest2",
-    "15matrix",
-    "user_shell",
-    "initproc",
-    "filetest_simple",
-    "cat_filea",
-    "sig_simple",
-    "sig_simple2",
-    "sig_ctrlc",
-    "sig_tests",
-    "threads",
-    "threads_arg",
-    "mpsc_sem",
-    "sync_sem",
-    "race_adder_mutex_blocking",
-    "test_condvar",
-]
\ No newline at end of file
diff --git a/user_libs/src/bin/00hello_world.rs b/user_libs/src/bin/00hello_world.rs
deleted file mode 100644
index cefa39b..0000000
--- a/user_libs/src/bin/00hello_world.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Hello, world!");
-    0
-}
diff --git a/user_libs/src/bin/01store_fault.rs b/user_libs/src/bin/01store_fault.rs
deleted file mode 100644
index 41413c9..0000000
--- a/user_libs/src/bin/01store_fault.rs
+++ /dev/null
@@ -1,13 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Into Test store_fault, we will insert an invalid store operation...");
-    println!("Kernel should kill this application!");
-    unsafe { core::ptr::null_mut::<u8>().write_volatile(0) };
-    0
-}
diff --git a/user_libs/src/bin/02power.rs b/user_libs/src/bin/02power.rs
deleted file mode 100644
index f628f34..0000000
--- a/user_libs/src/bin/02power.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-const SIZE: usize = 10;
-const P: u32 = 3;
-const STEP: usize = 100000;
-const MOD: u32 = 10007;
-
-#[no_mangle]
-fn main() -> i32 {
-    let mut pow = [0u32; SIZE];
-    let mut index: usize = 0;
-    pow[index] = 1;
-    for i in 1..=STEP {
-        let last = pow[index];
-        index = (index + 1) % SIZE;
-        pow[index] = last * P % MOD;
-        if i % 10000 == 0 {
-            println!("{}^{}={}(MOD {})", P, i, pow[index], MOD);
-        }
-    }
-    println!("Test power OK!");
-    0
-}
diff --git a/user_libs/src/bin/03priv_inst.rs b/user_libs/src/bin/03priv_inst.rs
deleted file mode 100644
index 962b7a9..0000000
--- a/user_libs/src/bin/03priv_inst.rs
+++ /dev/null
@@ -1,13 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Try to execute privileged instruction in U Mode");
-    println!("Kernel should kill this application!");
-    unsafe { core::arch::asm!("sret") };
-    0
-}
diff --git a/user_libs/src/bin/04priv_csr.rs b/user_libs/src/bin/04priv_csr.rs
deleted file mode 100644
index 611982a..0000000
--- a/user_libs/src/bin/04priv_csr.rs
+++ /dev/null
@@ -1,13 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-#[no_mangle]
-fn main() -> i32 {
-    println!("Try to access privileged CSR in U Mode");
-    println!("Kernel should kill this application!");
-    unsafe { core::arch::asm!("csrw stvec, zero") };
-    0
-}
diff --git a/user_libs/src/bin/05write_a.rs b/user_libs/src/bin/05write_a.rs
deleted file mode 100644
index 68a36e9..0000000
--- a/user_libs/src/bin/05write_a.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::sched_yield;
-
-const WIDTH: usize = 10;
-const HEIGHT: usize = 5;
-
-#[no_mangle]
-fn main() -> i32 {
-    for i in 0..HEIGHT {
-        for _ in 0..WIDTH {
-            print!("A");
-        }
-        println!(" [{}/{}]", i + 1, HEIGHT);
-        sched_yield();
-    }
-    println!("Test write_a OK!");
-    0
-}
diff --git a/user_libs/src/bin/06write_b.rs b/user_libs/src/bin/06write_b.rs
deleted file mode 100644
index b1a9a8b..0000000
--- a/user_libs/src/bin/06write_b.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::sched_yield;
-
-const WIDTH: usize = 10;
-const HEIGHT: usize = 2;
-
-#[no_mangle]
-fn main() -> i32 {
-    for i in 0..HEIGHT {
-        for _ in 0..WIDTH {
-            print!("B");
-        }
-        println!(" [{}/{}]", i + 1, HEIGHT);
-        sched_yield();
-    }
-    println!("Test write_b OK!");
-    0
-}
diff --git a/user_libs/src/bin/07write_c.rs b/user_libs/src/bin/07write_c.rs
deleted file mode 100644
index 5fcd0f7..0000000
--- a/user_libs/src/bin/07write_c.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::sched_yield;
-
-const WIDTH: usize = 10;
-const HEIGHT: usize = 3;
-
-#[no_mangle]
-fn main() -> i32 {
-    for i in 0..HEIGHT {
-        for _ in 0..WIDTH {
-            print!("C");
-        }
-        println!(" [{}/{}]", i + 1, HEIGHT);
-        sched_yield();
-    }
-    println!("Test write_c OK!");
-    0
-}
diff --git a/user_libs/src/bin/08power_3.rs b/user_libs/src/bin/08power_3.rs
deleted file mode 100644
index 1a04dc7..0000000
--- a/user_libs/src/bin/08power_3.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-const LEN: usize = 100;
-
-#[no_mangle]
-fn main() -> i32 {
-    let p = 3u64;
-    let m = 998244353u64;
-    let iter: usize = 200000;
-    let mut s = [0u64; LEN];
-    let mut cur = 0usize;
-    s[cur] = 1;
-    for i in 1..=iter {
-        let next = if cur + 1 == LEN { 0 } else { cur + 1 };
-        s[next] = s[cur] * p % m;
-        cur = next;
-        if i % 10000 == 0 {
-            println!("power_3 [{}/{}]", i, iter);
-        }
-    }
-    println!("{}^{} = {}(MOD {})", p, iter, s[cur], m);
-    println!("Test power_3 OK!");
-    0
-}
diff --git a/user_libs/src/bin/09power_5.rs b/user_libs/src/bin/09power_5.rs
deleted file mode 100644
index e47761b..0000000
--- a/user_libs/src/bin/09power_5.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-const LEN: usize = 100;
-
-#[no_mangle]
-fn main() -> i32 {
-    let p = 5u64;
-    let m = 998244353u64;
-    let iter: usize = 140000;
-    let mut s = [0u64; LEN];
-    let mut cur = 0usize;
-    s[cur] = 1;
-    for i in 1..=iter {
-        let next = if cur + 1 == LEN { 0 } else { cur + 1 };
-        s[next] = s[cur] * p % m;
-        cur = next;
-        if i % 10000 == 0 {
-            println!("power_5 [{}/{}]", i, iter);
-        }
-    }
-    println!("{}^{} = {}(MOD {})", p, iter, s[cur], m);
-    println!("Test power_5 OK!");
-    0
-}
diff --git a/user_libs/src/bin/10power_7.rs b/user_libs/src/bin/10power_7.rs
deleted file mode 100644
index a97d2f5..0000000
--- a/user_libs/src/bin/10power_7.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-const LEN: usize = 100;
-
-#[no_mangle]
-fn main() -> i32 {
-    let p = 7u64;
-    let m = 998244353u64;
-    let iter: usize = 160000;
-    let mut s = [0u64; LEN];
-    let mut cur = 0usize;
-    s[cur] = 1;
-    for i in 1..=iter {
-        let next = if cur + 1 == LEN { 0 } else { cur + 1 };
-        s[next] = s[cur] * p % m;
-        cur = next;
-        if i % 10000 == 0 {
-            println!("power_7 [{}/{}]", i, iter);
-        }
-    }
-    println!("{}^{} = {}(MOD {})", p, iter, s[cur], m);
-    println!("Test power_7 OK!");
-    0
-}
diff --git a/user_libs/src/bin/11sleep.rs b/user_libs/src/bin/11sleep.rs
deleted file mode 100644
index 5081a25..0000000
--- a/user_libs/src/bin/11sleep.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{clock_gettime, sched_yield, ClockId, TimeSpec};
-
-#[no_mangle]
-fn main() -> i32 {
-    let mut time: TimeSpec = TimeSpec::ZERO;
-    clock_gettime(ClockId::CLOCK_MONOTONIC, &mut time as *mut _ as _);
-    let time = time + TimeSpec::SECOND;
-    loop {
-        let mut now: TimeSpec = TimeSpec::ZERO;
-        clock_gettime(ClockId::CLOCK_MONOTONIC, &mut now as *mut _ as _);
-        if now > time {
-            break;
-        }
-        sched_yield();
-    }
-    println!("Test sleep OK!");
-    0
-}
diff --git a/user_libs/src/bin/12forktest.rs b/user_libs/src/bin/12forktest.rs
deleted file mode 100644
index 5374a56..0000000
--- a/user_libs/src/bin/12forktest.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, wait};
-
-const MAX_CHILD: usize = 30;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for i in 0..MAX_CHILD {
-        let pid = fork();
-        if pid == 0 {
-            println!("I am child {}", i);
-            exit(0);
-        } else {
-            println!("forked child pid = {}", pid);
-        }
-        assert!(pid > 0);
-    }
-    let mut exit_code: i32 = 0;
-    for _ in 0..MAX_CHILD {
-        if wait(&mut exit_code) <= 0 {
-            panic!("wait stopped early");
-        }
-    }
-    if wait(&mut exit_code) > 0 {
-        panic!("wait got too many");
-    }
-    println!("forktest pass.");
-    0
-}
diff --git a/user_libs/src/bin/13forktree.rs b/user_libs/src/bin/13forktree.rs
deleted file mode 100644
index 72125bd..0000000
--- a/user_libs/src/bin/13forktree.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{exit, fork, getpid, sched_yield, sleep, wait};
-
-const DEPTH: usize = 4;
-
-fn fork_child(cur: &str, branch: char) {
-    let mut next = [0u8; DEPTH + 1];
-    let l = cur.len();
-    if l >= DEPTH {
-        return;
-    }
-    next[..l].copy_from_slice(cur.as_bytes());
-    next[l] = branch as u8;
-    if fork() == 0 {
-        fork_tree(core::str::from_utf8(&next[..l + 1]).unwrap());
-        sched_yield();
-        exit(0);
-    }
-}
-
-fn fork_tree(cur: &str) {
-    println!("pid{}: {}", getpid(), cur);
-    fork_child(cur, '0');
-    fork_child(cur, '1');
-    let mut exit_code: i32 = 0;
-    for _ in 0..2 {
-        wait(&mut exit_code);
-    }
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    fork_tree("");
-    let mut exit_code: i32 = 0;
-    for _ in 0..2 {
-        wait(&mut exit_code);
-    }
-    sleep(3000);
-    0
-}
diff --git a/user_libs/src/bin/14forktest2.rs b/user_libs/src/bin/14forktest2.rs
deleted file mode 100644
index d256cd2..0000000
--- a/user_libs/src/bin/14forktest2.rs
+++ /dev/null
@@ -1,37 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{clock_gettime, exit, fork, getpid, sleep, wait, ClockId, TimeSpec};
-
-static NUM: usize = 30;
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for _ in 0..NUM {
-        let pid = fork();
-        if pid == 0 {
-            let mut time: TimeSpec = TimeSpec::ZERO;
-            clock_gettime(ClockId::CLOCK_MONOTONIC, &mut time as *mut _ as _);
-            let current_time = (time.tv_sec * 1000) + (time.tv_nsec / 1000000);
-            let sleep_length =
-                (current_time as i32 as isize) * (current_time as i32 as isize) % 1000 + 1000;
-            println!("pid {} sleep for {} ms", getpid(), sleep_length);
-            sleep(sleep_length as usize);
-            println!("pid {} OK!", getpid());
-            exit(0);
-        }
-    }
-
-    let mut exit_code: i32 = 0;
-    for _ in 0..NUM {
-        // println!("child {}", wait(&mut exit_code));
-        assert!(wait(&mut exit_code) > 0);
-        assert_eq!(exit_code, 0);
-    }
-    assert!(wait(&mut exit_code) < 0);
-    println!("forktest2 test passed!");
-    0
-}
diff --git a/user_libs/src/bin/15matrix.rs b/user_libs/src/bin/15matrix.rs
deleted file mode 100644
index f126b49..0000000
--- a/user_libs/src/bin/15matrix.rs
+++ /dev/null
@@ -1,71 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::needless_range_loop)]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{clock_gettime, exit, fork, getpid, sched_yield, wait, ClockId, TimeSpec};
-
-static NUM: usize = 30;
-const N: usize = 10;
-static P: i32 = 10007;
-type Arr = [[i32; N]; N];
-
-fn work(times: isize) {
-    let mut a: Arr = Default::default();
-    let mut b: Arr = Default::default();
-    let mut c: Arr = Default::default();
-    for i in 0..N {
-        for j in 0..N {
-            a[i][j] = 1;
-            b[i][j] = 1;
-        }
-    }
-    sched_yield();
-    println!("pid {} is running ({} times)!.", getpid(), times);
-    for _ in 0..times {
-        for i in 0..N {
-            for j in 0..N {
-                c[i][j] = 0;
-                for k in 0..N {
-                    c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % P;
-                }
-            }
-        }
-        for i in 0..N {
-            for j in 0..N {
-                a[i][j] = c[i][j];
-                b[i][j] = c[i][j];
-            }
-        }
-    }
-    println!("pid {} done!.", getpid());
-    exit(0);
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    for _ in 0..NUM {
-        let pid = fork();
-        if pid == 0 {
-            let mut time: TimeSpec = TimeSpec::ZERO;
-            clock_gettime(ClockId::CLOCK_MONOTONIC, &mut time as *mut _ as _);
-            let current_time = (time.tv_sec * 1000) + (time.tv_nsec / 1000000);
-            let times = (current_time as i32 as isize) * (current_time as i32 as isize) % 1000;
-            work(times * 10);
-        }
-    }
-
-    println!("fork ok.");
-
-    let mut exit_code: i32 = 0;
-    for _ in 0..NUM {
-        if wait(&mut exit_code) < 0 {
-            panic!("wait failed.");
-        }
-    }
-    assert!(wait(&mut exit_code) < 0);
-    println!("matrix passed.");
-    0
-}
diff --git a/user_libs/src/bin/cat_filea.rs b/user_libs/src/bin/cat_filea.rs
deleted file mode 100644
index 6307ecd..0000000
--- a/user_libs/src/bin/cat_filea.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use user_lib::{close, open, read, OpenFlags};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let fd = open("filea\0", OpenFlags::RDONLY);
-    if fd == -1 {
-        panic!("Error occured when opening file");
-    }
-    let fd = fd as usize;
-    let mut buf = [0u8; 256];
-    loop {
-        let size = read(fd, &mut buf) as usize;
-        if size == 0 {
-            break;
-        }
-        println!("{}", core::str::from_utf8(&buf[..size]).unwrap());
-    }
-    close(fd);
-    0
-}
diff --git a/user_libs/src/bin/filetest_simple.rs b/user_libs/src/bin/filetest_simple.rs
deleted file mode 100644
index 3406d55..0000000
--- a/user_libs/src/bin/filetest_simple.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-use user_lib::{close, open, read, write, OpenFlags};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let test_str = "Hello, world!";
-    let filea = "filea\0";
-    let fd = open(filea, OpenFlags::CREATE | OpenFlags::WRONLY);
-    assert!(fd > 0);
-    let fd = fd as usize;
-    write(fd, test_str.as_bytes());
-    close(fd);
-
-    let fd = open(filea, OpenFlags::RDONLY);
-    assert!(fd > 0);
-    let fd = fd as usize;
-    let mut buffer = [0u8; 100];
-    let read_len = read(fd, &mut buffer) as usize;
-    close(fd);
-
-    assert_eq!(test_str, core::str::from_utf8(&buffer[..read_len]).unwrap(),);
-    println!("file_test passed!");
-    0
-}
diff --git a/user_libs/src/bin/initproc.rs b/user_libs/src/bin/initproc.rs
deleted file mode 100644
index 3428680..0000000
--- a/user_libs/src/bin/initproc.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use user_lib::{exec, fork, sched_yield, wait};
-
-#[no_mangle]
-fn main() -> i32 {
-    if fork() == 0 {
-        // exec("user_shell\0", &[core::ptr::null::<u8>()]);
-        exec("user_shell");
-    } else {
-        loop {
-            let mut exit_code: i32 = 0;
-            let pid = wait(&mut exit_code);
-            if pid == -1 {
-                sched_yield();
-                continue;
-            }
-
-            // println!(
-            //     "[initproc] Released a zombie process, pid={}, exit_code={}",
-            //     pid,
-            //     exit_code,
-            // );
-        }
-    }
-    0
-}
diff --git a/user_libs/src/bin/mpsc_sem.rs b/user_libs/src/bin/mpsc_sem.rs
deleted file mode 100644
index b11bccd..0000000
--- a/user_libs/src/bin/mpsc_sem.rs
+++ /dev/null
@@ -1,73 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::println_empty_string)]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::exit;
-use user_lib::{semaphore_create, semaphore_down, semaphore_up};
-use user_lib::{thread_create, waittid};
-
-const SEM_MUTEX: usize = 0;
-const SEM_EMPTY: usize = 1;
-const SEM_EXISTED: usize = 2;
-const BUFFER_SIZE: usize = 8;
-static mut BUFFER: [usize; BUFFER_SIZE] = [0; BUFFER_SIZE];
-static mut FRONT: usize = 0;
-static mut TAIL: usize = 0;
-const PRODUCER_COUNT: usize = 4;
-const NUMBER_PER_PRODUCER: usize = 100;
-
-unsafe fn producer(id: *const usize) -> isize {
-    let id = *id;
-    for _ in 0..NUMBER_PER_PRODUCER {
-        semaphore_down(SEM_EMPTY);
-        semaphore_down(SEM_MUTEX);
-        BUFFER[FRONT] = id;
-        FRONT = (FRONT + 1) % BUFFER_SIZE;
-        semaphore_up(SEM_MUTEX);
-        semaphore_up(SEM_EXISTED);
-    }
-    exit(0)
-}
-
-unsafe fn consumer() -> isize {
-    for _ in 0..PRODUCER_COUNT * NUMBER_PER_PRODUCER {
-        semaphore_down(SEM_EXISTED);
-        semaphore_down(SEM_MUTEX);
-        print!("{} ", BUFFER[TAIL]);
-        TAIL = (TAIL + 1) % BUFFER_SIZE;
-        semaphore_up(SEM_MUTEX);
-        semaphore_up(SEM_EMPTY);
-    }
-    println!("");
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create semaphores
-    assert_eq!(semaphore_create(1) as usize, SEM_MUTEX);
-    assert_eq!(semaphore_create(BUFFER_SIZE) as usize, SEM_EMPTY);
-    assert_eq!(semaphore_create(0) as usize, SEM_EXISTED);
-    // create threads
-    let ids: Vec<_> = (0..PRODUCER_COUNT).collect();
-    let mut threads = Vec::new();
-    for i in 0..PRODUCER_COUNT {
-        threads.push(thread_create(
-            producer as usize,
-            &ids.as_slice()[i] as *const _ as usize,
-        ));
-    }
-    threads.push(thread_create(consumer as usize, 0));
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("mpsc_sem passed!");
-    0
-}
diff --git a/user_libs/src/bin/race_adder_mutex_blocking.rs b/user_libs/src/bin/race_adder_mutex_blocking.rs
deleted file mode 100644
index b486ee2..0000000
--- a/user_libs/src/bin/race_adder_mutex_blocking.rs
+++ /dev/null
@@ -1,52 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{clock_gettime, exit, thread_create, waittid, ClockId, TimeSpec};
-use user_lib::{mutex_create, mutex_lock, mutex_unlock};
-
-static mut A: usize = 0;
-const PER_THREAD: usize = 1000;
-const THREAD_COUNT: usize = 16;
-
-unsafe fn f() -> isize {
-    let mut t = 2usize;
-    for _ in 0..PER_THREAD {
-        mutex_lock(0);
-        let a = &mut A as *mut usize;
-        let cur = a.read_volatile();
-        for _ in 0..500 {
-            t = t * t % 10007;
-        }
-        a.write_volatile(cur + 1);
-        mutex_unlock(0);
-    }
-    exit(t as i32)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut start_time: TimeSpec = TimeSpec::ZERO;
-    let mut end_time: TimeSpec = TimeSpec::ZERO;
-    clock_gettime(ClockId::CLOCK_MONOTONIC, &mut start_time as *mut _ as _);
-    assert_eq!(mutex_create(true), 0);
-    let mut v = Vec::new();
-    for _ in 0..THREAD_COUNT {
-        v.push(thread_create(f as usize, 0) as usize);
-    }
-    let mut time_cost = Vec::new();
-    for tid in v.iter() {
-        time_cost.push(waittid(*tid));
-    }
-    clock_gettime(ClockId::CLOCK_MONOTONIC, &mut end_time as *mut _ as _);
-    let total_time = end_time.tv_sec * 1000 + end_time.tv_nsec / 1_000_000
-        - start_time.tv_sec * 1000
-        - start_time.tv_nsec / 1_000_000;
-    println!("time cost is {}ms", total_time);
-    assert_eq!(unsafe { A }, PER_THREAD * THREAD_COUNT);
-    0
-}
diff --git a/user_libs/src/bin/sig_ctrlc.rs b/user_libs/src/bin/sig_ctrlc.rs
deleted file mode 100644
index 9d48352..0000000
--- a/user_libs/src/bin/sig_ctrlc.rs
+++ /dev/null
@@ -1,40 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate alloc;
-
-extern crate user_lib;
-use user_lib::*;
-
-const LF: u8 = 0x0au8;
-const CR: u8 = 0x0du8;
-
-fn func() {
-    println!("signal_handler: caught signal SIGINT, and exit(1)");
-    exit(1);
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("sig_ctrlc starting....  Press 'ctrl-c' or 'ENTER'  will quit.");
-
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func as usize;
-
-    println!("sig_ctrlc: sigaction");
-    if sigaction(SignalNo::SIGINT, &new, &old) < 0 {
-        panic!("Sigaction failed!");
-    }
-    println!("sig_ctrlc: getchar....");
-    loop {
-        let c = getchar();
-
-        println!("Got Char  {}", c);
-        if c == LF || c == CR {
-            break;
-        }
-    }
-    println!("sig_ctrlc: Done");
-    0
-}
diff --git a/user_libs/src/bin/sig_simple.rs b/user_libs/src/bin/sig_simple.rs
deleted file mode 100644
index 5c91fe5..0000000
--- a/user_libs/src/bin/sig_simple.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use user_lib::*;
-
-fn func() {
-    println!("user_sig_test succsess");
-    sigreturn();
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func as usize;
-    println!("pid = {}", getpid());
-    println!("signal_simple: sigaction");
-    if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-        panic!("Sigaction failed!");
-    }
-    println!("signal_simple: kill");
-    if kill(getpid(), SignalNo::SIGUSR1) < 0 {
-        println!("Kill failed!");
-        exit(1);
-    }
-    println!("signal_simple: Done");
-    0
-}
diff --git a/user_libs/src/bin/sig_simple2.rs b/user_libs/src/bin/sig_simple2.rs
deleted file mode 100644
index c5980c9..0000000
--- a/user_libs/src/bin/sig_simple2.rs
+++ /dev/null
@@ -1,43 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use user_lib::*;
-
-fn func() {
-    println!("user_sig_test succsess");
-    sigreturn();
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let pid = fork();
-    if pid == 0 {
-        let mut new = SignalAction::default();
-        let old = SignalAction::default();
-        new.handler = func as usize;
-
-        println!("signal_simple2: child sigaction");
-        if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-            panic!("Sigaction failed!");
-        }
-        sleep(1000);
-        println!("signal_simple2: child done");
-        exit(0);
-    } else if pid > 0 {
-        println!("signal_simple2: parent kill child");
-        sleep(500);
-        if kill(pid, SignalNo::SIGUSR1) < 0 {
-            println!("Kill failed!");
-            exit(1);
-        }
-        println!("signal_simple2: parent wait child");
-        let mut exit_code = 0;
-        waitpid(pid, &mut exit_code);
-        println!("signal_simple2: parent Done");
-        exit(0);
-    }
-
-    0
-}
diff --git a/user_libs/src/bin/sig_tests.rs b/user_libs/src/bin/sig_tests.rs
deleted file mode 100644
index f5fbc79..0000000
--- a/user_libs/src/bin/sig_tests.rs
+++ /dev/null
@@ -1,208 +0,0 @@
-#![no_std]
-#![no_main]
-
-extern crate user_lib;
-
-use user_lib::*;
-
-fn func() {
-    println!("user_sig_test succsess");
-    sigreturn();
-}
-
-fn func2() {
-    loop {
-        print!("");
-    }
-}
-
-fn func3() {
-    println!("interrupt");
-    sigreturn();
-}
-
-fn user_sig_test_failsignum() {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func as usize;
-    if sigaction(50.into(), &new, &old) >= 0 {
-        panic!("Wrong sigaction but success!");
-    }
-}
-
-fn user_sig_test_kill() {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func as usize;
-
-    if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-        panic!("Sigaction failed!");
-    }
-    if kill(getpid(), SignalNo::SIGUSR1) < 0 {
-        println!("Kill failed!");
-        exit(1);
-    }
-}
-
-fn user_sig_test_multiprocsignals() {
-    let pid = fork();
-    if pid == 0 {
-        let mut new = SignalAction::default();
-        let old = SignalAction::default();
-        new.handler = func as usize;
-        if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-            panic!("Sigaction failed!");
-        }
-    } else {
-        if kill(pid, SignalNo::SIGUSR1) < 0 {
-            println!("Kill failed!");
-            exit(1);
-        }
-        let mut exit_code = 0;
-        wait(&mut exit_code);
-    }
-}
-
-fn user_sig_test_restore() {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    let old2 = SignalAction::default();
-    new.handler = func as usize;
-
-    if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-        panic!("Sigaction failed!");
-    }
-
-    if sigaction(SignalNo::SIGUSR1, &old, &old2) < 0 {
-        panic!("Sigaction failed!");
-    }
-
-    if old2.handler != new.handler {
-        println!("Restore failed!");
-        exit(-1);
-    }
-}
-
-fn kernel_sig_test_ignore() {
-    sigprocmask(1 << SignalNo::SIGSTOP as usize);
-    if kill(getpid(), SignalNo::SIGSTOP) < 0 {
-        println!("kill faild\n");
-        exit(-1);
-    }
-}
-
-fn kernel_sig_test_stop_cont() {
-    let pid = fork();
-    if pid == 0 {
-        kill(getpid(), SignalNo::SIGSTOP);
-        sleep(1000);
-        exit(-1);
-    } else {
-        sleep(5000);
-        kill(pid, SignalNo::SIGCONT);
-        let mut exit_code = 0;
-        wait(&mut exit_code);
-    }
-}
-
-fn kernel_sig_test_failignorekill() {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func as usize;
-
-    if sigaction(SignalNo::SIGKILL, &new, &old) >= 0 {
-        panic!("Should not set sigaction to kill!");
-    }
-
-    if sigaction(SignalNo::SIGKILL, &new, 0 as *const SignalAction) >= 0 {
-        panic!("Should not set sigaction to kill!");
-    }
-
-    if sigaction(SignalNo::SIGKILL, 0 as *const SignalAction, &old) >= 0 {
-        panic!("Should not set sigaction to kill!");
-    }
-}
-
-fn final_sig_test() {
-    let mut new = SignalAction::default();
-    let old = SignalAction::default();
-    new.handler = func2 as usize;
-
-    let mut new2 = SignalAction::default();
-    let old2 = SignalAction::default();
-    new2.handler = func3 as usize;
-
-    let pid = fork();
-    if pid == 0 {
-        if sigaction(SignalNo::SIGUSR1, &new, &old) < 0 {
-            panic!("Sigaction failed!");
-        }
-        if sigaction(14.into(), &new2, &old2) < 0 {
-            panic!("Sigaction failed!");
-        }
-        if kill(getpid(), SignalNo::SIGUSR1) < 0 {
-            println!("Kill failed!");
-            exit(-1);
-        }
-    } else {
-        sleep(1000);
-        if kill(pid, 14.into()) < 0 {
-            println!("Kill failed!");
-            exit(-1);
-        }
-        sleep(1000);
-        kill(pid, SignalNo::SIGKILL);
-    }
-}
-
-fn run(f: fn()) -> bool {
-    let pid = fork();
-    if pid == 0 {
-        f();
-        exit(0);
-        unreachable!()
-    } else {
-        let mut exit_code: i32 = 0;
-        wait(&mut exit_code);
-        if exit_code != 0 {
-            println!("FAILED!");
-        } else {
-            println!("OK!");
-        }
-        exit_code == 0
-    }
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let tests: [(fn(), &str); 8] = [
-        (user_sig_test_failsignum, "user_sig_test_failsignum"),
-        (user_sig_test_kill, "user_sig_test_kill"),
-        (
-            user_sig_test_multiprocsignals,
-            "user_sig_test_multiprocsignals",
-        ),
-        (user_sig_test_restore, "user_sig_test_restore"),
-        (kernel_sig_test_ignore, "kernel_sig_test_ignore"),
-        (kernel_sig_test_stop_cont, "kernel_sig_test_stop_cont"),
-        (
-            kernel_sig_test_failignorekill,
-            "kernel_sig_test_failignorekill",
-        ),
-        (final_sig_test, "final_sig_test"),
-    ];
-    let mut fail_num = 0;
-    for test in tests {
-        println!("Testing {}", test.1);
-        if !run(test.0) {
-            fail_num += 1;
-        }
-    }
-    if fail_num == 0 {
-        println!("ALL TESTS PASSED");
-        0
-    } else {
-        println!("SOME TESTS FAILED");
-        -1
-    }
-}
diff --git a/user_libs/src/bin/sync_sem.rs b/user_libs/src/bin/sync_sem.rs
deleted file mode 100644
index 8fddd9c..0000000
--- a/user_libs/src/bin/sync_sem.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::exit;
-use user_lib::{semaphore_create, semaphore_down, semaphore_up};
-use user_lib::{sleep, thread_create, waittid};
-
-const SEM_SYNC: usize = 0;
-
-unsafe fn first() -> isize {
-    sleep(10);
-    println!("First work and wakeup Second");
-    semaphore_up(SEM_SYNC);
-    exit(0)
-}
-
-unsafe fn second() -> isize {
-    println!("Second want to continue,but need to wait first");
-    semaphore_down(SEM_SYNC);
-    println!("Second can work now");
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create semaphores
-    assert_eq!(semaphore_create(0) as usize, SEM_SYNC);
-    // create threads
-    let threads = vec![
-        thread_create(first as usize, 0),
-        thread_create(second as usize, 0),
-    ];
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("sync_sem passed!");
-    0
-}
diff --git a/user_libs/src/bin/test_condvar.rs b/user_libs/src/bin/test_condvar.rs
deleted file mode 100644
index 25c146f..0000000
--- a/user_libs/src/bin/test_condvar.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::exit;
-use user_lib::{
-    condvar_create, condvar_signal, condvar_wait, mutex_create, mutex_lock, mutex_unlock,
-};
-use user_lib::{sleep, thread_create, waittid};
-
-static mut A: usize = 0;
-
-const CONDVAR_ID: usize = 0;
-const MUTEX_ID: usize = 0;
-
-unsafe fn first() -> isize {
-    sleep(10);
-    println!("First work, Change A --> 1 and wakeup Second");
-    mutex_lock(MUTEX_ID);
-    A = 1;
-    condvar_signal(CONDVAR_ID);
-    mutex_unlock(MUTEX_ID);
-    exit(0)
-}
-
-unsafe fn second() -> isize {
-    println!("Second want to continue,but need to wait A=1");
-    mutex_lock(MUTEX_ID);
-    while A == 0 {
-        println!("Second: A is {}", A);
-        condvar_wait(CONDVAR_ID, MUTEX_ID);
-    }
-    mutex_unlock(MUTEX_ID);
-    println!("A is {}, Second can work now", A);
-    exit(0)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    // create condvar & mutex
-    assert_eq!(condvar_create() as usize, CONDVAR_ID);
-    assert_eq!(mutex_create(true) as usize, MUTEX_ID);
-    // create threads
-    let threads = vec![
-        thread_create(first as usize, 0),
-        thread_create(second as usize, 0),
-    ];
-    // wait for all threads to complete
-    for thread in threads.iter() {
-        waittid(*thread as usize);
-    }
-    println!("test_condvar passed!");
-    0
-}
diff --git a/user_libs/src/bin/threads.rs b/user_libs/src/bin/threads.rs
deleted file mode 100644
index e47dac6..0000000
--- a/user_libs/src/bin/threads.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec;
-use user_lib::{exit, thread_create, waittid};
-
-pub fn thread_a() -> isize {
-    for _ in 0..1000 {
-        print!("a");
-    }
-    exit(1)
-}
-
-pub fn thread_b() -> isize {
-    for _ in 0..1000 {
-        print!("b");
-    }
-    exit(2)
-}
-
-pub fn thread_c() -> isize {
-    for _ in 0..1000 {
-        print!("c");
-    }
-    exit(3)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("threads test========");
-    let mut v = vec![
-        thread_create(thread_a as usize, 0),
-        thread_create(thread_b as usize, 0),
-        thread_create(thread_c as usize, 0),
-    ];
-    println!("v :{:?}", v);
-    let max_len = 5;
-    for i in 0..max_len {
-        println!("create tid: {}", i + 4);
-        let tid = thread_create(thread_b as usize, 0);
-        println!("create tid: {} end", i + 4);
-        v.push(tid);
-    }
-    println!("create end");
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    println!("==========================v size: {:?}", v);
-    0
-}
diff --git a/user_libs/src/bin/threads_arg.rs b/user_libs/src/bin/threads_arg.rs
deleted file mode 100644
index 7802f02..0000000
--- a/user_libs/src/bin/threads_arg.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-#![no_std]
-#![no_main]
-
-#[macro_use]
-extern crate user_lib;
-extern crate alloc;
-
-use alloc::vec::Vec;
-use user_lib::{exit, thread_create, waittid};
-
-struct Argument {
-    pub ch: char,
-    pub rc: i32,
-}
-
-fn thread_print(arg: *const Argument) -> isize {
-    let arg = unsafe { &*arg };
-    for _ in 0..1000 {
-        print!("{}", arg.ch);
-    }
-    exit(arg.rc)
-}
-
-#[no_mangle]
-pub fn main() -> i32 {
-    let mut v = Vec::new();
-    let args = [
-        Argument { ch: 'a', rc: 1 },
-        Argument { ch: 'b', rc: 2 },
-        Argument { ch: 'c', rc: 3 },
-    ];
-    for arg in args.iter() {
-        v.push(thread_create(
-            thread_print as usize,
-            arg as *const _ as usize,
-        ));
-    }
-    for tid in v.iter() {
-        let exit_code = waittid(*tid as usize);
-        println!("thread#{} exited with code {}", tid, exit_code);
-    }
-    println!("main thread exited.");
-    0
-}
diff --git a/user_libs/src/bin/user_shell.rs b/user_libs/src/bin/user_shell.rs
deleted file mode 100644
index 5dcdbdb..0000000
--- a/user_libs/src/bin/user_shell.rs
+++ /dev/null
@@ -1,63 +0,0 @@
-#![no_std]
-#![no_main]
-#![allow(clippy::println_empty_string)]
-
-extern crate alloc;
-
-#[macro_use]
-extern crate user_lib;
-
-const LF: u8 = 0x0au8;
-const CR: u8 = 0x0du8;
-const DL: u8 = 0x7fu8;
-const BS: u8 = 0x08u8;
-
-use alloc::string::String;
-use user_lib::{exec, fork, getchar, waitpid};
-
-#[no_mangle]
-pub fn main() -> i32 {
-    println!("Rust user shell");
-    let mut line: String = String::new(); // 记录着当前输入的命令
-    print!(">> ");
-    loop {
-        let c = getchar();
-        match c {
-            LF | CR => {
-                // 换行
-                println!();
-                if !line.is_empty() {
-                    let pid = fork();
-                    if pid == 0 {
-                        // child process
-                        if exec(line.as_str()) == -1 {
-                            println!("Error when executing!");
-                            return -4;
-                        }
-                        unreachable!();
-                    } else {
-                        let mut exit_code: i32 = 0;
-                        let exit_pid = waitpid(pid as isize, &mut exit_code);
-                        assert_eq!(pid, exit_pid);
-                        println!("Shell: Process {} exited with code {}", pid, exit_code);
-                    }
-                    line.clear();
-                }
-                print!(">> ");
-            }
-            BS | DL => {
-                // backspace
-                if !line.is_empty() {
-                    print!("{}", BS as char);
-                    print!(" ");
-                    print!("{}", BS as char);
-                    line.pop();
-                }
-            }
-            _ => {
-                print!("{}", c as char);
-                line.push(c as char);
-            }
-        }
-    }
-}
diff --git a/user_libs/src/heap.rs b/user_libs/src/heap.rs
deleted file mode 100644
index 591d32a..0000000
--- a/user_libs/src/heap.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿use alloc::alloc::handle_alloc_error;
-use core::{
-    alloc::{GlobalAlloc, Layout},
-    ptr::NonNull,
-};
-use customizable_buddy::{BuddyAllocator, LinkedListBuddy, UsizeBuddy};
-
-/// 初始化全局分配器和内核堆分配器。
-pub fn init() {
-    // 托管空间 16 KiB
-    const MEMORY_SIZE: usize = 16 << 10;
-    static mut MEMORY: [u8; MEMORY_SIZE] = [0u8; MEMORY_SIZE];
-    unsafe {
-        HEAP.init(
-            core::mem::size_of::<usize>().trailing_zeros() as _,
-            NonNull::new(MEMORY.as_mut_ptr()).unwrap(),
-        );
-        HEAP.transfer(NonNull::new_unchecked(MEMORY.as_mut_ptr()), MEMORY.len());
-    }
-}
-
-type MutAllocator<const N: usize> = BuddyAllocator<N, UsizeBuddy, LinkedListBuddy>;
-static mut HEAP: MutAllocator<32> = MutAllocator::new();
-
-struct Global;
-
-#[global_allocator]
-static GLOBAL: Global = Global;
-
-unsafe impl GlobalAlloc for Global {
-    #[inline]
-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
-        if let Ok((ptr, _)) = HEAP.allocate_layout::<u8>(layout) {
-            ptr.as_ptr()
-        } else {
-            handle_alloc_error(layout)
-        }
-    }
-
-    #[inline]
-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
-        HEAP.deallocate_layout(NonNull::new(ptr).unwrap(), layout)
-    }
-}
diff --git a/user_libs/src/lib.rs b/user_libs/src/lib.rs
deleted file mode 100644
index 7a3db81..0000000
--- a/user_libs/src/lib.rs
+++ /dev/null
@@ -1,81 +0,0 @@
-#![no_std]
-#![feature(linkage)]
-#![feature(panic_info_message)]
-#![feature(alloc_error_handler)]
-
-mod heap;
-
-extern crate alloc;
-
-use core::alloc::Layout;
-use rcore_console::log;
-
-pub use rcore_console::{print, println};
-pub use syscall::*;
-
-#[no_mangle]
-#[link_section = ".text.entry"]
-pub extern "C" fn _start() -> ! {
-    rcore_console::init_console(&Console);
-    rcore_console::set_log_level(option_env!("LOG"));
-    heap::init();
-    exit(main());
-    unreachable!()
-}
-
-#[linkage = "weak"]
-#[no_mangle]
-fn main() -> i32 {
-    panic!("Cannot find main!");
-}
-
-#[panic_handler]
-fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! {
-    let err = panic_info.message().unwrap();
-    if let Some(location) = panic_info.location() {
-        log::error!("Panicked at {}:{}, {err}", location.file(), location.line());
-    } else {
-        log::error!("Panicked: {err}");
-    }
-    exit(1);
-    unreachable!()
-}
-
-#[alloc_error_handler]
-fn alloc_error_handler(layout: Layout) -> ! {
-    panic!("Failed to alloc {layout:?}")
-}
-
-pub fn getchar() -> u8 {
-    let mut c = [0u8; 1];
-    read(STDIN, &mut c);
-    c[0]
-}
-
-struct Console;
-
-impl rcore_console::Console for Console {
-    #[inline]
-    fn put_char(&self, c: u8) {
-        syscall::write(STDOUT, &[c]);
-    }
-
-    #[inline]
-    fn put_str(&self, s: &str) {
-        syscall::write(STDOUT, s.as_bytes());
-    }
-}
-
-pub fn sleep(period_ms: usize) {
-    let mut time: TimeSpec = TimeSpec::ZERO;
-    clock_gettime(ClockId::CLOCK_MONOTONIC, &mut time as *mut _ as _);
-    let time = time + TimeSpec::from_millsecond(period_ms);
-    loop {
-        let mut now: TimeSpec = TimeSpec::ZERO;
-        clock_gettime(ClockId::CLOCK_MONOTONIC, &mut now as *mut _ as _);
-        if now > time {
-            break;
-        }
-        sched_yield();
-    }
-}
diff --git a/vm/Cargo.toml b/vm/Cargo.toml
deleted file mode 100644
index c29e46c..0000000
--- a/vm/Cargo.toml
+++ /dev/null
@@ -1,10 +0,0 @@
-[package]
-name = "vm"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-spin = "0.9.4"
-page-table = "0.0.6"
\ No newline at end of file
diff --git a/vm/src/lib.rs b/vm/src/lib.rs
deleted file mode 100644
index ad4a774..0000000
--- a/vm/src/lib.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-//! 内核虚存管理。
-
-#![no_std]
-#![deny(warnings, missing_docs)]
-
-mod space;
-
-pub extern crate page_table;
-pub use space::AddressSpace;
-
-use core::ptr::NonNull;
-use page_table::{Pte, VmFlags, VmMeta, PPN};
-
-/// 物理页管理。
-pub trait PageManager<Meta: VmMeta> {
-    /// 新建根页表页。
-    fn new_root() -> Self;
-
-    /// 获取根页表。
-    fn root_ptr(&self) -> NonNull<Pte<Meta>>;
-
-    /// 获取根页表的物理页号。
-    #[inline]
-    fn root_ppn(&self) -> PPN<Meta> {
-        self.v_to_p(self.root_ptr())
-    }
-
-    /// 计算当前地址空间上指向物理页的指针。
-    fn p_to_v<T>(&self, ppn: PPN<Meta>) -> NonNull<T>;
-
-    /// 计算当前地址空间上的指针指向的物理页。
-    fn v_to_p<T>(&self, ptr: NonNull<T>) -> PPN<Meta>;
-
-    /// 检查是否拥有一个页的所有权。
-    fn check_owned(&self, pte: Pte<Meta>) -> bool;
-
-    /// 为地址空间分配 `len` 个物理页。
-    fn allocate(&mut self, len: usize, flags: &mut VmFlags<Meta>) -> NonNull<u8>;
-
-    /// 从地址空间释放 `pte` 指示的 `len` 个物理页。
-    fn deallocate(&mut self, pte: Pte<Meta>, len: usize) -> usize;
-
-    /// 释放根页表。
-    fn drop_root(&mut self);
-}
diff --git a/vm/src/space/mapper.rs b/vm/src/space/mapper.rs
deleted file mode 100644
index 772aa69..0000000
--- a/vm/src/space/mapper.rs
+++ /dev/null
@@ -1,69 +0,0 @@
-use crate::{AddressSpace, PageManager};
-use core::{ops::Range, ptr::NonNull};
-use page_table::{Decorator, Pos, Pte, Update, VmFlags, VmMeta, PPN};
-
-pub(super) struct Mapper<'a, Meta: VmMeta, M: PageManager<Meta>> {
-    space: &'a mut AddressSpace<Meta, M>,
-    range: Range<PPN<Meta>>,
-    flags: VmFlags<Meta>,
-    done: bool,
-}
-
-impl<'a, Meta: VmMeta, M: PageManager<Meta>> Mapper<'a, Meta, M> {
-    #[inline]
-    pub fn new(
-        space: &'a mut AddressSpace<Meta, M>,
-        range: Range<PPN<Meta>>,
-        flags: VmFlags<Meta>,
-    ) -> Self {
-        Self {
-            space,
-            range,
-            flags,
-            done: false,
-        }
-    }
-
-    #[inline]
-    pub fn ans(self) -> bool {
-        self.done
-    }
-}
-
-impl<Meta: VmMeta, M: PageManager<Meta>> Decorator<Meta> for Mapper<'_, Meta, M> {
-    #[inline]
-    fn arrive(&mut self, pte: &mut Pte<Meta>, target_hint: Pos<Meta>) -> Pos<Meta> {
-        assert!(!pte.is_valid());
-        *pte = self.flags.build_pte(self.range.start);
-        self.range.start += 1;
-        if self.range.start == self.range.end {
-            self.done = true;
-            Pos::stop()
-        } else {
-            target_hint.next()
-        }
-    }
-
-    #[inline]
-    fn meet(
-        &mut self,
-        _level: usize,
-        pte: Pte<Meta>,
-        _target_hint: Pos<Meta>,
-    ) -> Option<NonNull<Pte<Meta>>> {
-        if self.space.page_manager.check_owned(pte) {
-            Some(self.space.page_manager.p_to_v(pte.ppn()))
-        } else {
-            None
-        }
-    }
-
-    #[inline]
-    fn block(&mut self, _level: usize, pte: Pte<Meta>, _target_hint: Pos<Meta>) -> Update<Meta> {
-        assert!(!pte.is_valid());
-        let mut flags = VmFlags::VALID;
-        let page = self.space.page_manager.allocate(1, &mut flags);
-        let ppn = self.space.page_manager.v_to_p(page);
-        Update::Pte(flags.build_pte(ppn), page.cast())
-    }
-}
diff --git a/vm/src/space/mod.rs b/vm/src/space/mod.rs
deleted file mode 100644
index 96c445c..0000000
--- a/vm/src/space/mod.rs
+++ /dev/null
@@ -1,147 +0,0 @@
-mod mapper;
-mod visitor;
-
-extern crate alloc;
-
-use crate::PageManager;
-use alloc::vec::Vec;
-use core::{fmt, ops::Range, ptr::NonNull};
-use mapper::Mapper;
-use page_table::{PageTable, PageTableFormatter, Pos, VAddr, VmFlags, VmMeta, PPN, VPN};
-use visitor::Visitor;
-
-/// 地址空间。
-pub struct AddressSpace<Meta: VmMeta, M: PageManager<Meta>> {
-    /// 虚拟地址块
-    pub areas: Vec<Range<VPN<Meta>>>,
-    page_manager: M,
-}
-
-impl<Meta: VmMeta, M: PageManager<Meta>> AddressSpace<Meta, M> {
-    /// 创建新地址空间。
-    #[inline]
-    pub fn new() -> Self {
-        Self {
-            areas: Vec::new(),
-            page_manager: M::new_root(),
-        }
-    }
-
-    /// 地址空间根页表的物理页号。
-    #[inline]
-    pub fn root_ppn(&self) -> PPN<Meta> {
-        self.page_manager.root_ppn()
-    }
-
-    /// 地址空间根页表
-    #[inline]
-    pub fn root(&self) -> PageTable<Meta> {
-        unsafe { PageTable::from_root(self.page_manager.root_ptr()) }
-    }
-
-    /// 向地址空间增加映射关系。
-    pub fn map_extern(&mut self, range: Range<VPN<Meta>>, pbase: PPN<Meta>, flags: VmFlags<Meta>) {
-        self.areas.push(range.start..range.end);
-        let count = range.end.val() - range.start.val();
-        let mut root = self.root();
-        let mut mapper = Mapper::new(self, pbase..pbase + count, flags);
-        root.walk_mut(Pos::new(range.start, 0), &mut mapper);
-        if !mapper.ans() {
-            // 映射失败，需要回滚吗？
-            todo!()
-        }
-    }
-
-    /// 分配新的物理页，拷贝数据并建立映射。
-    pub fn map(
-        &mut self,
-        range: Range<VPN<Meta>>,
-        data: &[u8],
-        offset: usize,
-        mut flags: VmFlags<Meta>,
-    ) {
-        let count = range.end.val() - range.start.val();
-        let size = count << Meta::PAGE_BITS;
-        assert!(size >= data.len() + offset);
-        let page = self.page_manager.allocate(count, &mut flags);
-        unsafe {
-            use core::slice::from_raw_parts_mut as slice;
-            let mut ptr = page.as_ptr();
-            slice(ptr, offset).fill(0);
-            ptr = ptr.add(offset);
-            slice(ptr, data.len()).copy_from_slice(data);
-            ptr = ptr.add(data.len());
-            slice(ptr, page.as_ptr().add(size).offset_from(ptr) as _).fill(0);
-        }
-        self.map_extern(range, self.page_manager.v_to_p(page), flags)
-    }
-
-    /// 检查 `flags` 的属性要求，然后将地址空间中的一个虚地址翻译成当前地址空间中的指针。
-    pub fn translate<T>(&self, addr: VAddr<Meta>, flags: VmFlags<Meta>) -> Option<NonNull<T>> {
-        let mut visitor = Visitor::new(self);
-        self.root().walk(Pos::new(addr.floor(), 0), &mut visitor);
-        visitor
-            .ans()
-            .filter(|pte| pte.flags().contains(flags))
-            .map(|pte| unsafe {
-                NonNull::new_unchecked(
-                    self.page_manager
-                        .p_to_v::<u8>(pte.ppn())
-                        .as_ptr()
-                        .add(addr.offset())
-                        .cast(),
-                )
-            })
-    }
-
-    /// 遍历地址空间，将其中的地址映射添加进自己的地址空间中，重新分配物理页并拷贝所有数据及代码
-    pub fn cloneself(&self, new_addrspace: &mut AddressSpace<Meta, M>) {
-        let root = self.root();
-        let areas = &self.areas;
-        for (_, range) in areas.iter().enumerate() {
-            let mut visitor = Visitor::new(self);
-            // 虚拟地址块的首地址的 vpn
-            let vpn = range.start;
-            // 利用 visitor 访问页表，并获取这个虚拟地址块的页属性
-            root.walk(Pos::new(vpn, 0), &mut visitor);
-            // 利用 visitor 获取这个虚拟地址块的页属性，以及起始地址
-            let (mut flags, mut data_ptr) = visitor
-                .ans()
-                .filter(|pte| pte.is_valid())
-                .map(|pte| {
-                    (pte.flags(), unsafe {
-                        NonNull::new_unchecked(self.page_manager.p_to_v::<u8>(pte.ppn()).as_ptr())
-                    })
-                })
-                .unwrap();
-            let vpn_range = range.start..range.end;
-            // 虚拟地址块中页数量
-            let count = range.end.val() - range.start.val();
-            let size = count << Meta::PAGE_BITS;
-            // 分配 count 个 flags 属性的物理页面
-            let paddr = new_addrspace.page_manager.allocate(count, &mut flags);
-            let ppn = new_addrspace.page_manager.v_to_p(paddr);
-            unsafe {
-                use core::slice::from_raw_parts_mut as slice;
-                let data = slice(data_ptr.as_mut(), size);
-                let ptr = paddr.as_ptr();
-                slice(ptr, size).copy_from_slice(data);
-            }
-            new_addrspace.map_extern(vpn_range, ppn, flags);
-        }
-    }
-}
-
-impl<Meta: VmMeta, P: PageManager<Meta>> fmt::Debug for AddressSpace<Meta, P> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        writeln!(f, "root: {:#x}", self.root_ppn().val())?;
-        write!(
-            f,
-            "{:?}",
-            PageTableFormatter {
-                pt: self.root(),
-                f: |ppn| self.page_manager.p_to_v(ppn)
-            }
-        )
-    }
-}
diff --git a/vm/src/space/visitor.rs b/vm/src/space/visitor.rs
deleted file mode 100644
index adf276d..0000000
--- a/vm/src/space/visitor.rs
+++ /dev/null
@@ -1,45 +0,0 @@
-use crate::{AddressSpace, PageManager};
-use core::ptr::NonNull;
-use page_table::{Pos, Pte, VmMeta};
-
-pub(super) struct Visitor<'a, Meta: VmMeta, M: PageManager<Meta>> {
-    space: &'a AddressSpace<Meta, M>,
-    ans: Option<Pte<Meta>>,
-}
-
-impl<'a, Meta: VmMeta, M: PageManager<Meta>> Visitor<'a, Meta, M> {
-    #[inline]
-    pub const fn new(space: &'a AddressSpace<Meta, M>) -> Self {
-        Self { space, ans: None }
-    }
-
-    #[inline]
-    pub const fn ans(self) -> Option<Pte<Meta>> {
-        self.ans
-    }
-}
-
-impl<'a, Meta: VmMeta, M: PageManager<Meta>> page_table::Visitor<Meta> for Visitor<'a, Meta, M> {
-    #[inline]
-    fn arrive(&mut self, pte: Pte<Meta>, _target_hint: Pos<Meta>) -> Pos<Meta> {
-        if pte.is_valid() {
-            self.ans = Some(pte);
-        }
-        Pos::stop()
-    }
-
-    #[inline]
-    fn meet(
-        &mut self,
-        _level: usize,
-        pte: Pte<Meta>,
-        _target_hint: Pos<Meta>,
-    ) -> Option<NonNull<Pte<Meta>>> {
-        Some(self.space.page_manager.p_to_v(pte.ppn()))
-    }
-
-    #[inline]
-    fn block(&mut self, _level: usize, _pte: Pte<Meta>, _target: Pos<Meta>) -> Pos<Meta> {
-        Pos::stop()
-    }
-}
-- 
2.34.1

